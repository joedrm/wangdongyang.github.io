<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="那年星空" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="声明引入类型、运算符、变量以及其他名称和构造。 声明将在程序中引入一个新的名称或构造例如，你使用声明来引入函数和方法，引入变量和常量，以及定义枚举、结构体、类和协议类型。你还可以使用声明来扩展现有具名类型的行为，并将其他地方声明的符号引入到你的程序中。 在 Swift 中，大多数声明也是定义，因为它们在声明的同时被实现或初始化。但由于协议不实现它的成员，所以协议成员在此仅仅是声明。为了方便起见，而">
<meta property="og:type" content="website">
<meta property="og:title" content="那年星空">
<meta property="og:url" content="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/ReferenceManual/Declarations.html">
<meta property="og:site_name" content="那年星空">
<meta property="og:description" content="声明引入类型、运算符、变量以及其他名称和构造。 声明将在程序中引入一个新的名称或构造例如，你使用声明来引入函数和方法，引入变量和常量，以及定义枚举、结构体、类和协议类型。你还可以使用声明来扩展现有具名类型的行为，并将其他地方声明的符号引入到你的程序中。 在 Swift 中，大多数声明也是定义，因为它们在声明的同时被实现或初始化。但由于协议不实现它的成员，所以协议成员在此仅仅是声明。为了方便起见，而">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-08T08:32:48.729Z">
<meta property="article:modified_time" content="2025-03-08T08:32:48.729Z">
<meta property="article:author" content="joe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/ReferenceManual/Declarations">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | 那年星空
  </title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6ad7c0c3175207d3b8885d6a63355af1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">那年星空</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content">
            

  <div class="posts-expand">
    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/course/">COURSE</a></li>
            <li><a href="/course/ios/">IOS</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/">THE-SWIFT-PROGRAMMING-LANGUAGE-IN-CHINESE-6.0</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/ReferenceManual/">REFERENCEMANUAL</a></li>
            <li>DECLARATIONS</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <html><head></head><body></body></html><html><head></head><body><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>引入类型、运算符、变量以及其他名称和构造。</p>
<p><em>声明</em>将在程序中引入一个新的名称或构造例如，你使用声明来引入函数和方法，引入变量和常量，以及定义枚举、结构体、类和协议类型。你还可以使用声明来扩展现有具名类型的行为，并将其他地方声明的符号引入到你的程序中。</p>
<p>在 Swift 中，大多数声明也是定义，因为它们在声明的同时被实现或初始化。但由于协议不实现它的成员，所以协议成员在此仅仅是声明。为了方便起见，而且这种区别在 Swift 中没那么重要，所以术语<em>声明</em>涵盖了声明和定义两种含义。</p>
<blockquote>
<p>声明的语法:</p>
<p><em>declaration</em> → <em>import-declaration</em> <br><em>declaration</em> → <em>constant-declaration</em> <br><em>declaration</em> → <em>variable-declaration</em> <br><em>declaration</em> → <em>typealias-declaration</em> <br><em>declaration</em> → <em>function-declaration</em> <br><em>declaration</em> → <em>enum-declaration</em> <br><em>declaration</em> → <em>struct-declaration</em> <br><em>declaration</em> → <em>class-declaration</em> <br><em>declaration</em> → <em>actor-declaration</em> <br><em>declaration</em> → <em>protocol-declaration</em> <br><em>declaration</em> → <em>initializer-declaration</em> <br><em>declaration</em> → <em>deinitializer-declaration</em> <br><em>declaration</em> → <em>extension-declaration</em> <br><em>declaration</em> → <em>subscript-declaration</em> <br><em>declaration</em> → <em>macro-declaration</em> <br><em>declaration</em> → <em>operator-declaration</em> <br><em>declaration</em> → <em>precedence-group-declaration</em></p>
</blockquote>
<h2 id="顶级代码"><a href="#顶级代码" class="headerlink" title="顶级代码"></a>顶级代码</h2><p>Swift 源文件中的顶级代码由零个或多个语句、声明和表达式组成。默认情况下，在源文件顶层声明的变量、常量和其他具名声明可以被同一模块中每个源文件的代码访问。你可以使用访问级别修饰符来重写此默认行为，具体说明见 <a href="doc:Declarations#访问控制级别">doc:Declarations#访问控制级别</a>。</p>
<p>有两种类型的顶级代码：顶级声明和可执行的顶级代码。顶级声明仅由声明组成，允许出现在所有 Swift 源文件中。可执行的顶级代码包含语句和表达式，而不仅仅是声明，仅允许作为程序的顶级入口点。</p>
<p>编译 Swift 代码生成可执行文件时，无论文件和模块中的代码如何组织，都只能通过以下方法之一来指定顶级入口点：<code>main</code> 特性、<code>NSApplicationMain</code> 特性、<code>UIApplicationMain</code> 特性、<code>main.swift</code> 文件，或包含顶级可执行代码的文件。</p>
<blockquote>
<p>顶级声明的语法:</p>
<p><em>top-level-declaration</em> → <em>statements</em><em>?</em></p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p><em>代码块</em>被各种声明和控制结构用来将语句组合在一起。它具有以下形式：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码块中的<em>语句</em>包括声明、表达式和其他类型的语句，并按它们在源代码中出现的顺序执行。</p>
<!--
  TR: What exactly are the scope rules for Swift?
-->

<!--
  TODO: Discuss scope.  I assume a code block creates a new scope?
-->

<blockquote>
<p>代码块的语法:</p>
<p><em>code-block</em> → <strong><code>{</code></strong> <em>statements</em><em>?</em> <strong><code>}</code></strong></p>
</blockquote>
<h2 id="导入声明"><a href="#导入声明" class="headerlink" title="导入声明"></a>导入声明</h2><p><em>导入声明</em>允许你访问在当前文件之外声明的符号。基本形式是导入整个模块；它由 <code>import</code> 关键字后跟模块名称组成。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;#module#&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>提供更多细节可以限制导入哪些符号——可以指定特定的子模块，也可以指定模块或子模块中特定的声明。使用这种限制后，在当前作用域中，只有被导入的符号是可用的，而不是整个模块中的所有声明。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;#<span class="keyword">import</span> kind#&gt; &lt;#module#&gt;.&lt;#symbol name#&gt;</span><br><span class="line"><span class="keyword">import</span> &lt;#module#&gt;.&lt;#submodule#&gt;</span><br></pre></td></tr></tbody></table></figure>

<!--
  TODO: Need to add more to this section.
-->

<blockquote>
<p>导入声明的语法:</p>
<p><em>import-declaration</em> → <em>attributes</em><em>?</em> <strong><code>import</code></strong> <em>import-kind</em><em>?</em> <em>import-path</em></p>
<p><em>import-kind</em> → <strong><code>typealias</code></strong> | <strong><code>struct</code></strong> | <strong><code>class</code></strong> | <strong><code>enum</code></strong> | <strong><code>protocol</code></strong> | <strong><code>let</code></strong> | <strong><code>var</code></strong> | <strong><code>func</code></strong> <br><em>import-path</em> → <em>identifier</em> | <em>identifier</em> <strong><code>.</code></strong> <em>import-path</em></p>
</blockquote>
<h2 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h2><p><em>常量声明</em>会在你的程序中引入一个具名的常量值。常量声明使用 <code>let</code> 关键字，形式如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="operator">&lt;</span>#constant name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#type#<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>#expression#<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>常量声明定义了<em>常量名称</em>与构造器<em>表达式</em>的值之间的不可变绑定；一旦常量的被赋值，就无法更改。也就是说，如果常量是用类对象初始化的，对象本身可以改变，但常量名称与它所指向的对象之间的绑定不能改变。</p>
<p>当常量声明在全局作用域时，常量必须赋值。当常量声明在函数或者方法的上下文中时，可以稍后初始化，只要保证在第一次读取其值之前已为其赋值。如果编译器能够证明常量的值从未被读取，则不要求该常量必须赋值。此分析称为<em>确定初始化</em>——编译器保证一个值在读取之前值已被赋值。</p>
<blockquote>
<p>注意:<br>确定初始化无法分析包含特定领域的内容，并且对条件语句中的状态跟踪能力也有限。如果你可以确定常量始终有一个值，但编译器无法证明这一点，请尝试简化设置该值的代码路径，或改用变量声明。</p>
</blockquote>
<!--
In the most general case,
DI reduces to the halting problem,
as shown by Rice's theorem.
-->

<p>当常量声明出现在类或结构体声明的上下文中时，它被视为一个<em>常量属性</em>。常量声明不是计算属性，因此没有 getter 或 setter。</p>
<p>如果<em>常量名称</em>是元组形式，元组中每一项的名称都会和初始化<em>表达式</em>中对应的值进行绑定。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (firstNumber, secondNumber) <span class="operator">=</span> (<span class="number">10</span>, <span class="number">42</span>)</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `constant-decl`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let (firstNumber, secondNumber) = (10, 42)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>在这个例子中，<code>firstNumber</code> 是值 <code>10</code> 的具名常量，而 <code>secondNumber</code> 是值 <code>42</code> 的具名常量。现在这两个常量可以独立使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The first number is <span class="subst">\(firstNumber)</span>.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;The first number is 10.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The second number is <span class="subst">\(secondNumber)</span>.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;The second number is 42.&quot;</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `constant-decl`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; print(&quot;The first number is \(firstNumber).&quot;)</span><br><span class="line">&lt;- The first number is 10.</span><br><span class="line">-&gt; print(&quot;The second number is \(secondNumber).&quot;)</span><br><span class="line">&lt;- The second number is 42.</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>在常量声明中，当可以推断出<em>常量名称</em>的类型时，类型注释（<code>:</code> <em>type</em>）是可选的，详见 <a href="doc:Types#类型推断">doc:Types#类型推断</a>。</p>
<p>要声明一个常量类型属性，请使用 <code>static</code> 声明修饰符标记该声明。类的常量类型属性总是隐式为 final；你无法用 class 或 final 声明修饰符实现允许或禁止被子类重写的目的。类型属性的讨论请参见 <a href="doc:Properties#类型属性">doc:Properties#类型属性</a>。</p>
<!--
  - test: `class-constants-cant-have-class-or-final`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; class Super &#123; class let x = 10 &#125;</span><br><span class="line">!$ error: class stored properties not supported in classes; did you mean &#x27;static&#x27;?</span><br><span class="line">!! class Super &#123; class let x = 10 &#125;</span><br><span class="line">!!               ~~~~~     ^</span><br><span class="line">-&gt; class S &#123; static final let x = 10 &#125;</span><br><span class="line">!$ error: static declarations are already final</span><br><span class="line">!! class S &#123; static final let x = 10 &#125;</span><br><span class="line">!!                  ^~~~~~</span><br><span class="line">!!-</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>有关常量的更多信息以及何时使用它们的指导，请参见 <a href="doc:TheBasics#常量和变量">doc:TheBasics#常量和变量</a> 和 <a href="doc:Properties#存储属性">doc:Properties#存储属性</a>。</p>
<blockquote>
<p>常量声明的语法</p>
<p><em>constant-declaration</em> → <em>attributes</em><em>?</em> <em>declaration-modifiers</em><em>?</em> <strong><code>let</code></strong> <em>pattern-initializer-list</em></p>
<p><em>pattern-initializer-list</em> → <em>pattern-initializer</em> | <em>pattern-initializer</em> <strong><code>,</code></strong> <em>pattern-initializer-list</em> <br><em>pattern-initializer</em> → <em>pattern</em> <em>initializer</em><em>?</em> <br><em>initializer</em> → <strong><code>=</code></strong> <em>expression</em></p>
</blockquote>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p><em>变量声明</em>会在你的程序中引入一个具名的变量值，并使用 <code>var</code> 关键字进行声明。</p>
<p>变量声明有多种形式，用于定义各种有名称的、可变的值，包括存储变量和计算变量及属性、存储变量和属性观察者，以及静态变量属性。使用哪种形式取决于变量声明的作用域以及你打算声明的变量类型。</p>
<blockquote>
<p>注意:<br>你还可以在协议声明的上下文中声明属性，参见 <a href="doc:Declarations#协议属性声明">doc:Declarations#协议属性声明</a>。</p>
</blockquote>
<p>你可以通过在子类的属性声明中标记 <code>override</code> 声明修饰符来重写属性，参见 <a href="doc:Inheritance#重写">doc:Inheritance#重写</a>。</p>
<h3 id="存储变量和存储变量属性"><a href="#存储变量和存储变量属性" class="headerlink" title="存储变量和存储变量属性"></a>存储变量和存储变量属性</h3><p>以下形式声明了一个存储变量或存储变量属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="operator">&lt;</span>#variable name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#type#<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>#expression#<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以在全局作用域、函数的局部作用域，类或结构体声明的上下文中定义这种形式的变量声明。当这种形式的变量声明在全局作用域或函数的全局作用域内声明时，它被称为<em>存储变量</em>。当它在类或结构体声明的上下文中声明时，它被称为<em>存储变量属性</em>。</p>
<p>构造器<em>表达式</em>不能出现在协议声明中，但在其他场景下，构造器<em>表达式</em>是可选的。也就是说，如果没有构造器<em>表达式</em>，变量声明必须包含显式类型注释（<code>:</code> <em>type</em>）。</p>
<p>与常量声明一样，如果变量声明省略了构造器<em>表达式</em>，则在第一次读取该变量之前必须为其设置一个值。同样，如果<em>变量名</em>是一个元组模式，则元组中每个项的名称都绑定到构造器<em>表达式</em>中的相应值。</p>
<p>如其名称所示，存储变量或存储变量属性的值存储在内存中。</p>
<h3 id="计算变量和计算属性"><a href="#计算变量和计算属性" class="headerlink" title="计算变量和计算属性"></a>计算变量和计算属性</h3><p>以下形式声明了一个计算变量或计算属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="operator">&lt;</span>#variable name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#type#<span class="operator">&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">set</span>(<span class="operator">&lt;</span>#setter name#<span class="operator">&gt;</span>) &#123;</span><br><span class="line">      <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在全局作用域、函数的全局作用域或类、结构体、枚举或扩展声明的上下文中定义这种形式的变量声明。当这种形式的变量声明在全局作用域或函数的全局作用域内声明时，它被称为<em>计算变量</em>。当它在类、结构体或扩展声明的上下文中声明时，它被称为<em>计算属性</em>。</p>
<p>getter 用于读取值，setter 用于写入值。setter 子句是可选的，当只需要 getter 时，可以省略两个子句，直接返回请求的值，参见 <a href="doc:Properties#只读计算属性">doc:Properties#只读计算属性</a>。但如果提供了 setter 子句，则必须同时提供 getter 子句。</p>
<p><em>setter 名称</em>和括号是可选的。如果你提供了 setter 名称，它将用作 setter 参数的名称。如果你不提供 setter 名称，setter 的默认参数名称是 <code>newValue</code>，参见 <a href="doc:Properties#简写Setter声明">doc:Properties#简写Setter声明</a>。</p>
<p>与存储的具名值和存储的变量属性不同，计算的具名值或计算属性的值并不会存储在内存中。</p>
<p>有关更多信息以及查看计算属性的示例，请参见 <a href="doc:Properties#计算属性">doc:Properties#计算属性</a>。</p>
<h3 id="存储变量观察者和属性观察者"><a href="#存储变量观察者和属性观察者" class="headerlink" title="存储变量观察者和属性观察者"></a>存储变量观察者和属性观察者</h3><p>你还可以使用 <code>willSet</code> 和 <code>didSet</code> 观察者声明一个存储变量或属性。带有观察者的存储变量或属性具有以下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="operator">&lt;</span>#variable name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#type#<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>#expression#<span class="operator">&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">willSet</span>(<span class="operator">&lt;</span>#setter name#<span class="operator">&gt;</span>) &#123;</span><br><span class="line">        <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">didSet</span>(<span class="operator">&lt;</span>#setter name#<span class="operator">&gt;</span>) &#123;</span><br><span class="line">        <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在全局作用域、函数的全局作用域或类或结构体声明的上下文中定义这种变量声明形式。当这种形式的变量声明在全局作用域或函数的全局作用域内声明时，观察者被称为<em>存储变量观察者</em>。当它在类或结构体声明的上下文中声明时，观察者被称为<em>属性观察者</em>。</p>
<p>你可以为任何存储属性添加属性观察者。你还可以通过在子类中重写属性，为任何继承自父类的属性（无论是存储的还是计算的）添加属性观察者，参见 <a href="doc:Inheritance#重写属性观察器">doc:Inheritance#重写属性观察器</a>。</p>
<p>构造器<em>表达式</em>在类或结构体声明的上下文中是可选的，但在其他地方是必须的。如果能通过构造器<em>表达式</em>推断出类型，则<em>类型</em>标注是可选的。通常，表达式的类型推断发生在首次读取属性时。如果在读取属性之前，初值已经被重写，则推断发生在首次写入属性时。</p>
<!--
  - test: `overwriting-property-without-writing`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; func loudConst(_ x: Int) -&gt; Int &#123;</span><br><span class="line">&gt;&gt;     print(&quot;initial value:&quot;, x)</span><br><span class="line">&gt;&gt;     return x</span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line">&gt;&gt; var x = loudConst(10)</span><br><span class="line">&gt;&gt; x = 20</span><br><span class="line">&gt;&gt; print(&quot;x:&quot;, x)</span><br><span class="line">&lt;&lt; initial value: 10</span><br><span class="line">&lt;&lt; x: 20</span><br><span class="line">&gt;&gt; var y = loudConst(100)</span><br><span class="line">&gt;&gt; print(&quot;y:&quot;, y)</span><br><span class="line">&lt;&lt; initial value: 100</span><br><span class="line">&lt;&lt; y: 100</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>willSet</code> 和 <code>didSet</code> 观察者提供了一种在变量或属性被赋值时的观察（和响应）方式。当变量或属性首次初始化时，观察者不会被调用。相反，它们仅在初始化上下文之外的情况下，值被设置时被调用。</p>
<p><code>willSet</code> 观察者在变量或属性的值被设置之前被调用。新值作为常量传递给 <code>willSet</code> 观察者，因此新值在 <code>willSet</code> 子句的实现中无法更改。<code>didSet</code> 观察者在新值被设置后立即被调用。与 <code>willSet</code> 观察者不同，变量或属性的旧值会传递给 <code>didSet</code> 观察者，以防你仍然需要访问它。也就是说，如果你在其自己的 <code>didSet</code> 观察者子句中给变量或属性赋值，那么你赋的这个新值将替代刚刚设置并传递给 <code>willSet</code> 观察者的值。</p>
<p><em>setter 名称</em>和 <code>willSet</code> 与 <code>didSet</code> 子句中的括号是可选的。如果提供了 setter 名称，它们将作为 <code>willSet</code> 和 <code>didSet</code> 观察者的参数名称。如果不提供 setter 名称，<code>willSet</code> 观察者的默认参数名称是 <code>newValue</code>，而 <code>didSet</code> 观察者的默认参数名称是 <code>oldValue</code>。</p>
<p><code>didSet</code> 子句在提供 <code>willSet</code> 子句时是可选的。同样，在提供 <code>didSet</code> 子句时，<code>willSet</code> 子句也是可选的。</p>
<p>如果在 <code>didSet</code> 主体中引用了旧值，为了使旧值可用，在调用 <code>didSet</code> 之前，会先调用 getter。否则，新的值会被存储，而不调用超类的 getter。下面的示例显示了一个由超类定义并被其子类重写以添加观察者的计算属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> xValue <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Getter was called&quot;</span>); <span class="keyword">return</span> xValue &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Setter was called&quot;</span>); xValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个子类在它的观察器中没有引用 oldValue，</span></span><br><span class="line"><span class="comment">// 因此，父类的 getter 方法中的打印语句只会执行一次</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">New</span>: <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> x: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;New value <span class="subst">\(x)</span>&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> new <span class="operator">=</span> <span class="type">New</span>()</span><br><span class="line">new.x <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="comment">// 打印 &quot;Setter was called&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;Getter was called&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;New value 100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个子类在它的观察器中引用了 oldValue，</span></span><br><span class="line"><span class="comment">// 因此父类的 getter 在 setter 之前会被调用一次，</span></span><br><span class="line"><span class="comment">// 然后再次调用以打印该值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewAndOld</span>: <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> x: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Old value <span class="subst">\(oldValue)</span> - new value <span class="subst">\(x)</span>&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newAndOld <span class="operator">=</span> <span class="type">NewAndOld</span>()</span><br><span class="line">newAndOld.x <span class="operator">=</span> <span class="number">200</span></span><br><span class="line"><span class="comment">// 打印 &quot;Getter was called&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;Setter was called&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;Getter was called&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;Old value 12 - new value 200&quot;</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `didSet-calls-superclass-getter`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-&gt; class Superclass &#123;</span><br><span class="line">       private var xValue = 12</span><br><span class="line">       var x: Int &#123;</span><br><span class="line">           get &#123; print(&quot;Getter was called&quot;); return xValue &#125;</span><br><span class="line">           set &#123; print(&quot;Setter was called&quot;); xValue = newValue &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">// This subclass doesn&#x27;t refer to oldValue in its observer, so the</span><br><span class="line">// superclass&#x27;s getter is called only once to print the value.</span><br><span class="line">-&gt; class New: Superclass &#123;</span><br><span class="line">       override var x: Int &#123;</span><br><span class="line">           didSet &#123; print(&quot;New value \(x)&quot;) &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   let new = New()</span><br><span class="line">   new.x = 100</span><br><span class="line">&lt;- Setter was called</span><br><span class="line">&lt;- Getter was called</span><br><span class="line">&lt;- New value 100</span><br><span class="line">---</span><br><span class="line">// This subclass refers to oldValue in its observer, so the superclass&#x27;s</span><br><span class="line">// getter is called once before the setter, and again to print the value.</span><br><span class="line">-&gt; class NewAndOld: Superclass &#123;</span><br><span class="line">       override var x: Int &#123;</span><br><span class="line">           didSet &#123; print(&quot;Old value \(oldValue) - new value \(x)&quot;) &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   let newAndOld = NewAndOld()</span><br><span class="line">   newAndOld.x = 200</span><br><span class="line">&lt;- Getter was called</span><br><span class="line">&lt;- Setter was called</span><br><span class="line">&lt;- Getter was called</span><br><span class="line">&lt;- Old value 12 - new value 200</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>有关更多信息以及如何使用属性观察者的示例，请参见 <a href="doc:Properties#属性观察器">doc:Properties#属性观察器</a>。</p>
<!--
  - test: `cant-mix-get-set-and-didSet`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; struct S &#123;</span><br><span class="line">&gt;&gt;     var x: Int &#123;</span><br><span class="line">&gt;&gt;         get &#123; print(&quot;S getter&quot;); return 12 &#125;</span><br><span class="line">&gt;&gt;         set &#123; return &#125;</span><br><span class="line">&gt;&gt;         didSet &#123; print(&quot;S didSet&quot;) &#125;</span><br><span class="line">&gt;&gt;     &#125;</span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line">!$ error: &#x27;didSet&#x27; cannot be provided together with a getter</span><br><span class="line">!! didSet &#123; print(&quot;S didSet&quot;) &#125;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="类型变量属性"><a href="#类型变量属性" class="headerlink" title="类型变量属性"></a>类型变量属性</h3><p>要声明一个类型变量属性，请使用 <code>static</code> 声明修饰符标记声明。类可以使用 <code>class</code> 声明修饰符标记类型计算属性，以允许子类重写超类的实现。类型属性的讨论请参见 <a href="doc:Properties#类型属性">doc:Properties#类型属性</a>。</p>
<blockquote>
<p>变量声明的语法:</p>
<p><em>variable-declaration</em> → <em>variable-declaration-head</em> <em>pattern-initializer-list</em> <br><em>variable-declaration</em> → <em>variable-declaration-head</em> <em>variable-name</em> <em>type-annotation</em> <em>code-block</em> <br><em>variable-declaration</em> → <em>variable-declaration-head</em> <em>variable-name</em> <em>type-annotation</em> <em>getter-setter-block</em> <br><em>variable-declaration</em> → <em>variable-declaration-head</em> <em>variable-name</em> <em>type-annotation</em> <em>getter-setter-keyword-block</em> <br><em>variable-declaration</em> → <em>variable-declaration-head</em> <em>variable-name</em> <em>initializer</em> <em>willSet-didSet-block</em> <br><em>variable-declaration</em> → <em>variable-declaration-head</em> <em>variable-name</em> <em>type-annotation</em> <em>initializer</em><em>?</em> <em>willSet-didSet-block</em></p>
<p><em>variable-declaration-head</em> → <em>attributes</em><em>?</em> <em>declaration-modifiers</em><em>?</em> <strong><code>var</code></strong> <br><em>variable-name</em> → <em>identifier</em></p>
<p><em>getter-setter-block</em> → <em>code-block</em> <br><em>getter-setter-block</em> → <strong><code>&#123;</code></strong> <em>getter-clause</em> <em>setter-clause</em><em>?</em> <strong><code>&#125;</code></strong> <br><em>getter-setter-block</em> → <strong><code>&#123;</code></strong> <em>setter-clause</em> <em>getter-clause</em> <strong><code>&#125;</code></strong> <br><em>getter-clause</em> → <em>attributes</em><em>?</em> <em>mutation-modifier</em><em>?</em> <strong><code>get</code></strong> <em>code-block</em> <br><em>setter-clause</em> → <em>attributes</em><em>?</em> <em>mutation-modifier</em><em>?</em> <strong><code>set</code></strong> <em>setter-name</em><em>?</em> <em>code-block</em> <br><em>setter-name</em> → <strong><code>(</code></strong> <em>identifier</em> <strong><code>)</code></strong></p>
<p><em>getter-setter-keyword-block</em> → <strong><code>&#123;</code></strong> <em>getter-keyword-clause</em> <em>setter-keyword-clause</em><em>?</em> <strong><code>&#125;</code></strong> <br><em>getter-setter-keyword-block</em> → <strong><code>&#123;</code></strong> <em>setter-keyword-clause</em> <em>getter-keyword-clause</em> <strong><code>&#125;</code></strong> <br><em>getter-keyword-clause</em> → <em>attributes</em><em>?</em> <em>mutation-modifier</em><em>?</em> <strong><code>get</code></strong> <br><em>setter-keyword-clause</em> → <em>attributes</em><em>?</em> <em>mutation-modifier</em><em>?</em> <strong><code>set</code></strong></p>
<p><em>willSet-didSet-block</em> → <strong><code>&#123;</code></strong> <em>willSet-clause</em> <em>didSet-clause</em><em>?</em> <strong><code>&#125;</code></strong> <br><em>willSet-didSet-block</em> → <strong><code>&#123;</code></strong> <em>didSet-clause</em> <em>willSet-clause</em><em>?</em> <strong><code>&#125;</code></strong> <br><em>willSet-clause</em> → <em>attributes</em><em>?</em> <strong><code>willSet</code></strong> <em>setter-name</em><em>?</em> <em>code-block</em> <br><em>didSet-clause</em> → <em>attributes</em><em>?</em> <strong><code>didSet</code></strong> <em>setter-name</em><em>?</em> <em>code-block</em></p>
</blockquote>
<!--
  NOTE: Type annotations are required for computed properties -- the
  types of those properties aren't computed/inferred.
-->

<h2 id="类型别名声明"><a href="#类型别名声明" class="headerlink" title="类型别名声明"></a>类型别名声明</h2><p><em>类型别名声明</em>将现有类型的具名别名引入到你的程序中。类型别名声明使用 <code>typealias</code> 关键字声明，具有以下形式：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="operator">&lt;</span>#name#<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>#existing type#<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在声明类型别名后，别名<em>名称</em>可以在程序中的任何地方替代<em>现有类型</em>使用。<em>现有类型</em>可以是具名类型或复合类型。类型别名不会创建新类型；它们只是允许一个名称引用现有类型。</p>
<p>类型别名声明可以使用泛型参数为现有的泛型类型命名。类型别名可以为现有类型的某些或所有泛型参数提供具体类型。例如：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">StringDictionary</span>&lt;<span class="type">Value</span>&gt; <span class="operator">=</span> <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Value</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来的两个字典是同一类型</span></span><br><span class="line"><span class="keyword">var</span> dictionary1: <span class="type">StringDictionary</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> [:]</span><br><span class="line"><span class="keyword">var</span> dictionary2: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt; <span class="operator">=</span> [:]</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `typealias-with-generic`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;</span><br><span class="line">---</span><br><span class="line">// The following dictionaries have the same type.</span><br><span class="line">-&gt; var dictionary1: StringDictionary&lt;Int&gt; = [:]</span><br><span class="line">-&gt; var dictionary2: Dictionary&lt;String, Int&gt; = [:]</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>当声明一个带有泛型参数的类型别名时，这些参数的约束必须与现有类型的泛型参数的约束完全匹配。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">DictionaryOfInts</span>&lt;<span class="type">Key</span>: <span class="type">Hashable</span>&gt; <span class="operator">=</span> <span class="type">Dictionary</span>&lt;<span class="type">Key</span>, <span class="type">Int</span>&gt;</span><br></pre></td></tr></table></figure>

<!--
  - test: `typealias-with-generic-constraint`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; typealias DictionaryOfInts&lt;Key: Hashable&gt; = Dictionary&lt;Key, Int&gt;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>因为类型别名和现有类型可以互换使用，类型别名不能引入额外的泛型约束。</p>
<p>类型别名可以通过省略声明中的所有泛型参数来转发现有类型的泛型参数。例如，这里声明的 <code>Diccionario</code> 类型别名具有与 <code>Dictionary</code> 相同的泛型参数和约束。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Diccionario</span> <span class="operator">=</span> <span class="type">Dictionary</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `typealias-using-shorthand`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; typealias Diccionario = Dictionary</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  Note that the compiler doesn't currently enforce this. For example, this works but shouldn't:
  typealias ProvidingMoreSpecificConstraints<T: Comparable & Hashable> = Dictionary<T, Int>
-->

<!--
  Things that shouldn't work:
  typealias NotRedeclaringSomeOfTheGenericParameters = Dictionary<T, String>
  typealias NotRedeclaringAnyOfTheGenericParameters = Dictionary
  typealias NotProvidingTheCorrectConstraints<T> = Dictionary<T, Int>
  typealias ProvidingMoreSpecificConstraints<T: Comparable & Hashable> = Dictionary<T, Int>
-->
<p>在协议声明中，类型别名可以为经常使用的类型提供一个更短和更方便的名称。例如：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Sequence</span> {</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> <span class="operator">=</span> <span class="type">Iterator</span>.<span class="type">Element</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sum</span>&lt;<span class="type">T</span>: <span class="type">Sequence</span>&gt;(<span class="keyword">_</span> <span class="params">sequence</span>: <span class="type">T</span>) -&gt; <span class="type">Int</span> <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Int</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `typealias-in-protocol`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol Sequence &#123;</span><br><span class="line">       associatedtype Iterator: IteratorProtocol</span><br><span class="line">       typealias Element = Iterator.Element</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; func sum&lt;T: Sequence&gt;(_ sequence: T) -&gt; Int where T.Element == Int &#123;</span><br><span class="line">       // ...</span><br><span class="line">&gt;&gt;     return 9000</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>没有这种类型别名，<code>sum</code> 函数必须将关联类型称为 <code>T.Iterator.Element</code>，而不是 <code>T.Element</code>。</p>
<p>另见 <a href="doc:Declarations#协议关联类型声明">doc:Declarations#协议关联类型声明</a>。</p>
<blockquote>
<p>类型别名声明的语法:</p>
<p><em>typealias-declaration</em> → <em>attributes</em><em>?</em> <em>access-level-modifier</em><em>?</em> <strong><code>typealias</code></strong> <em>typealias-name</em> <em>generic-parameter-clause</em><em>?</em> <em>typealias-assignment</em> <br><em>typealias-name</em> → <em>identifier</em> <br><em>typealias-assignment</em> → <strong><code>=</code></strong> <em>type</em></p>
</blockquote>
<!--
  Old grammar:
  typealias-declaration -> typealias-head typealias-assignment
  typealias-head -> ``typealias`` typealias-name type-inheritance-clause-OPT
  typealias-name -> identifier
  typealias-assignment -> ``=`` type
-->

<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p><em>函数声明</em>将一个函数或方法引入到你的程序中。在类、结构体、枚举或协议的上下文中声明的函数被称为<em>方法</em>。函数声明使用 <code>func</code> 关键字声明，具有以下形式：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;</span><span class="keyword">#function</span> name#<span class="operator">&gt;</span>(<span class="operator">&lt;</span>#parameters#<span class="operator">&gt;</span>) -&gt; <span class="operator">&lt;</span>#return type#<span class="operator">&gt;</span> {</span><br><span class="line">    <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果函数的返回类型是 <code>Void</code> ，则可以省略返回类型，如下所示：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;</span><span class="keyword">#function</span> name#<span class="operator">&gt;</span>(<span class="operator">&lt;</span>#parameters#<span class="operator">&gt;</span>) {</span><br><span class="line">    <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为参数类型无法被推断出来，所以函数的每个参数必须明确指定类型。如果在参数类型前写上 <code>inout</code>，则该参数可以在函数的作用域内被修改。关于 in-out 参数的详细讨论请参见下面的 <a href="doc:Declarations#In-Out-参数">doc:Declarations#In-Out-参数</a>。</p>
<p>如果一个函数声明中的<em>语句</em>只包含一个表达式，则默认返回该表达式的值。只有在表达式的类型和函数的返回类型不是 <code>Void</code>，并且不是像 <code>Never</code> 那样没有任何枚举值的枚举时，才会考虑这种隐式返回语法。</p>
<!--
  As of Swift 5.3,
  the only way to make an uninhabited type is to create an empty enum,
  so just say that directly instead of using & defining the compiler jargon.
-->

<p>函数可以使用元组类型作为返回类型来返回多个值。</p>
<!--
  TODO: ^-- Add some more here.
-->

<p>在函数内部，可以定义另一个函数。这种定义在函数内部的函数，被称为<em>嵌套函数</em>。</p>
<p>如果一个嵌套函数捕获了一个保证不会逃逸的值——例如一个 in-out 参数——或者作为一个非逃逸函数参数传递，那么这个嵌套函数就是非逃逸的。否则，嵌套函数就是逃逸的。</p>
<p>有关嵌套函数的讨论，请参见 <a href="doc:Functions#嵌套函数">doc:Functions#嵌套函数</a>。</p>
<h3 id="参数名称"><a href="#参数名称" class="headerlink" title="参数名称"></a>参数名称</h3><p>函数的参数是一个以逗号分隔的列表，每个参数都可以是不同的类型。函数调用时的参数顺序必须和函数声明时的参数顺序一致。最简单的参数列表有着如下的形式：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>#parameter name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#parameter type#<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>参数有名称和标签，名称用于在函数内访问参数，标签用于在调用函数时指定参数。默认情况下，参数的名称也可以作为标签。例如：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">f</span>(<span class="params">x</span>: <span class="type">Int</span>, <span class="params">y</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> { <span class="keyword">return</span> x <span class="operator">+</span> y }</span><br><span class="line">f(x: <span class="number">1</span>, y: <span class="number">2</span>) <span class="comment">// x 和 y 都带有标签</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `default-parameter-names`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func f(x: Int, y: Int) -&gt; Int &#123; return x + y &#125;</span><br><span class="line">&gt;&gt; let r0 =</span><br><span class="line">-&gt; f(x: 1, y: 2) // x 和 y 都带有标签</span><br><span class="line">&gt;&gt; assert(r0 == 3)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  Rewrite the above to avoid bare expressions.
  Tracking bug is <rdar://problem/35301593>
-->

<p>你可以使用以下形式（选其一），重写参数标签的默认行为：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>#argument label#<span class="operator">&gt;</span> <span class="operator">&lt;</span>#parameter name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#parameter type#<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">_</span> <span class="operator">&lt;</span>#parameter name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#parameter type#<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在参数名称前的名称会作为这个参数的显式实参标签，它可以和参数名称不同。在函数或方法调用时，相对应的参数必须使用这个实参标签。</p>
<p>参数名称前的下划线（<code>_</code>）可以去除参数的实参标签。在函数或方法调用时，相对应的参数必须去除标签。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">repeatGreeting</span>(<span class="keyword">_</span> <span class="params">greeting</span>: <span class="type">String</span>, <span class="params">count</span> <span class="params">n</span>: <span class="type">Int</span>) { <span class="comment">/* 打招呼 n 次 */</span> }</span><br><span class="line">repeatGreeting(<span class="string">"Hello, world!"</span>, count: <span class="number">2</span>) <span class="comment">//  count 带有标签，greeting 没有</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `overridden-parameter-names`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func repeatGreeting(_ greeting: String, count n: Int) &#123; /* Greet n times */ &#125;</span><br><span class="line">-&gt; repeatGreeting(&quot;Hello, world!&quot;, count: 2) //  count is labeled, greeting is not</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="参数修饰符"><a href="#参数修饰符" class="headerlink" title="参数修饰符"></a>参数修饰符</h3><p><em>参数修饰符</em>改变了参数传递给函数的方式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>#argument label#<span class="operator">&gt;</span> <span class="operator">&lt;</span>#parameter name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#parameter modifier#<span class="operator">&gt;</span> <span class="operator">&lt;</span>#parameter type#<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>要使用参数修饰符，请在参数类型之前写 <code>inout</code>、<code>borrowing</code> 或 <code>consuming</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">a</span>: <span class="keyword">inout</span> <span class="type">A</span>, <span class="params">b</span>: consuming <span class="type">B</span>, <span class="params">c</span>: <span class="type">C</span>) &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="In-Out-参数"><a href="#In-Out-参数" class="headerlink" title="In-Out 参数"></a>In-Out 参数</h4><p>默认情况下，Swift 中的函数参数是按值传递的：在函数内进行的任何更改对调用者都是不可见的。如果需要传入一个 in-out 参数，可以使用 <code>inout</code> 参数修饰符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    a <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用包含 in-out 参数的函数时，必须在 in-out 参数前加上 &amp;（与符号），以表明函数调用可以更改该参数的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> <span class="number">7</span></span><br><span class="line">someFunction(<span class="operator">&amp;</span>x)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment">// 打印 &quot;8&quot;</span></span><br></pre></td></tr></table></figure>

<p>In-out 参数的传递方式如下：</p>
<ol>
<li>当函数被调用时，参数的值会被复制。</li>
<li>在函数体内，副本被修改。</li>
<li>当函数返回时，副本的值被赋给原始参数。</li>
</ol>
<p>这种行为被称为<em>拷入拷出（copy-in copy-out）</em> 或<em>值结果调用（call by value result）</em>。例如，当一个计算属性或一个带观察者的属性作为 in-out 参数传递时，它的 getter 在函数调用中被调用，而它的 setter 在函数返回时被调用。</p>
<p>作为一种优化手段，当参数值存储在内存中的物理地址时，在函数体内部和外部均会使用同一内存位置。这种优化行为被称为<em>引用调用（call by reference）</em>; 它满足了 copy-in copy-out 模型的所有要求，同时消除了复制的开销。请使用 copy-in copy-out 给出的模型编写代码，而不依赖于引用传递优化，以便在有或没有优化的情况下都能正确运行。</p>
<p>在函数内，不要访问作为 in-out 参数传递的值，即使原始值在当前作用域中可用。访问原始值是对该值的同时访问，这违反了内存独占性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someValue: <span class="type">Int</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    a <span class="operator">+=</span> someValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：这会导致运行时排他性违规</span></span><br><span class="line">someFunction(<span class="operator">&amp;</span>someValue)</span><br></pre></td></tr></table></figure>

<p>出于同样的原因，你不能将相同的值传递给多个 in-out 参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someValue: <span class="type">Int</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    a <span class="operator">+=</span> b</span><br><span class="line">    b <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：不能将同一个值传递给多个 in-out 参数</span></span><br><span class="line">someFunction(<span class="operator">&amp;</span>someValue, <span class="operator">&amp;</span>someValue)</span><br></pre></td></tr></table></figure>

<p>有关内存安全和内存独占的更多信息，请参见 <a href="doc:MemorySafety">doc:MemorySafety</a>。</p>
<!--
  When the call-by-reference optimization is in play,
  it would happen to do what you want.
  But you still shouldn't do that --
  as noted above, you're not allowed to depend on
  behavioral differences that happen because of call by reference.
-->

<p>捕获 in-out 参数的闭包或嵌套函数必须是非逃逸的。如果你需要捕获一个 in-out 参数而不对其进行修改，请使用捕获列表显式地以不可变方式捕获该参数。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>) -&gt; () -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> { [a] <span class="keyword">in</span> <span class="keyword">return</span> a <span class="operator">+</span> <span class="number">1</span> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `explicit-capture-for-inout`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func someFunction(a: inout Int) -&gt; () -&gt; Int &#123;</span><br><span class="line">       return &#123; [a] in return a + 1 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&gt; class C &#123; var x = 100 &#125;</span><br><span class="line">&gt;&gt; let c = C()</span><br><span class="line">&gt;&gt; let f = someFunction(a: &amp;c.x)</span><br><span class="line">&gt;&gt; c.x = 200</span><br><span class="line">&gt;&gt; let r = f()</span><br><span class="line">&gt;&gt; print(r, r == c.x)</span><br><span class="line">&lt;&lt; 101 false</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>如果你需要捕获并修改一个 in-out 参数，请使用一个显式的局部副本，例如在多线程代码中，确保所有修改在函数返回之前都已完成。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">multithreadedFunction</span>(<span class="params">queue</span>: <span class="type">DispatchQueue</span>, <span class="params">x</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个本地副本，并在函数结束时手动将其复制回去。</span></span><br><span class="line">    <span class="keyword">var</span> localX <span class="operator">=</span> x</span><br><span class="line">    <span class="keyword">defer</span> &#123; x <span class="operator">=</span> localX &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步操作 localX，然后在返回之前等待。</span></span><br><span class="line">    queue.async &#123; someMutatingOperation(<span class="operator">&amp;</span>localX) &#125;</span><br><span class="line">    queue.sync &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `cant-pass-inout-aliasing`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; import Dispatch</span><br><span class="line">&gt;&gt; func someMutatingOperation(_ a: inout Int) &#123;&#125;</span><br><span class="line">-&gt; func multithreadedFunction(queue: DispatchQueue, x: inout Int) &#123;</span><br><span class="line">      // Make a local copy and manually copy it back.</span><br><span class="line">      var localX = x</span><br><span class="line">      defer &#123; x = localX &#125;</span><br><span class="line"></span><br><span class="line">      // Operate on localX asynchronously, then wait before returning.</span><br><span class="line">      queue.async &#123; someMutatingOperation(&amp;localX) &#125;</span><br><span class="line">      queue.sync &#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>有关 in-out 参数的更多讨论和示例，请参见 <a href="doc:Functions#In-Out-参数">doc:Functions#In-Out-参数</a>.。</p>
<!--
  - test: `escaping-cant-capture-inout`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func outer(a: inout Int) -&gt; () -&gt; Void &#123;</span><br><span class="line">       func inner() &#123;</span><br><span class="line">           a += 1</span><br><span class="line">       &#125;</span><br><span class="line">       return inner</span><br><span class="line">   &#125;</span><br><span class="line">!$ error: escaping local function captures &#x27;inout&#x27; parameter &#x27;a&#x27;</span><br><span class="line">!! return inner</span><br><span class="line">!! ^</span><br><span class="line">!$ note: parameter &#x27;a&#x27; is declared &#x27;inout&#x27;</span><br><span class="line">!! func outer(a: inout Int) -&gt; () -&gt; Void &#123;</span><br><span class="line">!! ^</span><br><span class="line">!$ note: captured here</span><br><span class="line">!! a += 1</span><br><span class="line">!! ^</span><br><span class="line">-&gt; func closure(a: inout Int) -&gt; () -&gt; Void &#123;</span><br><span class="line">       return &#123; a += 1 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">!$ error: escaping closure captures &#x27;inout&#x27; parameter &#x27;a&#x27;</span><br><span class="line">!! return &#123; a += 1 &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ note: parameter &#x27;a&#x27; is declared &#x27;inout&#x27;</span><br><span class="line">!! func closure(a: inout Int) -&gt; () -&gt; Void &#123;</span><br><span class="line">!! ^</span><br><span class="line">!$ note: captured here</span><br><span class="line">!! return &#123; a += 1 &#125;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h4 id="借用和消费参数"><a href="#借用和消费参数" class="headerlink" title="借用和消费参数"></a>借用和消费参数</h4><p>默认情况下，Swift 使用一套规则在函数调用之间自动管理对象生命周期，在需要时复制值。默认规则旨在在大多数情况下最小化开销——如果你想要更具体的控制，可以应用 <code>borrowing</code> 或 <code>consuming</code> 参数修饰符。在这种情况下，使用 <code>copy</code> 显式标记复制操作。</p>
<p>无论你是否使用默认规则，Swift 确保在所有情况下对象的生命周期和所有权都得到正确管理。这些参数修饰符仅影响特定使用模式的相对效率，而不影响正确性。</p>
<!--
TODO: Describe the default rules.
Essentially, inits and property setters are consuming,
and everything else is borrowing.
Where are copies implicitly inserted?
-->

<p><code>borrowing</code> 修饰函数参数时，函数不会保留参数的值。在这种情况下，调用者保留对象的所有权，并负责对象的生命周期管理。所以当函数只是临时使用对象时，用 <code>borrowing</code> 修饰可以最大限度地减少开销。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `isLessThan` 不会保留任一参数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">isLessThan</span>(<span class="params">lhs</span>: borrowing <span class="type">A</span>, <span class="params">rhs</span>: borrowing <span class="type">A</span>) -&gt; <span class="type">Bool</span> {</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果函数需要保留参数的值，例如，通过将其存储在全局变量中——你可以使用 <code>copy</code> 显式地复制该值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样是 `isLessThan` 函数，这个 `isLessThan` 可以将最小值记录下来</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">isLessThan</span>(<span class="params">lhs</span>: borrowing <span class="type">A</span>, <span class="params">rhs</span>: borrowing <span class="type">A</span>) -&gt; <span class="type">Bool</span> {</span><br><span class="line">    <span class="keyword">if</span> lhs <span class="operator">&lt;</span> storedValue {</span><br><span class="line">        storedValue <span class="operator">=</span> copy lhs</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> rhs <span class="operator">&lt;</span> storedValue {</span><br><span class="line">        storedValue <span class="operator">=</span> copy rhs</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lhs <span class="operator">&lt;</span> rhs</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>相反，<code>consuming</code> 参数修饰符表示该函数拥有该值的所有权，负责在函数返回之前存储或销毁它。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `store` 会保留它的参数，因此将其标记为 `consuming`</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">store</span>(<span class="params">a</span>: consuming <span class="type">A</span>) {</span><br><span class="line">    someGlobalVariable <span class="operator">=</span> a</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用 <code>consuming</code> 可以在调用者在函数调用后不再需要使用该对象时，最小化开销。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常，这就是最后一次使用 value 了</span></span><br><span class="line">store(a: value)</span><br></pre></td></tr></tbody></table></figure>

<p>如果在函数调用后继续使用可复制对象，编译器会在函数调用之前自动复制该对象。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器会在这里插入一个隐式副本</span></span><br><span class="line">store(a: someValue)  <span class="comment">// 此函数消费 someValue</span></span><br><span class="line"><span class="built_in">print</span>(someValue)  <span class="comment">// 这里使用的是 someValue 的副本</span></span><br></pre></td></tr></tbody></table></figure>

<p>与 <code>inout</code> 不同，<code>borrowing</code> 和 <code>consuming</code> 参数在调用函数时不需要任何特殊标记：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">a</span>: borrowing <span class="type">A</span>, <span class="params">b</span>: consuming <span class="type">B</span>) { <span class="operator">...</span> }</span><br><span class="line"></span><br><span class="line">someFunction(a: someA, b: someB)</span><br></pre></td></tr></tbody></table></figure>

<p>显式使用 <code>borrowing</code> 或 <code>consuming</code> 表示你希望更严格地控制运行时所有权管理的开销。因为复制可能导致意外的运行时所有权操作，所以标记为这两种修饰符的参数在没有使用显式的 <code>copy</code> 关键字的情况下不能被复制：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">borrowingFunction1</span>(<span class="params">a</span>: borrowing <span class="type">A</span>) {</span><br><span class="line">    <span class="comment">// 错误：无法隐式复制 a</span></span><br><span class="line">    <span class="comment">// 这个赋值操作需要复制，因为 `a` 只是从调用者那里借来的。</span></span><br><span class="line">    someGlobalVariable <span class="operator">=</span> a</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">borrowingFunction2</span>(<span class="params">a</span>: borrowing <span class="type">A</span>) {</span><br><span class="line">    <span class="comment">// 可以：显式复制是可以的</span></span><br><span class="line">    someGlobalVariable <span class="operator">=</span> copy a</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">consumingFunction1</span>(<span class="params">a</span>: consuming <span class="type">A</span>) {</span><br><span class="line">    <span class="comment">// 错误：无法隐式复制 a</span></span><br><span class="line">    <span class="comment">// 这个赋值操作需要复制，因为后面有 `print`</span></span><br><span class="line">    someGlobalVariable <span class="operator">=</span> a</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">consumingFunction2</span>(<span class="params">a</span>: consuming <span class="type">A</span>) {</span><br><span class="line">    <span class="comment">// 可以：显式复制在这种情况下有效</span></span><br><span class="line">    someGlobalVariable <span class="operator">=</span> copy a</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">consumingFunction3</span>(<span class="params">a</span>: consuming <span class="type">A</span>) {</span><br><span class="line">    <span class="comment">// 可以：不需要复制，因为这是最后一次使用</span></span><br><span class="line">    someGlobalVariable <span class="operator">=</span> a</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<!--
  TODO: `borrowing` and `consuming` keywords with noncopyable argument types
-->
<!--
  TODO: Any change of parameter modifier is ABI-breaking
-->

<h3 id="特殊类型的参数"><a href="#特殊类型的参数" class="headerlink" title="特殊类型的参数"></a>特殊类型的参数</h3><p>参数可以被忽略，数量可以不固定，还可以为其提供默认值，使用形式如下</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_</span> : <span class="operator">&lt;</span>#parameter type#<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>#parameter name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#parameter type#<span class="operator">&gt;</span><span class="operator">...</span></span><br><span class="line"><span class="operator">&lt;</span>#parameter name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#parameter type#<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>#default argument value#<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>下划线 (<code>_</code>) 参数被显式忽略，无法在函数体内访问。</p>
<p>带有基本类型名称后面紧跟三个点（<code>...</code>）的参数被理解为可变参数。紧跟在可变参数后面的参数必须有一个实参标签。一个函数可以有多个可变参数。可变参数被视为包含基本类型名称元素的数组。例如，可变参数 <code>Int...</code> 被视为 <code>[Int]</code>。有关使用可变参数的示例，请参见 <a href="doc:Functions#可变参数">doc:Functions#可变参数</a>。</p>
<p>带有等号（<code>=</code>）且在类型后跟随一个表达式的参数，表示该参数有一个默认值。这个给定的表达式会在函数调用时进行求值。如果在调用函数时省略了该参数，则会使用默认值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">f</span>(<span class="params">x</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">42</span>) -&gt; <span class="type">Int</span> { <span class="keyword">return</span> x }</span><br><span class="line">f()       <span class="comment">// 有效，使用默认值</span></span><br><span class="line">f(x: <span class="number">7</span>)   <span class="comment">// 有效，使用提供的值</span></span><br><span class="line">f(<span class="number">7</span>)      <span class="comment">// 无效，缺少实参标签</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `default-args-and-labels`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func f(x: Int = 42) -&gt; Int &#123; return x &#125;</span><br><span class="line">&gt;&gt; let _ =</span><br><span class="line">-&gt; f()       // Valid, uses default value</span><br><span class="line">&gt;&gt; let _ =</span><br><span class="line">-&gt; f(x: 7)   // Valid, uses the value provided</span><br><span class="line">&gt;&gt; let _ =</span><br><span class="line">-&gt; f(7)      // Invalid, missing argument label</span><br><span class="line">!$ error: missing argument label &#x27;x:&#x27; in call</span><br><span class="line">!! f(7)      // Invalid, missing argument label</span><br><span class="line">!!   ^</span><br><span class="line">!!   x:</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  Rewrite the above to avoid discarding the function's return value.
  Tracking bug is <rdar://problem/35301593>
-->

<!--
  - test: `default-args-evaluated-at-call-site`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func shout() -&gt; Int &#123;</span><br><span class="line">      print(&quot;evaluated&quot;)</span><br><span class="line">      return 10</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; func foo(x: Int = shout()) &#123; print(&quot;x is \(x)&quot;) &#125;</span><br><span class="line">-&gt; foo(x: 100)</span><br><span class="line">&lt;&lt; x is 100</span><br><span class="line">-&gt; foo()</span><br><span class="line">&lt;&lt; evaluated</span><br><span class="line">&lt;&lt; x is 10</span><br><span class="line">-&gt; foo()</span><br><span class="line">&lt;&lt; evaluated</span><br><span class="line">&lt;&lt; x is 10</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="特殊类型的方法"><a href="#特殊类型的方法" class="headerlink" title="特殊类型的方法"></a>特殊类型的方法</h3><p>枚举或结构体的方法，如果修改了 <code>self</code>，必须标记为 <code>mutating</code> 声明修饰符。</p>
<p>重写超类方法的方法必须标记为 <code>override</code> 声明修饰符。没有 <code>override</code> 修饰符而重写方法，或者在不重写超类方法的情况下使用 <code>override</code> 修饰符，都是编译时错误。</p>
<p>与类型相关的方法，而不是与类型实例相关的方法，必须使用 <code>static</code> 声明修饰符来标记（枚举和结构体使用 <code>static</code>，类可以使用 <code>static</code> 或 <code>class</code> 声明修饰符）。用 <code>class</code> 声明修饰符标记的类类型方法可以被子类的实现重写；用 <code>class final</code> 或 <code>static</code> 标记的类类型方法则不能被重写。</p>
<!--
  - test: `overriding-class-methods-err`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-&gt; class S &#123; class final func f() -&gt; Int &#123; return 12 &#125; &#125;</span><br><span class="line">-&gt; class SS: S &#123; override class func f() -&gt; Int &#123; return 120 &#125; &#125;</span><br><span class="line">!$ error: class method overrides a &#x27;final&#x27; class method</span><br><span class="line">!! class SS: S &#123; override class func f() -&gt; Int &#123; return 120 &#125; &#125;</span><br><span class="line">!!                                  ^</span><br><span class="line">!$ note: overridden declaration is here</span><br><span class="line">!! class S &#123; class final func f() -&gt; Int &#123; return 12 &#125; &#125;</span><br><span class="line">!!                           ^</span><br><span class="line">-&gt; class S2 &#123; static func f() -&gt; Int &#123; return 12 &#125; &#125;</span><br><span class="line">-&gt; class SS2: S2 &#123; override static func f() -&gt; Int &#123; return 120 &#125; &#125;</span><br><span class="line">!$ error: cannot override static method</span><br><span class="line">!! class SS2: S2 &#123; override static func f() -&gt; Int &#123; return 120 &#125; &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ note: overridden declaration is here</span><br><span class="line">!! class S2 &#123; static func f() -&gt; Int &#123; return 12 &#125; &#125;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `overriding-class-methods`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; class S3 &#123; class func f() -&gt; Int &#123; return 12 &#125; &#125;</span><br><span class="line">-&gt; class SS3: S3 &#123; override class func f() -&gt; Int &#123; return 120 &#125; &#125;</span><br><span class="line">-&gt; print(SS3.f())</span><br><span class="line">&lt;- 120</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="特殊名称的方法"><a href="#特殊名称的方法" class="headerlink" title="特殊名称的方法"></a>特殊名称的方法</h3><p>一些具有特殊名称的方法为函数调用语法提供了语法糖。如果一个类型定义了这些方法之一，该类型的实例就可以使用函数调用语法。此时的函数调用会被理解为对该实例上某个特殊命名方法的调用</p>
<p>类、结构体或枚举类型可以通过定义一个 <code>dynamicallyCall(withArguments:)</code> 方法或一个 <code>dynamicallyCall(withKeywordArguments:)</code> 方法来支持函数调用语法，参见 <a href="doc:Attributes#dynamicCallable">doc:Attributes#dynamicCallable</a>，或者通过定义一个作为函数调用（call-as-function）的方法，如下所述。如果该类型同时定义了一个作为函数调用的方法和 <code>dynamicCallable</code> 特性使用的其中一个方法，则在可以使用任一方法的情况下，编译器优先选择作为函数调用的方法。</p>
<p>作为函数调用方法的名称为 <code>callAsFunction()</code>，或其他以 <code>callAsFunction(</code> 开头并带有有标签或无标签参数的名称——例如，<code>callAsFunction(_:_:)</code> 和 <code>callAsFunction(something:)</code> 也是有效的作为函数调用方法名称。</p>
<!--
  Above, callAsFunction( is in code voice even though
  it's not actually a symbol that exists in the reader's code.
  Per discussion with Chuck, this is the closest typographic convention
  to what we're trying to express here.
-->

<p>以下函数调用是等效的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CallableStruct</span> {</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">callAsFunction</span>(<span class="keyword">_</span> <span class="params">number</span>: <span class="type">Int</span>, <span class="params">scale</span>: <span class="type">Int</span>) {</span><br><span class="line">        <span class="built_in">print</span>(scale <span class="operator">*</span> (number <span class="operator">+</span> value))</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> callable <span class="operator">=</span> <span class="type">CallableStruct</span>(value: <span class="number">100</span>)</span><br><span class="line">callable(<span class="number">4</span>, scale: <span class="number">2</span>)</span><br><span class="line">callable.callAsFunction(<span class="number">4</span>, scale: <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 两个函数调用都打印 208。</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `call-as-function`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-&gt; struct CallableStruct &#123;</span><br><span class="line">       var value: Int</span><br><span class="line">       func callAsFunction(_ number: Int, scale: Int) &#123;</span><br><span class="line">           print(scale * (number + value))</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; let callable = CallableStruct(value: 100)</span><br><span class="line">-&gt; callable(4, scale: 2)</span><br><span class="line">-&gt; callable.callAsFunction(4, scale: 2)</span><br><span class="line">// Both function calls print 208.</span><br><span class="line">&lt;&lt; 208</span><br><span class="line">&lt;&lt; 208</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>作为函数调用的方法和来自 <code>dynamicCallable</code> 特性的方法在将多少信息编码到类型系统与在运行时可能的动态行为之间做出了不同的权衡。当你声明一个作为函数调用的方法时，你需要指定参数的数量，以及每个参数的类型和标签。<code>dynamicCallable</code> 特性的方法仅指定用于保存参数数组的类型。</p>
<p>定义一个作为函数调用的方法，或者来自 <code>dynamicCallable</code> 特性的方法，并不允许你在函数调用表达式以外的任何上下文中将该类型的实例用作函数。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someFunction1: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Void</span> <span class="operator">=</span> callable(<span class="keyword">_</span>:scale:)  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> someFunction2: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Void</span> <span class="operator">=</span> callable.callAsFunction(<span class="keyword">_</span>:scale:)</span><br></pre></td></tr></table></figure>

<!--
  - test: `call-as-function-err`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; struct CallableStruct &#123;</span><br><span class="line">&gt;&gt;     var value: Int</span><br><span class="line">&gt;&gt;     func callAsFunction(_ number: Int, scale: Int) &#123; &#125;</span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line">&gt;&gt; let callable = CallableStruct(value: 100)</span><br><span class="line">-&gt; let someFunction1: (Int, Int) -&gt; Void = callable(_:scale:)  // Error</span><br><span class="line">-&gt; let someFunction2: (Int, Int) -&gt; Void = callable.callAsFunction(_:scale:)</span><br><span class="line">&gt;&gt; _ = someFunction1 // suppress unused-constant warning</span><br><span class="line">&gt;&gt; _ = someFunction2 // suppress unused-constant warning</span><br><span class="line">!$ error: cannot find &#x27;callable(_:scale:)&#x27; in scope</span><br><span class="line">!! let someFunction1: (Int, Int) -&gt; Void = callable(_:scale:)  // Error</span><br><span class="line">!! ^~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>subscript(dynamicMember:)</code> 下标为成员查找提供了语法糖，参见 <a href="doc:Attributes#dynamicMemberLookup">doc:Attributes#dynamicMemberLookup</a>。</p>
<h3 id="抛出函数和方法"><a href="#抛出函数和方法" class="headerlink" title="抛出函数和方法"></a>抛出函数和方法</h3><p>可以抛出错误的函数和方法必须标记 <code>throws</code> 关键字。这些函数和方法被称为<em>抛出函数</em>和<em>抛出方法</em>。它们具有以下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;</span><span class="keyword">#function</span> name#<span class="operator">&gt;</span>(<span class="operator">&lt;</span>#parameters#<span class="operator">&gt;</span>) <span class="keyword">throws</span> -&gt; <span class="operator">&lt;</span>#return type#<span class="operator">&gt;</span> &#123;</span><br><span class="line">    <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出特定错误类型的函数具有以下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;</span><span class="keyword">#function</span> name#<span class="operator">&gt;</span>(<span class="operator">&lt;</span>#parameters#<span class="operator">&gt;</span>) <span class="keyword">throws</span>(<span class="operator">&lt;</span><span class="keyword">#error</span> type#<span class="operator">&gt;</span>) -&gt; <span class="operator">&lt;</span>#return type#<span class="operator">&gt;</span> &#123;</span><br><span class="line">    <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用抛出函数或方法的必须被包裹在一个 <code>try</code> 或 <code>try!</code> 表达式中（即，在 <code>try</code> 或 <code>try!</code> 操作符的作用域内）。</p>
<p>函数的类型包括：它是否会抛出错误，以及它抛出的错误类型。非抛出函数是抛出函数的子类型。所以，可以在使用抛出函数的地方使用非抛出函数。有关抛出错误函数类型的更多信息，请参阅 <a href="doc:Types#Function-Type">doc:Types#Function-Type</a>。有关处理具有显式类型的错误的示例，请参阅 <a href="doc:ErrorHandling#Specifying-the-Error-Type">doc:ErrorHandling#Specifying-the-Error-Type</a>。</p>
<p>你不能仅根据函数是否会抛出错误来重载一个函数。不过，你可以根据函数的<em>参数</em>是否会抛出错误来重载函数。</p>
<p>抛出方法不能重写非抛出方法，且抛出方法也不能满足协议中对非抛出方法的要求。不过，非抛出方法可以重写抛出方法，且非抛出方法也可以满足协议中对会抛出方法的要求。</p>
<h3 id="再抛出函数和方法"><a href="#再抛出函数和方法" class="headerlink" title="再抛出函数和方法"></a>再抛出函数和方法</h3><p>函数或方法可以使用 <code>rethrows</code> 关键字声明，表示它只在其某个函数参数抛出错误时才会抛出错误。这样的函数和方法被称为<em>再抛出函数（rethrowing functions）</em>和<em>再抛出方法（rethrowing methods）</em>。再抛出函数和方法必须至少有一个会抛出错误的函数参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">callback</span>: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) <span class="keyword">rethrows</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `rethrows`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func someFunction(callback: () throws -&gt; Void) rethrows &#123;</span><br><span class="line">       try callback()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>再抛出的函数或方法只能在 <code>catch</code> 子句中包含 <code>throw</code> 语句。这使得你可以在 <code>do</code>-<code>catch</code> 语句中调用抛出函数，并通过抛出不同的错误在 <code>catch</code> 子句中处理错误。此外，<code>catch</code> 子句必须仅处理由再抛出函数的抛出参数抛出的错误。例如，以下是无效的，因为 <code>catch</code> 子句将处理由 <code>alwaysThrows()</code> 抛出的错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">alwaysThrows</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">SomeError</span>.error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">callback</span>: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) <span class="keyword">rethrows</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> callback()</span><br><span class="line">        <span class="keyword">try</span> alwaysThrows()  <span class="comment">// 无效，alwaysThrows() 不是一个抛出参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">AnotherError</span>.error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `double-negative-rethrows`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; enum SomeError: Error &#123; case error &#125;</span><br><span class="line">&gt;&gt; enum AnotherError: Error &#123; case error &#125;</span><br><span class="line">-&gt; func alwaysThrows() throws &#123;</span><br><span class="line">       throw SomeError.error</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; func someFunction(callback: () throws -&gt; Void) rethrows &#123;</span><br><span class="line">      do &#123;</span><br><span class="line">         try callback()</span><br><span class="line">         try alwaysThrows()  // Invalid, alwaysThrows() isn&#x27;t a throwing parameter</span><br><span class="line">      &#125; catch &#123;</span><br><span class="line">         throw AnotherError.error</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">!$ error: a function declared &#x27;rethrows&#x27; may only throw if its parameter does</span><br><span class="line">!!               throw AnotherError.error</span><br><span class="line">!!               ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `throwing-in-rethrowing-function`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-&gt; enum SomeError: Error &#123; case c, d &#125;</span><br><span class="line">-&gt; func f1(callback: () throws -&gt; Void) rethrows &#123;</span><br><span class="line">       do &#123;</span><br><span class="line">           try callback()</span><br><span class="line">       &#125; catch &#123;</span><br><span class="line">           throw SomeError.c  // OK</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; func f2(callback: () throws -&gt; Void) rethrows &#123;</span><br><span class="line">       throw SomeError.d  // Error</span><br><span class="line">   &#125;</span><br><span class="line">!$ error: a function declared &#x27;rethrows&#x27; may only throw if its parameter does</span><br><span class="line">!! throw SomeError.d  // Error</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>抛出方法不能重写再抛出方法，抛出方法也不能满足再抛出方法的协议要求。也就是说，再抛出方法可以重写抛出方法，再抛出方法可以满足抛出方法的协议要求。</p>
<p>在泛型代码中，抛出特定错误类型是再抛出的替代方案。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>&lt;<span class="type">E</span>: <span class="type">Error</span>&gt;(<span class="params">callback</span>: () <span class="keyword">throws</span>(<span class="type">E</span>) -&gt; <span class="type">Void</span>) <span class="keyword">throws</span>(<span class="type">E</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种传播错误的方法保留了错误的类型信息。然而，与标记一个函数 <code>rethrows</code> 不同，这种方法并不阻止该函数抛出相同类型的错误。</p>
<!--
TODO: Revisit the comparison between rethrows and throws(E) above,
since it seems likely that the latter will generally replace the former.

See also rdar://128972373
-->

<h3 id="异步函数和方法"><a href="#异步函数和方法" class="headerlink" title="异步函数和方法"></a>异步函数和方法</h3><p>以异步方式运行的函数和方法必须使用 <code>async</code> 关键字标记。这类函数和方法被称为<em>异步函数</em>和<em>异步方法</em>。它们的形式如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;</span><span class="keyword">#function</span> name#<span class="operator">&gt;</span>(<span class="operator">&lt;</span>#parameters#<span class="operator">&gt;</span>) <span class="keyword">async</span> -&gt; <span class="operator">&lt;</span>#return type#<span class="operator">&gt;</span> {</span><br><span class="line">    <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对异步函数或方法的调用必须包装在一个 <code>await</code> 表达式中——也就是说，它们必须在 <code>await</code> 操作符的作用域内。</p>
<p><code>async</code> 关键字是函数类型的一部分，且同步函数是异步函数的子类型。因此，你可以在需要异步函数的上下文中使用同步函数。例如，你可以用同步方法重写异步方法，且同步方法可以满足对异步方法的协议要求。</p>
<p>你可以根据函数是否为异步来重载一个函数。在调用时，由上下文决定使用哪个重载：在异步上下文中，会使用异步函数，而在同步上下文中，会使用同步函数。</p>
<p>异步方法不能重写同步方法，且异步方法不能满足对同步方法的协议要求。不过，同步方法可以重写异步方法，且同步方法可以满足对异步方法的协议要求。</p>
<!--
  - test: `sync-satisfy-async-protocol-requirements`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; protocol P &#123; func f() async -&gt; Int &#125;</span><br><span class="line">&gt;&gt; class Super: P &#123;</span><br><span class="line">&gt;&gt;     func f() async -&gt; Int &#123; return 12 &#125;</span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line">&gt;&gt; class Sub: Super &#123;</span><br><span class="line">&gt;&gt;     func f() -&gt; Int &#123; return 120 &#125;</span><br><span class="line">&gt;&gt; &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="永不返回的函数"><a href="#永不返回的函数" class="headerlink" title="永不返回的函数"></a>永不返回的函数</h3><p>Swift 定义了一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/never"><code>Never</code></a> 类型，表示一个函数或方法不会返回给调用者。返回类型为 <code>Never</code> 的函数和方法被称为<em>非返回</em>。非返回的函数和方法要么导致不可恢复的错误，要么开始一个无限进行的工作序列。这意味着在调用后立即运行的代码永远不会被执行。即使抛出错误的函数和再抛出错误的函数是非返回类型，它们仍然可以将程序控制权转移到相应的 <code>catch</code> 块。</p>
<p>非返回的函数或方法可以在 guard 语句的 <code>else</code> 分支中调用，以结束该分支，见 <a href="doc:Statements#Guard-语句">doc:Statements#Guard-语句</a>。</p>
<p>你可以重写一个非返回的方法，但新方法必须保持其返回类型和非返回的行为。</p>
<blockquote>
<p>函数声明的语法:</p>
<p><em>function-declaration</em> → <em>function-head</em> <em>function-name</em> <em>generic-parameter-clause</em><em>?</em> <em>function-signature</em> <em>generic-where-clause</em><em>?</em> <em>function-body</em><em>?</em></p>
<p><em>function-head</em> → <em>attributes</em><em>?</em> <em>declaration-modifiers</em><em>?</em> <strong><code>func</code></strong> <br><em>function-name</em> → <em>identifier</em> | <em>operator</em></p>
<p><em>function-signature</em> → <em>parameter-clause</em> <strong><code>async</code></strong><em>?</em> <em>throws-clause</em><em>?</em> <em>function-result</em><em>?</em> <br><em>function-signature</em> → <em>parameter-clause</em> <strong><code>async</code></strong><em>?</em> <strong><code>rethrows</code></strong> <em>function-result</em><em>?</em> <br><em>function-result</em> → <strong><code>-&gt;</code></strong> <em>attributes</em><em>?</em> <em>type</em> <br><em>function-body</em> → <em>code-block</em></p>
<p><em>parameter-clause</em> → <strong><code>(</code></strong> <strong><code>)</code></strong> | <strong><code>(</code></strong> <em>parameter-list</em> <strong><code>)</code></strong> <br><em>parameter-list</em> → <em>parameter</em> | <em>parameter</em> <strong><code>,</code></strong> <em>parameter-list</em> <br><em>parameter</em> → <em>external-parameter-name</em><em>?</em> <em>local-parameter-name</em> <em>parameter-type-annotation</em> <em>default-argument-clause</em><em>?</em> <br><em>parameter</em> → <em>external-parameter-name</em><em>?</em> <em>local-parameter-name</em> <em>parameter-type-annotation</em> <br><em>parameter</em> → <em>external-parameter-name</em><em>?</em> <em>local-parameter-name</em> <em>parameter-type-annotation</em> <strong><code>...</code></strong></p>
<p><em>external-parameter-name</em> → <em>identifier</em> <br><em>local-parameter-name</em> → <em>identifier</em> <br><em>parameter-type-annotation</em> → <strong><code>:</code></strong> <em>attributes</em><em>?</em> <em>parameter-modifier</em><em>?</em> <em>type</em> <br><em>parameter-modifier</em> → <strong><code>inout</code></strong> | <strong><code>borrowing</code></strong> | <strong><code>consuming</code></strong><br><em>default-argument-clause</em> → <strong><code>=</code></strong> <em>expression</em></p>
</blockquote>
<!--
  NOTE: Code block is optional in the context of a protocol.
  Everywhere else, it's required.
  We could refactor to have a separation between function definition/declaration.
  There's also the low-level "asm name" FFI
  which is a definition and declaration corner case.
  Let's just deal with this difference in prose.
-->

<h2 id="枚举声明"><a href="#枚举声明" class="headerlink" title="枚举声明"></a>枚举声明</h2><p><em>枚举声明</em>将一个具名的枚举类型引入到你的程序中。</p>
<p>枚举声明有两种基本形式，使用 <code>enum</code> 关键字进行声明。使用任一形式声明的枚举的主体包含零个或多个值——称为<em>枚举用例</em>——以及任意数量的声明，包括计算属性、实例方法、类型方法、构造器、类型别名，甚至其他枚举、结构体、类和协议类型。枚举声明不能包含析构器或协议声明。</p>
<p>枚举类型可以采用任意数量的协议，但不能从类、结构体或其他枚举继承。</p>
<p>与类和结构体不同，枚举类型没有隐式提供的默认构造器；所有构造器必须显式声明。构造器可以委托给枚举中的其他构造器，但初始化过程只有在构造器将枚举的一个用例赋值给 <code>self</code> 后才完成。</p>
<p>像结构体但不同于类，枚举是值类型；当枚举的实例被赋值给变量或常量，或作为参数传递给函数调用时，会被复制。有关值类型的信息，请参见 <a href="doc:ClassesAndStructures#结构体和枚举是值类型">doc:ClassesAndStructures#结构体和枚举是值类型</a>。</p>
<p>你可以通过扩展声明扩展枚举类型的行为，如 <a href="doc:Declarations#扩展声明">doc:Declarations#扩展声明</a> 中所讨论的。</p>
<h3 id="任意类型的枚举成员"><a href="#任意类型的枚举成员" class="headerlink" title="任意类型的枚举成员"></a>任意类型的枚举成员</h3><p>如下的形式声明了一个包含任意类型枚举用例的枚举变量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &lt;#<span class="title class_">enumeration</span> <span class="title class_">name</span>#&gt;: &lt;#<span class="title class_">adopted</span> <span class="title class_">protocols</span>#&gt; {</span><br><span class="line">    <span class="keyword">case</span> <span class="operator">&lt;</span>#enumeration <span class="keyword">case</span> <span class="number">1</span>#<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="operator">&lt;</span>#enumeration <span class="keyword">case</span> <span class="number">2</span>#<span class="operator">&gt;</span>(<span class="operator">&lt;</span>#associated value types#<span class="operator">&gt;</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种形式的枚举声明在其他语言中有时被叫做<em>可识别联合</em>。</p>
<p>在这种形式中，每个用例块由 <code>case</code> 关键字开始，后面跟着一个或多个枚举用例，用逗号分隔。每个用例的名称必须是唯一的。每个用例还可以指定它存储特定类型的值。这些类型在<em>关联值类型</em>元组中指定，紧接在用例名称之后。</p>
<p>存储关联值的枚举成员可以用作函数，这些函数创建具有指定关联值的枚举实例。就像函数一样，你可以获取对枚举成员的引用，并在代码中稍后应用它。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Number</span> {</span><br><span class="line">    <span class="keyword">case</span> integer(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> real(<span class="type">Double</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> f <span class="operator">=</span> <span class="type">Number</span>.integer</span><br><span class="line"><span class="comment">// f 是一个 (Int) -&gt; Number 的函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用函数 `f` 来创建一个包含整数值的 `Number` 实例数组</span></span><br><span class="line"><span class="keyword">let</span> evenInts: [<span class="type">Number</span>] <span class="operator">=</span> [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>].map(f)</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `enum-case-as-function`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; enum Number &#123;</span><br><span class="line">      case integer(Int)</span><br><span class="line">      case real(Double)</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; let f = Number.integer</span><br><span class="line">-&gt; // f is a function of type (Int) -&gt; Number</span><br><span class="line">---</span><br><span class="line">-&gt; // Apply f to create an array of Number instances with integer values</span><br><span class="line">-&gt; let evenInts: [Number] = [0, 2, 4, 6].map(f)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  No expectation for evenInts because there isn't a good way to spell one.
  Using print() puts a module prefix like tmpabc in front of Number
  so the expectation would need to be a regex (which we don't have),
  and assert() would require Number to conform to Equatable.
-->

<p>有关更多信息以及查看枚举关联值的示例，请参见 <a href="doc:Enumerations#关联值">doc:Enumerations#关联值</a>。</p>
<h4 id="间接枚举"><a href="#间接枚举" class="headerlink" title="间接枚举"></a>间接枚举</h4><p>枚举类型可以具有递归结构，就是说，枚举用例的关联值类型可以是枚举类型自身。然而，枚举类型的实例具有值语义，这意味着它们在内存中有固定布局。为了支持递归，编译器必须插入一个间接层。</p>
<p>要让某个枚举用例支持递归，请使用 <code>indirect</code> 声明修饰符进行标记。间接枚举成员必须具有关联值。</p>
<!--
  TODO The word "enable" is kind of a weasel word.
  Better to have a more concrete discussion of exactly when
  it is and isn't used.
  For example, does "indirect enum { X(Int) } mark X as indirect?
-->

<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Tree</span>&lt;<span class="title class_">T</span>&gt; {</span><br><span class="line">    <span class="keyword">case</span> empty</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> node(value: <span class="type">T</span>, left: <span class="type">Tree</span>, right: <span class="type">Tree</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `indirect-enum`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; enum Tree&lt;T&gt; &#123;</span><br><span class="line">      case empty</span><br><span class="line">      indirect case node(value: T, left: Tree, right: Tree)</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&gt; let l1 = Tree.node(value: 10, left: Tree.empty, right: Tree.empty)</span><br><span class="line">&gt;&gt; let l2 = Tree.node(value: 100, left: Tree.empty, right: Tree.empty)</span><br><span class="line">&gt;&gt; let t = Tree.node(value: 50, left: l1, right: l2)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>要让一个枚举类型的所有用例都支持递归，请使用 <code>indirect</code> 修饰符标记整个枚举——当枚举包含许多需要标记为 <code>indirect</code> 修饰符的用例时，这样做非常方便。</p>
<p>使用 <code>indirect</code> 修饰符标记的枚举类型可以既包含有关联值的用例，同时还可包含没有关联值的用例。但是，它不能再单独使用 <code>indirect</code> 修饰符来标记某个用例。</p>
<!--
  It really should be an associated value **that includes the enum type**
  but right now the compiler is satisfied with any associated value.
  Alex emailed Joe Groff 2015-07-08 about this.
-->

<!--
  assertion indirect-in-indirect

  -> indirect enum E { indirect case c(E) }
  !! <REPL Input>:1:19: error: enum case in 'indirect' enum cannot also be 'indirect'
  !! indirect enum E { indirect case c(E) }
  !!                   ^
-->

<!--
  assertion indirect-without-recursion

  -> enum E { indirect case c }
  !! <REPL Input>:1:10: error: enum case 'c' without associated value cannot be 'indirect'
  !! enum E { indirect case c }
  !!          ^
  ---
  -> enum E1 { indirect case c() }     // This is fine, but probably shouldn't be
  -> enum E2 { indirect case c(Int) }  // This is fine, but probably shouldn't be
  ---
  -> indirect enum E3 { case x }
-->

<h3 id="带有原始值类型的枚举"><a href="#带有原始值类型的枚举" class="headerlink" title="带有原始值类型的枚举"></a>带有原始值类型的枚举</h3><p>以下形式声明了一个枚举类型，其中包含相同基本类型的枚举成员：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &lt;#<span class="title class_">enumeration</span> <span class="title class_">name</span>#&gt;: &lt;#<span class="title class_">raw</span>-<span class="title class_">value</span> <span class="title class_">type</span>#&gt;, &lt;#<span class="title class_">adopted</span> <span class="title class_">protocols</span>#&gt; {</span><br><span class="line">    <span class="keyword">case</span> <span class="operator">&lt;</span>#enumeration <span class="keyword">case</span> <span class="number">1</span>#<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>#raw value <span class="number">1</span>#<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="operator">&lt;</span>#enumeration <span class="keyword">case</span> <span class="number">2</span>#<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>#raw value <span class="number">2</span>#<span class="operator">&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这种形式中，每个用例块由 <code>case</code> 关键字开始，后面跟着一个或多个枚举用例，用逗号分隔。与第一种形式中的用例不同，每个用例都有一个基础值，称为<em>原始值</em>，其基本类型相同。这些值的类型在<em>原始值类型</em>中指定，必须表示整数、浮点数、字符串或单个字符。特别是，<em>原始值类型</em>必须遵循 <code>Equatable</code> 协议，并且遵循以下协议之一：<code>ExpressibleByIntegerLiteral</code> 用于整型字面量，<code>ExpressibleByFloatLiteral</code> 用于浮点型字面量，<code>ExpressibleByStringLiteral</code> 用于包含任意数量字符的字符串字面量，以及 <code>ExpressibleByUnicodeScalarLiteral</code> 或 <code>ExpressibleByExtendedGraphemeClusterLiteral</code> 用于仅包含单个字符的字符串字面量。每一个用例的名字和原始值必须唯一。</p>
<!--
  The list of ExpressibleBy... protocols above also appears in LexicalStructure_Literals.
  This list is shorter because these five protocols are explicitly supported in the compiler.
-->

<p>如果原始值类型被指定为 <code>Int</code>，并且你没有显式地为这些用例分配值，它们将隐式地被分配值 <code>0</code>、<code>1</code>、<code>2</code>，依此类推。每个未分配的 <code>Int</code> 类型的用例将隐式地被分配一个原始值，该值是从前一个用例的原始值自动递增的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ExampleEnum</span>: <span class="title class_">Int</span> {</span><br><span class="line">    <span class="keyword">case</span> a, b, c <span class="operator">=</span> <span class="number">5</span>, d</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `raw-value-enum`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; enum ExampleEnum: Int &#123;</span><br><span class="line">      case a, b, c = 5, d</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>在上述示例中，<code>ExampleEnum.a</code> 的原始值为 <code>0</code>，而 <code>ExampleEnum.b</code> 的值为 <code>1</code>。由于 <code>ExampleEnum.c</code> 的值被显式设置为 <code>5</code>，因此 <code>ExampleEnum.d</code> 的值自动从 <code>5</code> 增加，结果为 <code>6</code>。</p>
<p>如果原始值类型被指定为 <code>String</code>，并且你没有显式地为各个用例分配值，则每个未分配的用例会隐式地分配一个与该成员名称相同文本的字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">GamePlayMode</span>: <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> cooperative, individual, competitive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `raw-value-enum-implicit-string-values`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; enum GamePlayMode: String &#123;</span><br><span class="line">      case cooperative, individual, competitive</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>在上述示例中，<code>GamePlayMode.cooperative</code> 的原始值是 <code>&quot;cooperative&quot;</code>，<code>GamePlayMode.individual</code> 的原始值是 <code>&quot;individual&quot;</code>，而 <code>GamePlayMode.competitive</code> 的原始值是 <code>&quot;competitive&quot;</code>。</p>
<p>具有原始值类型的枚举隐式遵循在 Swift 标准库中定义的 <code>RawRepresentable</code> 协议。因此，它们具有 <code>rawValue</code> 属性和一个可失败构造器，其签名为 <code>init?(rawValue: RawValue)</code>。你可以使用 <code>rawValue</code> 属性访问枚举用例的原始值，如 <code>ExampleEnum.b.rawValue</code>。你还可以使用原始值通过调用枚举的可失败构造器来查找相应的用例，如 <code>ExampleEnum(rawValue: 5)</code>，这将返回一个可选的用例。有关更多信息以及查看具有原始值类型的案例示例，请参见 <a href="doc:Enumerations#原始值">doc:Enumerations#原始值</a>。</p>
<h3 id="访问枚举成员"><a href="#访问枚举成员" class="headerlink" title="访问枚举成员"></a>访问枚举成员</h3><p>要引用枚举类型的用例，请使用点（<code>.</code>）语法，如 <code>EnumerationType.enumerationCase</code> 所示。当枚举类型可以从上下文中推断时，可以省略它（仍然需要 <code>.</code>），参见 <a href="doc:Enumerations#枚举语法">doc:Enumerations#枚举语法</a> 和 <a href="doc:Expressions#隐式成员表达式">doc:Expressions#隐式成员表达式</a>。</p>
<p>要检查枚举用例的值，请使用 <code>switch</code> 语句，如 <a href="doc:Enumerations#使用-Switch-语句匹配枚举值">doc:Enumerations#使用-Switch-语句匹配枚举值</a> 中所示。在 <code>switch</code> 语句的用例分支中，枚举类型会与枚举用例进行模式匹配，详见 <a href="doc:Patterns#枚举用例模式">doc:Patterns#枚举用例模式</a>。</p>
<!--
  FIXME: Or use if-case:
  enum E { case c(Int) }
  let e = E.c(100)
  if case E.c(let i) = e { print(i) }
  // prints 100
-->

<!--
  NOTE: Note that you can require protocol adoption,
  by using a protocol type as the raw-value type,
  but you do need to make it be one of the types
  that support = in order for you to specify the raw values.
  You can have: <#raw-value type, protocol conformance#>.
  UPDATE: You can only have one raw-value type specified.
  I changed the grammar to be more restrictive in light of this.
-->

<!--
  NOTE: Per Doug and Ted, "('->' type)?" isn't part of the grammar.
  We removed it from our grammar, below.
-->

<blockquote>
<p>枚举声明的语法:</p>
<p><em>enum-declaration</em> → <em>attributes</em><em>?</em> <em>access-level-modifier</em><em>?</em> <em>union-style-enum</em> <br><em>enum-declaration</em> → <em>attributes</em><em>?</em> <em>access-level-modifier</em><em>?</em> <em>raw-value-style-enum</em></p>
<p><em>union-style-enum</em> → <strong><code>indirect</code></strong><em>?</em> <strong><code>enum</code></strong> <em>enum-name</em> <em>generic-parameter-clause</em><em>?</em> <em>type-inheritance-clause</em><em>?</em> <em>generic-where-clause</em><em>?</em> <strong><code>{</code></strong> <em>union-style-enum-members</em><em>?</em> <strong><code>}</code></strong> <br><em>union-style-enum-members</em> → <em>union-style-enum-member</em> <em>union-style-enum-members</em><em>?</em> <br><em>union-style-enum-member</em> → <em>declaration</em> | <em>union-style-enum-case-clause</em> | <em>compiler-control-statement</em> <br><em>union-style-enum-case-clause</em> → <em>attributes</em><em>?</em> <strong><code>indirect</code></strong><em>?</em> <strong><code>case</code></strong> <em>union-style-enum-case-list</em> <br><em>union-style-enum-case-list</em> → <em>union-style-enum-case</em> | <em>union-style-enum-case</em> <strong><code>,</code></strong> <em>union-style-enum-case-list</em> <br><em>union-style-enum-case</em> → <em>enum-case-name</em> <em>tuple-type</em><em>?</em> <br><em>enum-name</em> → <em>identifier</em> <br><em>enum-case-name</em> → <em>identifier</em></p>
<p><em>raw-value-style-enum</em> → <strong><code>enum</code></strong> <em>enum-name</em> <em>generic-parameter-clause</em><em>?</em> <em>type-inheritance-clause</em> <em>generic-where-clause</em><em>?</em> <strong><code>{</code></strong> <em>raw-value-style-enum-members</em> <strong><code>}</code></strong> <br><em>raw-value-style-enum-members</em> → <em>raw-value-style-enum-member</em> <em>raw-value-style-enum-members</em><em>?</em> <br><em>raw-value-style-enum-member</em> → <em>declaration</em> | <em>raw-value-style-enum-case-clause</em> | <em>compiler-control-statement</em> <br><em>raw-value-style-enum-case-clause</em> → <em>attributes</em><em>?</em> <strong><code>case</code></strong> <em>raw-value-style-enum-case-list</em> <br><em>raw-value-style-enum-case-list</em> → <em>raw-value-style-enum-case</em> | <em>raw-value-style-enum-case</em> <strong><code>,</code></strong> <em>raw-value-style-enum-case-list</em> <br><em>raw-value-style-enum-case</em> → <em>enum-case-name</em> <em>raw-value-assignment</em><em>?</em> <br><em>raw-value-assignment</em> → <strong><code>=</code></strong> <em>raw-value-literal</em> <br><em>raw-value-literal</em> → <em>numeric-literal</em> | <em>static-string-literal</em> | <em>boolean-literal</em></p>
</blockquote>
<!--
  NOTE: The two types of enums are sufficiently different enough to warrant separating
  the grammar accordingly. ([Contributor 6004] pointed this out in his email.)
  I'm not sure I'm happy with the names I've chosen for two kinds of enums,
  so please let me know if you can think of better names (Tim and Dave are OK with them)!
  I chose union-style-enum, because this kind of enum behaves like a discriminated union,
  not like an ordinary enum type. They're a kind of "sum" type in the language
  of ADTs (Algebraic Data Types). Functional languages, like F# for example,
  actually have both types (discriminated unions and enumeration types),
  because they behave differently. I'm not sure why we've blended them together,
  especially given that they have distinct syntactic declaration requirements
  and they behave differently.
-->

<h2 id="结构体声明"><a href="#结构体声明" class="headerlink" title="结构体声明"></a>结构体声明</h2><p><em>结构体声明</em>将一个具名的结构体类型引入到你的程序中。结构体声明使用 <code>struct</code> 关键字声明，具有以下形式：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &lt;#<span class="title class_">structure</span> <span class="title class_">name</span>#&gt;: &lt;#<span class="title class_">adopted</span> <span class="title class_">protocols</span>#&gt; {</span><br><span class="line">    <span class="operator">&lt;</span>#declarations#<span class="operator">&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结构体的主体包含零个或多个<em>声明</em>。这些<em>声明</em>可以包括存储属性和计算属性、类型属性、实例方法、类型方法、构造器、下标、类型别名，甚至其他结构体、类、actor 和枚举声明。结构体声明不能包含析构器或协议声明。有关包含各种类型声明的结构体的讨论和多个示例，请参见 <a href="doc:ClassesAndStructures">doc:ClassesAndStructures</a>。</p>
<p>结构体类型可以采用任意数量的协议，但不能从类、枚举或其他结构体继承。</p>
<p>有三种方法可以创建先前声明的结构体的实例：</p>
<ul>
<li>调用结构体中声明的某个构造器，参见 <a href="doc:Initialization#构造器">doc:Initialization#构造器</a>。</li>
<li>如果没有声明构造器，则调用结构体的成员遍历构造器，参见 <a href="doc:Initialization#结构体类型的成员逐一构造器">doc:Initialization#结构体类型的成员逐一构造器</a>。</li>
<li>如果没有声明构造器，且结构体声明的所有属性都给定了初始值，则调用结构体的默认构造器，参见 <a href="doc:Initialization#默认构造器">doc:Initialization#默认构造器</a>。</li>
</ul>
<p>初始化结构体中声明属性的过程在 <a href="doc:Initialization">doc:Initialization</a> 中描述。</p>
<p>结构体实例的属性可以使用点 (<code>.</code>) 语法访问，参见 <a href="doc:ClassesAndStructures#访问属性">doc:ClassesAndStructures#访问属性</a>。</p>
<p>结构体是值类型；当结构体的实例被赋值给变量或常量，或作为参数传递给函数调用时，会被复制。有关值类型的信息，请参见 <a href="doc:ClassesAndStructures#结构体和枚举是值类型">doc:ClassesAndStructures#结构体和枚举是值类型</a>。</p>
<p>你可以通过扩展声明来扩展结构体类型的行为，参见 <a href="doc:Declarations#扩展声明">doc:Declarations#扩展声明</a>。</p>
<blockquote>
<p>结构体声明的语法:</p>
<p><em>struct-declaration</em> → <em>attributes</em><em>?</em> <em>access-level-modifier</em><em>?</em> <strong><code>struct</code></strong> <em>struct-name</em> <em>generic-parameter-clause</em><em>?</em> <em>type-inheritance-clause</em><em>?</em> <em>generic-where-clause</em><em>?</em> <em>struct-body</em> <br><em>struct-name</em> → <em>identifier</em> <br><em>struct-body</em> → <strong><code>{</code></strong> <em>struct-members</em><em>?</em> <strong><code>}</code></strong></p>
<p><em>struct-members</em> → <em>struct-member</em> <em>struct-members</em><em>?</em> <br><em>struct-member</em> → <em>declaration</em> | <em>compiler-control-statement</em></p>
</blockquote>
<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p><em>类声明</em>将一个具名的类类型引入到你的程序中。类声明使用 <code>class</code> 关键字声明，具有以下形式：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;#<span class="title class_">class</span> <span class="title class_">name</span>#&gt;: &lt;#<span class="title class_">superclass</span>#&gt;, &lt;#<span class="title class_">adopted</span> <span class="title class_">protocols</span>#&gt; {</span><br><span class="line">    <span class="operator">&lt;</span>#declarations#<span class="operator">&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>类的主体包含零个或多个<em>声明</em>。这些<em>声明</em>可以包括存储属性和计算属性、实例方法、类型方法、构造器、一个析构器、下标、类型别名，甚至其他类、结构体、actor 和枚举声明。类声明不能包含协议声明。有关包含各种类型声明的类的讨论和多个示例，请参见 <a href="doc:ClassesAndStructures">doc:ClassesAndStructures</a>。</p>
<p>类类型只能继承自一个父类，即它的<em>超类</em>，但可以采用任意数量的协议。<em>超类</em>在<em>类名</em>和冒号之后首先出现，后面跟着任何<em>采用的协议</em>。泛型类可以继承其他泛型和非泛型类，但非泛型类只能继承其他非泛型类。当你在冒号后写泛型超类的名称时，必须包括该泛型类的全名，包括其泛型参数子句。</p>
<p>如在 <a href="doc:Declarations#构造器声明">doc:Declarations#构造器声明</a> 中讨论的，类可以有指定构造器和便利构造器。类的指定构造器必须初始化所有声明的属性，并且必须在调用任何超类的指定构造器之前完成此操作。</p>
<p>类可以重写其超类的属性、方法、下标和构造器。重写的属性、方法、下标和指定构造器必须标记为 <code>override</code> 声明修饰符。</p>
<!--
  - test: `designatedInitializersRequireOverride`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; class C &#123; init() &#123;&#125; &#125;</span><br><span class="line">-&gt; class D: C &#123; override init() &#123; super.init() &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>要要求子类实现超类的构造器，请使用 <code>required</code> 声明修饰符标记超类的构造器。子类对该构造器的实现也必须使用 <code>required</code> 声明修饰符进行标记。</p>
<p>尽管在<em>超类</em>中声明的属性和方法被当前类继承，但在<em>超类</em>中声明的指定构造器仅在子类满足 <a href="doc:Initialization#构造器的自动继承">doc:Initialization#构造器的自动继承</a> 中描述的条件时才会被继承。Swift 类不从通用基类继承。</p>
<p>有两种方法可以创建一个先前声明的类的实例：</p>
<ul>
<li>调用类中声明的某个构造器，参见 <a href="doc:Initialization#构造器">doc:Initialization#构造器</a>。</li>
<li>如果没有声明构造器，且类声明的所有属性都给定了初始值，则调用类的默认构造器，参见 <a href="doc:Initialization#默认构造器">doc:Initialization#默认构造器</a>。</li>
</ul>
<p>使用点（<code>.</code>）语法访问类实例的属性，参见 <a href="doc:ClassesAndStructures#访问属性">doc:ClassesAndStructures#访问属性</a>。</p>
<p>类是引用类型；当类的实例被赋值给变量或常量，或作为参数传递给函数调用时，是引用而不是复制。有关引用类型的信息，请参见 <a href="doc:ClassesAndStructures#类是引用类型">doc:ClassesAndStructures#类是引用类型</a>。</p>
<p>你可以通过扩展声明扩展类类型的行为，参见 <a href="doc:Declarations#扩展声明">doc:Declarations#扩展声明</a>。</p>
<blockquote>
<p>类声明的语法:</p>
<p><em>class-declaration</em> → <em>attributes</em><em>?</em> <em>access-level-modifier</em><em>?</em> <strong><code>final</code></strong><em>?</em> <strong><code>class</code></strong> <em>class-name</em> <em>generic-parameter-clause</em><em>?</em> <em>type-inheritance-clause</em><em>?</em> <em>generic-where-clause</em><em>?</em> <em>class-body</em> <br><em>class-declaration</em> → <em>attributes</em><em>?</em> <strong><code>final</code></strong> <em>access-level-modifier</em><em>?</em> <strong><code>class</code></strong> <em>class-name</em> <em>generic-parameter-clause</em><em>?</em> <em>type-inheritance-clause</em><em>?</em> <em>generic-where-clause</em><em>?</em> <em>class-body</em> <br><em>class-name</em> → <em>identifier</em> <br><em>class-body</em> → <strong><code>&#123;</code></strong> <em>class-members</em><em>?</em> <strong><code>&#125;</code></strong></p>
<p><em>class-members</em> → <em>class-member</em> <em>class-members</em><em>?</em> <br><em>class-member</em> → <em>declaration</em> | <em>compiler-control-statement</em></p>
</blockquote>
<h2 id="Actor-声明"><a href="#Actor-声明" class="headerlink" title="Actor 声明"></a>Actor 声明</h2><p><em>actor 声明</em>将一个具名的 actor 类型引入到你的程序中。actor 声明使用 <code>actor</code> 关键字声明，具有以下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> &lt;#<span class="title class_">actor</span> <span class="title class_">name</span>#&gt;: &lt;#<span class="title class_">adopted</span> <span class="title class_">protocols</span>#&gt; &#123;</span><br><span class="line">    <span class="operator">&lt;</span>#declarations#<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>actor 的主体包含零个或多个<em>声明</em>。这些<em>声明</em>可以包括存储属性和计算属性、实例方法、类型方法、构造器、一个析构器、下标、类型别名，甚至其他类、结构体和枚举声明。有关包含各种声明的 actor 的讨论和多个示例，请参见 <a href="doc:Concurrency#Actors">doc:Concurrency#Actors</a>。</p>
<p>actor 类型可以采用任意数量的协议，但不能从类、枚举、结构体或其他 actor 继承。然而，标记为 <code>@objc</code> 特性的 actor 隐式地遵循 <code>NSObjectProtocol</code> 协议，并作为 <code>NSObject</code> 的子类型暴露给 Objective-C 运行时。</p>
<p>有两种方法可以创建一个先前声明的 actor 的实例：</p>
<ul>
<li>调用 actor 中声明的某个构造方法，参见 <a href="doc:Initialization#构造器">doc:Initialization#构造器</a>。</li>
<li>如果没有声明初始值，并且 actor 声明的所有属性都给定了初始值，则调用 actor 的默认构造器，参见 <a href="doc:Initialization#默认构造器">doc:Initialization#默认构造器</a>。</li>
</ul>
<p>默认情况下，actor 的成员是与该 actor 隔离的。方法体或属性的 getter 等代码是在该 actor 上执行的。actor 内部的代码可以同步地与这些成员交互，因为代码已经在同一个 actor 上运行；但 actor 外部的代码必须使用 <code>await</code> 标记，以表明该代码是异步地在另一个 actor 上运行的。键路径不能引用 actor 的隔离成员。actor 隔离的存储属性可以作为 in-out 参数传递给同步函数，但不能传递给异步函数。</p>
<p>actor 还可以拥有非隔离成员，其声明使用 <code>nonisolated</code> 关键字标记。非隔离成员的执行方式类似于 actor 外部的代码：它无法与 actor 的任何隔离状态交互，调用者在使用时也不需要使用 <code>await</code> 进行标记。</p>
<p>actor 的成员只有在它们是非隔离或异步的情况下才能标记为 <code>@objc</code> 属性。</p>
<p>初始化 actor 中声明的属性的过程，参见 <a href="doc:Initialization">doc:Initialization</a>。</p>
<p>actor 实例的属性可以使用点 (<code>.</code>) 语法访问，参见 <a href="doc:ClassesAndStructures#访问属性">doc:ClassesAndStructures#访问属性</a>。</p>
<p>actor 是引用类型；当分配给变量或常量，或作为参数传递给函数调用时，actor 的实例是被引用而不是复制。有关引用类型的信息，请参见 <a href="doc:ClassesAndStructures#类是引用类型">doc:ClassesAndStructures#类是引用类型</a>。</p>
<p>你可以通过扩展声明扩展 actor 类型的行为，参见 <a href="doc:Declarations#扩展声明">doc:Declarations#扩展声明</a>。</p>
<!--
  TODO Additional bits from the SE-0306 actors proposal:

  Partial applications of isolated functions are only permitted
  when the expression is a direct argument
  whose corresponding parameter is non-escaping and non-Sendable.
-->

<blockquote>
<p>actor 声明的语法:</p>
<p><em>actor-declaration</em> → <em>attributes</em><em>?</em> <em>access-level-modifier</em><em>?</em> <strong><code>actor</code></strong> <em>actor-name</em> <em>generic-parameter-clause</em><em>?</em> <em>type-inheritance-clause</em><em>?</em> <em>generic-where-clause</em><em>?</em> <em>actor-body</em> <br><em>actor-name</em> → <em>identifier</em> <br><em>actor-body</em> → <strong><code>{</code></strong> <em>actor-members</em><em>?</em> <strong><code>}</code></strong></p>
<p><em>actor-members</em> → <em>actor-member</em> <em>actor-members</em><em>?</em> <br><em>actor-member</em> → <em>declaration</em> | <em>compiler-control-statement</em></p>
</blockquote>
<h2 id="协议声明"><a href="#协议声明" class="headerlink" title="协议声明"></a>协议声明</h2><p><em>协议声明</em>将一个具名的协议类型引入到你的程序中。协议声明使用 <code>protocol</code> 关键字声明，具有以下形式：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> &lt;#<span class="title class_">protocol</span> <span class="title class_">name</span>#&gt;: &lt;#<span class="title class_">inherited</span> <span class="title class_">protocols</span>#&gt; {</span><br><span class="line">    <span class="operator">&lt;</span>#<span class="keyword">protocol</span> <span class="title class_">member</span> <span class="title class_">declarations</span>#&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>协议声明可以出现在全局作用域内，或嵌套在非泛型类型或非泛型函数内部。</p>
<p>协议的主体包含零个或多个<em>协议成员声明</em>，这些声明描述了任何采用该协议的类型必须满足的遵循性要求。特别是，协议可以声明遵循的类型必须实现某些属性、方法、构造器和下标。协议还可以声明特殊类型的类型别名，称为<em>关联类型</em>，可以指定协议中各种声明之间的关系。协议声明不能包含类、结构体、枚举或其他协议声明。<em>协议成员声明</em>将在下面详细讨论。</p>
<p>协议类型可以从任意数量的其他协议继承。当一个协议类型从其他协议继承时，这些其他协议的要求集合会被聚合，任何从当前协议继承的类型必须遵循所有这些要求。有关如何使用协议继承的示例，请参见 <a href="doc:Protocols#协议的继承">doc:Protocols#协议的继承</a>。</p>
<blockquote>
<p>注意:<br>你还可以使用协议组合类型聚合多个协议的合规性要求，参见 <a href="doc:Types#协议组合类型">doc:Types#协议组合类型</a> 和 <a href="doc:Protocols#协议组合">doc:Protocols#协议组合</a>。</p>
</blockquote>
<p>你可以通过在该类型的扩展声明中采用协议，为先前声明的类型添加协议遵循性。在扩展中，你必须实现所采用协议的所有要求。如果该类型已经实现了所有要求，你可以将扩展声明的主体留空。</p>
<p>默认情况下，遵循协议的类型必须实现协议中声明的所有属性、方法和下标。也就是说，你可以使用 <code>optional</code> 声明修饰符来标记这些协议成员声明，以指定遵循类型的实现是可选的。<code>optional</code> 修饰符只能应用于标记为 <code>objc</code> 特性的成员，并且只能应用于标记为 <code>objc</code> 特性的协议成员。因此，只有类类型可以采用并遵循包含可选成员要求的协议。有关如何使用 <code>optional</code> 声明修饰符的信息，以及如何访问可选协议成员的指导——例如，当你不确定遵循类型是否实现它们时——请参见 <a href="doc:Protocols#可选协议要求">doc:Protocols#可选协议要求</a>。</p>
<!--
  TODO: Currently, you can't check for an optional initializer,
  so we're leaving those out of the documentation, even though you can mark
  an initializer with the @optional attribute. It's still being decided by the
  compiler team. Update this section if they decide to make everything work
  properly for optional initializer requirements.
-->

<p>枚举的用例可以满足类型成员的协议要求。具体来说，没有任何关联值的枚举用例满足类型 <code>Self</code> 的只读类型变量的协议要求，而具有关联值的枚举成员满足返回 <code>Self</code> 的函数的协议要求，该函数的参数及其实参标签与枚举成员的关联值匹配。例如：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> someValue: <span class="keyword">Self</span> { <span class="keyword">get</span> }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">x</span>: <span class="type">Int</span>) -&gt; <span class="keyword">Self</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span>: <span class="title class_">SomeProtocol</span> {</span><br><span class="line">    <span class="keyword">case</span> someValue</span><br><span class="line">    <span class="keyword">case</span> someFunction(x: <span class="type">Int</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `enum-case-satisfy-protocol-requirement`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol SomeProtocol &#123;</span><br><span class="line">       static var someValue: Self &#123; get &#125;</span><br><span class="line">       static func someFunction(x: Int) -&gt; Self</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; enum MyEnum: SomeProtocol &#123;</span><br><span class="line">       case someValue</span><br><span class="line">       case someFunction(x: Int)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>要将协议的采用限制为类类型，只需在冒号后将 <code>AnyObject</code> 协议包含在<em>继承协议</em>列表中。例如，以下协议只能被类类型采用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span>: <span class="title class_">AnyObject</span> &#123;</span><br><span class="line">    <span class="comment">/* 协议成员写在这里 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `protocol-declaration`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol SomeProtocol: AnyObject &#123;</span><br><span class="line">       /* Protocol members go here */</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>任何从标记为 <code>AnyObject</code> 要求的协议继承的协议，也只能被类类型采用。</p>
<blockquote>
<p>注意:<br>如果一个协议标记了 <code>objc</code> 特性，则 <code>AnyObject</code> 要求隐式应用于该协议；无需显式的将该协议标记为 <code>AnyObject</code> 要求。</p>
</blockquote>
<p>协议是具名类型，因此它们可以出现在代码中与其他具名类型相同的位置，如 <a href="doc:Protocols#协议作为类型">doc:Protocols#协议作为类型</a> 中所讨论的。然而，你无法构造协议的实例，因为协议实际上并不提供它们所指定的要求的实现。</p>
<p>你可以使用协议来声明类或结构体的代理应该实现哪些方法，参见 <a href="doc:Protocols#代理">doc:Protocols#代理</a>。</p>
<blockquote>
<p>协议声明的语法:</p>
<p><em>protocol-declaration</em> → <em>attributes</em><em>?</em> <em>access-level-modifier</em><em>?</em> <strong><code>protocol</code></strong> <em>protocol-name</em> <em>type-inheritance-clause</em><em>?</em> <em>generic-where-clause</em><em>?</em> <em>protocol-body</em> <br><em>protocol-name</em> → <em>identifier</em> <br><em>protocol-body</em> → <strong><code>&#123;</code></strong> <em>protocol-members</em><em>?</em> <strong><code>&#125;</code></strong></p>
<p><em>protocol-members</em> → <em>protocol-member</em> <em>protocol-members</em><em>?</em> <br><em>protocol-member</em> → <em>protocol-member-declaration</em> | <em>compiler-control-statement</em></p>
<p><em>protocol-member-declaration</em> → <em>protocol-property-declaration</em> <br><em>protocol-member-declaration</em> → <em>protocol-method-declaration</em> <br><em>protocol-member-declaration</em> → <em>protocol-initializer-declaration</em> <br><em>protocol-member-declaration</em> → <em>protocol-subscript-declaration</em> <br><em>protocol-member-declaration</em> → <em>protocol-associated-type-declaration</em> <br><em>protocol-member-declaration</em> → <em>typealias-declaration</em></p>
</blockquote>
<h3 id="协议属性声明"><a href="#协议属性声明" class="headerlink" title="协议属性声明"></a>协议属性声明</h3><p>协议通过在协议声明体中包含一个<em>协议属性声明</em>，规定遵循该协议的类型必须实现一个属性。协议属性声明是一种特殊形式的变量声明，格式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="operator">&lt;</span>#property name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#type#<span class="operator">&gt;</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>

<p>与其他协议成员声明一样，这些属性声明仅声明遵循该协议的类型的 getter 和 setter 要求。因此，你不会在声明它的协议中直接实现 getter 或 setter。</p>
<p>遵循协议的类型可以通过多种方式满足 getter 和 setter 的要求。如果属性声明同时包含 <code>get</code> 和 <code>set</code> 关键字，遵循类型可以用存储变量属性或可读写的计算属性（即实现了 getter 和 setter 的属性）来实现。然而，这样的属性声明不能被实现为常量属性或只读计算属性。如果属性声明只包含 <code>get</code> 关键字，则可以实现为任何类型的属性。关于符合协议类型如何实现属性要求的示例，参见 <a href="doc:Protocols#属性要求">doc:Protocols#属性要求</a>。</p>
<p>在协议声明中声明类型属性要求时，使用 <code>static</code> 关键字标记属性声明。遵循该协议的结构体和枚举使用 <code>static</code> 关键字声明属性，而遵循该协议的类则可以使用 <code>static</code> 或 <code>class</code> 关键字声明属性。为结构体、枚举或类添加协议遵循的扩展使用与其扩展的类型相同的关键字。为类型属性要求提供默认实现的扩展使用 <code>static</code> 关键字。</p>
<!--
  - test: `protocols-with-type-property-requirements`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol P &#123; static var x: Int &#123; get &#125; &#125;</span><br><span class="line">-&gt; protocol P2 &#123; class var x: Int &#123; get &#125; &#125;</span><br><span class="line">!$ error: class properties are only allowed within classes; use &#x27;static&#x27; to declare a requirement fulfilled by either a static or class property</span><br><span class="line">!! protocol P2 &#123; class var x: Int &#123; get &#125; &#125;</span><br><span class="line">!!              ~~~~~ ^</span><br><span class="line">!!              static</span><br><span class="line">-&gt; struct S: P &#123; static var x = 10 &#125;</span><br><span class="line">-&gt; class C1: P &#123; static var x = 20 &#125;</span><br><span class="line">-&gt; class C2: P &#123; class var x = 30 &#125;</span><br><span class="line">!$ error: class stored properties not supported in classes; did you mean &#x27;static&#x27;?</span><br><span class="line">!! class C2: P &#123; class var x = 30 &#125;</span><br><span class="line">!!               ~~~~~     ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `protocol-type-property-default-implementation`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol P &#123; static var x: Int &#123; get &#125; &#125;</span><br><span class="line">-&gt; extension P &#123; static var x: Int &#123; return 100 &#125; &#125;</span><br><span class="line">-&gt; struct S1: P &#123; &#125;</span><br><span class="line">-&gt; print(S1.x)</span><br><span class="line">&lt;- 100</span><br><span class="line">-&gt; struct S2: P &#123; static var x = 10 &#125;</span><br><span class="line">-&gt; print(S2.x)</span><br><span class="line">&lt;- 10</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>另见 <a href="doc:Declarations#变量声明">doc:Declarations#变量声明</a>。</p>
<blockquote>
<p>协议属性声明的语法:</p>
<p><em>protocol-property-declaration</em> → <em>variable-declaration-head</em> <em>variable-name</em> <em>type-annotation</em> <em>getter-setter-keyword-block</em></p>
</blockquote>
<h3 id="协议方法声明"><a href="#协议方法声明" class="headerlink" title="协议方法声明"></a>协议方法声明</h3><p>协议通过在协议声明体中包含一个协议方法声明，规定遵循该协议的类型必须实现一个方法。协议方法声明的形式与函数声明相同，但有两个例外：它们不包含函数体，且不能在函数声明中提供任何默认参数值。关于遵循协议类型如何实现方法要求的示例，参见 <a href="doc:Protocols#方法要求">doc:Protocols#方法要求</a>。</p>
<p>在协议声明中声明类或静态方法的要求时，使用 <code>static</code> 修饰符标记方法声明。遵循该协议的结构体和枚举使用 <code>static</code> 关键字声明该方法，而遵循该协议的类则使用 <code>static</code> 或 <code>class</code> 关键字声明该方法。为结构体、枚举或类添加协议遵循的扩展使用与其扩展的类型相同的关键字。为类型方法要求提供默认实现的扩展使用 <code>static</code> 关键字。</p>
<p>另见 <a href="doc:Declarations#函数声明">doc:Declarations#函数声明</a>。</p>
<!--
  TODO: Talk about using ``Self`` in parameters and return types.
-->

<blockquote>
<p>协议方法声明的语法:</p>
<p><em>protocol-method-declaration</em> → <em>function-head</em> <em>function-name</em> <em>generic-parameter-clause</em><em>?</em> <em>function-signature</em> <em>generic-where-clause</em><em>?</em></p>
</blockquote>
<h3 id="协议构造器声明"><a href="#协议构造器声明" class="headerlink" title="协议构造器声明"></a>协议构造器声明</h3><p>协议通过在协议声明的主体中包含协议构造器声明，要求遵循的类型必须实现一个构造器。协议构造器声明的形式与构造器声明相同，只是不包括构造器的主体。</p>
<p>遵循类型可以通过实现一个非可失败构造器或一个 <code>init!</code> 可失败构造器来满足非可失败协议构造器的要求。一个遵循类型可以通过实现任何类型的构造器来满足可失败协议构造器的要求。</p>
<p>当一个类实现一个构造器以满足协议的构造器要求时，如果该类尚未标记为 <code>final</code> 声明修饰符，则构造器必须标记为 <code>required</code> 声明修饰符。</p>
<p>另见 <a href="doc:Declarations#构造器声明">doc:Declarations#构造器声明</a>。</p>
<blockquote>
<p>协议构造器声明的语法:</p>
<p><em>protocol-initializer-declaration</em> → <em>initializer-head</em> <em>generic-parameter-clause</em><em>?</em> <em>parameter-clause</em> <em>throws-clause</em><em>?</em> <em>generic-where-clause</em><em>?</em> <br><em>protocol-initializer-declaration</em> → <em>initializer-head</em> <em>generic-parameter-clause</em><em>?</em> <em>parameter-clause</em> <strong><code>rethrows</code></strong> <em>generic-where-clause</em><em>?</em></p>
</blockquote>
<h3 id="协议下标声明"><a href="#协议下标声明" class="headerlink" title="协议下标声明"></a>协议下标声明</h3><p>协议声明遵循的类型必须通过在协议声明的主体中包含协议下标声明来实现下标。协议下标声明具有下标声明的特殊形式：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span> (<span class="operator">&lt;</span>#parameters#<span class="operator">&gt;</span>) -&gt; <span class="operator">&lt;</span>#return type#<span class="operator">&gt;</span> { <span class="keyword">get</span> <span class="keyword">set</span> }</span><br></pre></td></tr></tbody></table></figure>

<p>下标声明仅声明遵循协议的类型所需的最小 getter 和 setter 实现要求。如果下标声明同时包含 <code>get</code> 和 <code>set</code> 关键字，则遵循的类型必须实现 getter 和 setter 子句。如果下标声明仅包含 <code>get</code> 关键字，则遵循的类型必须实现<em>至少</em>一个 getter 子句，并且可以选择性地实现一个 setter 子句。</p>
<p>在协议声明中声明静态下标要求时，使用 <code>static</code> 声明修饰符标记下标声明。遵循该协议的结构体和枚举使用 <code>static</code> 关键字声明下标，而遵循该协议的类则使用 <code>static</code> 或 <code>class</code> 关键字声明下标。为结构体、枚举或类添加协议遵循性的扩展使用与其扩展的类型相同的关键字。为静态下标要求提供默认实现的扩展使用 <code>static</code> 关键字。</p>
<p>另见 <a href="doc:Declarations#下标声明">doc:Declarations#下标声明</a>。</p>
<blockquote>
<p>协议下标声明的语法:</p>
<p><em>protocol-subscript-declaration</em> → <em>subscript-head</em> <em>subscript-result</em> <em>generic-where-clause</em><em>?</em> <em>getter-setter-keyword-block</em></p>
</blockquote>
<h3 id="协议关联类型声明"><a href="#协议关联类型声明" class="headerlink" title="协议关联类型声明"></a>协议关联类型声明</h3><p>协议使用 <code>associatedtype</code> 关键字声明关联类型。关联类型为作为协议声明一部分使用的类型提供了别名。关联类型类似于泛型参数子句中的类型参数，但它们与声明它们的协议中的 <code>Self</code> 相关联。在该上下文中，<code>Self</code> 指的是遵循该协议的最终类型。有关更多信息和示例，请参见 <a href="doc:Generics#关联类型">doc:Generics#关联类型</a>。</p>
<p>你在协议声明中使用通用的 <code>where</code> 子句，以便为从另一个协议继承的关联类型添加约束，而无需重新声明关联类型。以下 <code>SubProtocol</code> 的声明是等效的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> {</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">SomeType</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">SubProtocolA</span>: <span class="title class_">SomeProtocol</span> {</span><br><span class="line">    <span class="comment">// 此语法会产生警告。</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">SomeType</span>: <span class="type">Equatable</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用此语法。</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">SubProtocolB</span>: <span class="title class_">SomeProtocol</span> <span class="title class_">where</span> <span class="title class_">SomeType</span>: <span class="title class_">Equatable</span> { }</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `protocol-associatedtype`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol SomeProtocol &#123;</span><br><span class="line">       associatedtype SomeType</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; protocol SubProtocolA: SomeProtocol &#123;</span><br><span class="line">       // This syntax produces a warning.</span><br><span class="line">       associatedtype SomeType: Equatable</span><br><span class="line">   &#125;</span><br><span class="line">!$ warning: redeclaration of associated type &#x27;SomeType&#x27; from protocol &#x27;SomeProtocol&#x27; is better expressed as a &#x27;where&#x27; clause on the protocol</span><br><span class="line">!! associatedtype SomeType: Equatable</span><br><span class="line">!! ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~</span><br><span class="line">!!-</span><br><span class="line">!$ note: &#x27;SomeType&#x27; declared here</span><br><span class="line">!! associatedtype SomeType</span><br><span class="line">!! ^</span><br><span class="line">---</span><br><span class="line">// This syntax is preferred.</span><br><span class="line">-&gt; protocol SubProtocolB: SomeProtocol where SomeType: Equatable &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  TODO: Finish writing this section after WWDC.
-->

<!--
  NOTE:
  What are associated types? What are they "associated" with? Is "Self"
  an implicit associated type of every protocol? [...]

  Here's an initial stab:
  An Associated Type is associated with an implementation of that protocol.
  The protocol declares it, and is defined as part of the protocol's implementation.

  "The ``Self`` type allows you to refer to the eventual type of ``self``
  (where ``self`` is the type that conforms to the protocol).
  In addition to ``Self``, a protocol's operations often need to refer to types
  that are related to the type of ``Self``, such as a type of data stored in a
  collection or the node and edge types of a graph." Is this still true?

    -> If we expand the discussion here,
    -> add a link from Types_SelfType
    -> to give more details about Self in protocols.

  NOTES from Doug:
  At one point, Self was an associated type, but that's the wrong modeling of
  the problem.  Self is the stand-in type for the thing that conforms to the
  protocol.  It's weird to think of it as an associated type because it's the
  primary thing.  It's certainly not an associated type.  In many ways, you
  can think of associated types as being parameters that get filled in by the
  conformance of a specific concrete type to that protocol.

  There's a substitution mapping here.  The parameters are associated with
  Self because they're derived from Self.  When you have a concrete type that
  conforms to a protocol, it supplies concrete types for Self and all the
  associated types.

  The associated types are like parameters, but they're associated with Self in
  the protocol.  Self is the eventual type of the thing that conforms to the
  protocol -- you have to have a name for it so you can do things with it.

  We use "associated" in contrast with generic parameters in interfaces in C#.
  The interesting thing there is that they don't have a name like Self for the
  actual type, but you can name any of these independent types.    In theory,
  they're often independent but in practice they're often not -- you have an
  interface parameterized on T, where all the uses of the thing are that T are
  the same as Self.  Instead of having these independent parameters to an
  interface, we have a named thing (Self) and all these other things that hand
  off of it.

  Here's a stupid simple way to see the distinction:

  C#:

  interface Sequence <Element> {}

  class String : Sequence <UnicodeScalar>
  class String : Sequence <GraphemeCluster>

  These are both fine in C#

  Swift:

  protocol Sequence { typealias Element }

  class String : Sequence { typealias Element = ... }

  Here you have to pick one or the other -- you can't have both.
-->

<p>另见 <a href="doc:Declarations#类型别名声明">doc:Declarations#类型别名声明</a>。</p>
<blockquote>
<p>协议关联类型声明的语法:</p>
<p><em>protocol-associated-type-declaration</em> → <em>attributes</em><em>?</em> <em>access-level-modifier</em><em>?</em> <strong><code>associatedtype</code></strong> <em>typealias-name</em> <em>type-inheritance-clause</em><em>?</em> <em>typealias-assignment</em><em>?</em> <em>generic-where-clause</em><em>?</em></p>
</blockquote>
<h2 id="构造器声明"><a href="#构造器声明" class="headerlink" title="构造器声明"></a>构造器声明</h2><p><em>构造器声明</em>在你的程序中引入了一个类、结构体或枚举的构造器。构造器声明使用 <code>init</code> 关键字声明，有两种基本形式。</p>
<p>结构体、枚举和类类型可以有任意数量的构造器，但是类的构造器具有不同的规则和行为。与结构体和枚举不同，类有两种类型的构造器：指定构造器和便利构造器，参见 <a href="doc:Initialization">doc:Initialization</a>。</p>
<p>以下形式声明了结构体和枚举的构造器，以及类的指定构造器：：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="operator">&lt;</span>#parameters#<span class="operator">&gt;</span>) {</span><br><span class="line">    <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>类的指定构造器直接初始化类的所有属性。它不能调用当前类的其他构造器，如果该类有一个超类，则必须调用超类的一个指定构造器。如果该类从其超类继承了任何属性，则在当前类中设置或修改这些属性之前，必须调用超类的一个指定构造器。</p>
<p>指定构造器只能在类声明中声明，因此不能通过扩展声明添加到类中。</p>
<p>结构体和枚举中的构造器可以调用其他已声明的构造器，以委托部分或全部初始化过程。</p>
<p>要为一个类声明便利构造器，请使用 <code>convenience</code> 声明修饰符标记构造器声明。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="operator">&lt;</span>#parameters#<span class="operator">&gt;</span>) {</span><br><span class="line">    <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>便利构造器可以将构造过程委托给另一个便利构造器或一个指定构造器。但是，类的构造过程必须以一个将类中所有属性完全初始化的指定构造器的调用作为结束。便利构造器不能调用超类的构造器</p>
<p>你可以使用 <code>required</code> 声明修饰符标记指定和便利构造器，以要求每个子类实现该构造器。子类对该构造器的实现也必须标记为 <code>required</code> 声明修饰符。</p>
<p>默认情况下，超类中声明的构造器不会被子类继承。也就是说，如果子类用默认值初始化了所有存储属性，并且没有定义自己的构造器，它将继承超类的所有构造器。如果子类重写了超类的所有指定构造器，它将继承超类的便利构造器。</p>
<p>与方法、属性和下标一样，你需要使用 <code>override</code> 声明修饰符标记重写的指定构造器。</p>
<blockquote>
<p>注意:<br>如果你使用 <code>required</code> 声明修饰符标记了一个构造器，则在子类中重写所需的构造器时，不要同时使用 <code>override</code> 修饰符标记该构造器。</p>
</blockquote>
<p>就像函数和方法一样，构造器可以抛出或再抛出错误。与函数和方法一样，你在构造器的参数后使用 <code>throws</code> 或 <code>rethrows</code> 关键字来指示适当的行为。同样，构造器可以是异步的，你使用 <code>async</code> 关键字来指示这一点。</p>
<p>要查看各种类型声明中构造器的示例，请参见 <a href="doc:Initialization">doc:Initialization</a>。</p>
<h3 id="可失败的构造器"><a href="#可失败的构造器" class="headerlink" title="可失败的构造器"></a>可失败的构造器</h3><p><em>可失败的构造器</em>是一种生成一个可选实例或一个隐式解包的可选实例的构造器，具体取决于构造器声明的类型。因此，可失败的构造器可以返回 <code>nil</code> 以表示初始化失败。</p>
<p>要声明一个可失败的构造器并生成一个可选实例，需要在构造器声明中的 <code>init</code> 关键字后面加上问号（<code>init?</code>）。要声明一个可失败构造器并生成一个隐式解包的可选实例，则需要加上感叹号（<code>init!</code>）。下面的示例展示了一个 <code>init?</code> 可失败的构造器，它生成了一个结构体的可选实例。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStruct</span> {</span><br><span class="line">    <span class="keyword">let</span> property: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 生成一个 `SomeStruct` 可选实例</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">input</span>: <span class="type">String</span>) {</span><br><span class="line">        <span class="keyword">if</span> input.isEmpty {</span><br><span class="line">            <span class="comment">// 丢弃 'self' 并返回 'nil'</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        }</span><br><span class="line">        property <span class="operator">=</span> input</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `failable`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-&gt; struct SomeStruct &#123;</span><br><span class="line">       let property: String</span><br><span class="line">       // produces an optional instance of &#x27;SomeStruct&#x27;</span><br><span class="line">       init?(input: String) &#123;</span><br><span class="line">           if input.isEmpty &#123;</span><br><span class="line">               // discard &#x27;self&#x27; and return &#x27;nil&#x27;</span><br><span class="line">               return nil</span><br><span class="line">           &#125;</span><br><span class="line">           property = input</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>调用 <code>init?</code> 可失败的构造器与调用不可失败的构造器的方式相同，只是你必须处理结果的可选性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualInstance <span class="operator">=</span> <span class="type">SomeStruct</span>(input: <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 &#x27;SomeStruct&#x27; 的实例执行操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// &#x27;SomeStruct&#x27; 的初始化失败，初始化器返回了 &#x27;nil&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `failable`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; if let actualInstance = SomeStruct(input: &quot;Hello&quot;) &#123;</span><br><span class="line">       // do something with the instance of &#x27;SomeStruct&#x27;</span><br><span class="line">&gt;&gt;     _ = actualInstance</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       // initialization of &#x27;SomeStruct&#x27; failed and the initializer returned &#x27;nil&#x27;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>可失败的构造器可以在构造器主体的实现中的任何时刻返回 <code>nil</code>。</p>
<p>可失败的构造器可以委托给任何类型的构造器。不可失败的构造器可以委托给另一个不可失败的构造器或一个 <code>init!</code> 可失败的构造器。不可失败的构造器可以通过强制解包超类构造器的结果来委托给一个 <code>init?</code> 可失败的构造器——例如，通过写 <code>super.init()!</code>。</p>
<p>初始化失败会通过构造器委托传播。具体来说，如果一个可失败的构造器委托给一个失败并返回 <code>nil</code> 的构造器，那么委托的构造器也会失败并隐式返回 <code>nil</code>。如果一个不可失败的构造器委托给一个失败并返回 <code>nil</code> 的 <code>init!</code> 可失败构造器，那么会引发运行时错误（就像你使用<code>!</code>运算符来解包一个值为 <code>nil</code>的可选值一样）。</p>
<p>可失败的指定构造器可以在子类中被任何类型的指定构造器重写。不可失败的指定构造器只能在子类中被不可失败的指定构造器重写。</p>
<p>有关更多信息以及可失败构造器的示例，请参见 <a href="doc:Initialization#可失败构造器">doc:Initialization#可失败构造器</a>。</p>
<blockquote>
<p>初始化声明的语法:</p>
<p><em>initializer-declaration</em> → <em>initializer-head</em> <em>generic-parameter-clause</em><em>?</em> <em>parameter-clause</em> <strong><code>async</code></strong><em>?</em> <em>throws-clause</em><em>?</em> <em>generic-where-clause</em><em>?</em> <em>initializer-body</em> <br><em>initializer-declaration</em> → <em>initializer-head</em> <em>generic-parameter-clause</em><em>?</em> <em>parameter-clause</em> <strong><code>async</code></strong><em>?</em> <strong><code>rethrows</code></strong> <em>generic-where-clause</em><em>?</em> <em>initializer-body</em> <br><em>initializer-head</em> → <em>attributes</em><em>?</em> <em>declaration-modifiers</em><em>?</em> <strong><code>init</code></strong> <br><em>initializer-head</em> → <em>attributes</em><em>?</em> <em>declaration-modifiers</em><em>?</em> <strong><code>init</code></strong> <strong><code>?</code></strong> <br><em>initializer-head</em> → <em>attributes</em><em>?</em> <em>declaration-modifiers</em><em>?</em> <strong><code>init</code></strong> <strong><code>!</code></strong> <br><em>initializer-body</em> → <em>code-block</em></p>
</blockquote>
<h2 id="析构器声明"><a href="#析构器声明" class="headerlink" title="析构器声明"></a>析构器声明</h2><p><em>析构器声明</em>为类类型声明一个析构器。析构器不接受参数，具有以下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构器在一个类对象不再有任何引用时，会在该对象被释放之前自动调用。析构器只能在类声明的主体内声明，不能在类的扩展中声明，并且每个类最多只能有一个析构器</p>
<p>子类继承其超类的析构器，该析构器在子类对象被释放之前隐式调用。子类对象在其继承链中的所有析构器执行完毕之前不会被释放。</p>
<p>析构器不会被直接调用。</p>
<p>在类声明中如何使用析构器的示例，请参见 <a href="doc:Deinitialization">doc:Deinitialization</a>。</p>
<blockquote>
<p>析构器声明的语法:</p>
<p><em>deinitializer-declaration</em> → <em>attributes</em><em>?</em> <strong><code>deinit</code></strong> <em>code-block</em></p>
</blockquote>
<h2 id="扩展声明"><a href="#扩展声明" class="headerlink" title="扩展声明"></a>扩展声明</h2><p><em>扩展声明</em>允许你扩展现有类型的行为。扩展声明使用 <code>extension</code> 关键字声明，具有以下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> &lt;#<span class="title class_">type</span> <span class="title class_">name</span>#&gt; <span class="title class_">where</span> &lt;#<span class="title class_">requirements</span>#&gt; &#123;</span><br><span class="line">    <span class="operator">&lt;</span>#declarations#<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展声明的主体包含零个或多个<em>声明</em>。这些<em>声明</em>可以包括计算属性、计算类型属性、实例方法、类型方法、构造器、下标声明，甚至类、结构体和枚举声明。扩展声明不能包含析构器或协议声明、存储属性、属性观察者或其他扩展声明。协议扩展中的声明不能标记为 <code>final</code>。有关包含各种类型声明的扩展的讨论和多个示例，请参见 <a href="doc:Extensions">doc:Extensions</a>。</p>
<p>如果<em>类型名称</em>是类、结构体或枚举类型，则扩展该类型。如果<em>类型名称</em>是协议类型，则扩展所有遵循该协议的类型。</p>
<p>扩展声明可以扩展具有关联类型的泛型类型或协议，并可以包含<em>要求</em>。如果扩展类型的实例或遵循扩展协议的类型的实例满足<em>要求</em>，则该实例获得声明中指定的行为。</p>
<p>扩展声明可以包含构造器声明。也就是说，如果你正在扩展的类型在另一个模块中定义，则构造器声明必须委托给该模块中已定义的构造器，以确保该类型的成员得到正确初始化。</p>
<p>现有类型的属性、方法和构造器不能在该类型的扩展中被重写。</p>
<p>扩展声明可以通过指定<em>采用的协议</em>，为现有的类、结构体或枚举类型添加协议遵循：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> &lt;#<span class="title class_">type</span> <span class="title class_">name</span>#&gt;: &lt;#<span class="title class_">adopted</span> <span class="title class_">protocols</span>#&gt; <span class="title class_">where</span> &lt;#<span class="title class_">requirements</span>#&gt; &#123;</span><br><span class="line">    <span class="operator">&lt;</span>#declarations#<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展声明不能为现有类添加类继承，因此你只能在<em>类型名称</em>和冒号后指定协议列表。</p>
<h3 id="条件遵循"><a href="#条件遵循" class="headerlink" title="条件遵循"></a>条件遵循</h3><p>你可以扩展一个泛型类型以有条件地遵循一个协议，从而使该类型的实例仅在满足某些要求时遵循该协议。你通过在扩展声明中包含<em>要求</em>来添加对协议的条件遵循。</p>
<h4 id="重写的要求在某些泛型上下文中不会被使用"><a href="#重写的要求在某些泛型上下文中不会被使用" class="headerlink" title="重写的要求在某些泛型上下文中不会被使用"></a>重写的要求在某些泛型上下文中不会被使用</h4><p>在某些泛型上下文中，通过条件遵循协议而获得行为的类型，并不总是使用该协议要求的特定实现。为了说明这种行为，以下示例定义了两个协议和一个有条件地遵循这两个协议的泛型类型。</p>
<!--
  This test needs to be compiled so that it will recognize Pair's
  CustomStringConvertible conformance -- the deprecated REPL doesn't
  seem to use the description property at all.
-->

<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Loggable</span> {</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">log</span>()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Loggable</span> {</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">log</span>() {</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">self</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">TitledLoggable</span>: <span class="title class_">Loggable</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> logTitle: <span class="type">String</span> { <span class="keyword">get</span> }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">TitledLoggable</span> {</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">log</span>() {</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(<span class="keyword">Self</span>.logTitle)</span>: <span class="subst">\(<span class="keyword">self</span>)</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">CustomStringConvertible</span> {</span><br><span class="line">    <span class="keyword">let</span> first: <span class="type">T</span></span><br><span class="line">    <span class="keyword">let</span> second: <span class="type">T</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(<span class="subst">\(first)</span>, <span class="subst">\(second)</span>)"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Pair</span>: <span class="title class_">Loggable</span> <span class="title class_">where</span> <span class="title class_">T</span>: <span class="title class_">Loggable</span> { }</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Pair</span>: <span class="title class_">TitledLoggable</span> <span class="title class_">where</span> <span class="title class_">T</span>: <span class="title class_">TitledLoggable</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> logTitle: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pair of '<span class="subst">\(T.logTitle)</span>'"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">String</span>: <span class="title class_">TitledLoggable</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> logTitle: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"String"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `conditional-conformance`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol Loggable &#123;</span><br><span class="line">       func log()</span><br><span class="line">   &#125;</span><br><span class="line">   extension Loggable &#123;</span><br><span class="line">       func log() &#123;</span><br><span class="line">           print(self)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">   protocol TitledLoggable: Loggable &#123;</span><br><span class="line">       static var logTitle: String &#123; get &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   extension TitledLoggable &#123;</span><br><span class="line">       func log() &#123;</span><br><span class="line">           print(&quot;\(Self.logTitle): \(self)&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">   struct Pair&lt;T&gt;: CustomStringConvertible &#123;</span><br><span class="line">       let first: T</span><br><span class="line">       let second: T</span><br><span class="line">       var description: String &#123;</span><br><span class="line">           return &quot;(\(first), \(second))&quot;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">   extension Pair: Loggable where T: Loggable &#123; &#125;</span><br><span class="line">   extension Pair: TitledLoggable where T: TitledLoggable &#123;</span><br><span class="line">       static var logTitle: String &#123;</span><br><span class="line">           return &quot;Pair of &#x27;\(T.logTitle)&#x27;&quot;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">   extension String: TitledLoggable &#123;</span><br><span class="line">      static var logTitle: String &#123;</span><br><span class="line">         return &quot;String&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>Pair</code> 结构体在其泛型类型分别遵循 <code>Loggable</code> 或 <code>TitledLoggable</code> 时，也会相应地遵循 <code>Loggable</code> 和 <code>TitledLoggable</code>。在下面的示例中，<code>oneAndTwo</code> 是 <code>Pair&lt;String&gt;</code> 的一个实例，由于 <code>String</code> 遵循 <code>TitledLoggable</code>，因此 <code>oneAndTwo</code> 也遵循 <code>TitledLoggable</code>。当直接调用 <code>oneAndTwo</code> 的 <code>log()</code> 方法时，将使用包含标题字符串的特定版本。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneAndTwo <span class="operator">=</span> <span class="type">Pair</span>(first: <span class="string">&quot;one&quot;</span>, second: <span class="string">&quot;two&quot;</span>)</span><br><span class="line">oneAndTwo.log()</span><br><span class="line"><span class="comment">// 打印 &quot;Pair of &#x27;String&#x27;: (one, two)&quot;</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `conditional-conformance`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let oneAndTwo = Pair(first: &quot;one&quot;, second: &quot;two&quot;)</span><br><span class="line">-&gt; oneAndTwo.log()</span><br><span class="line">&lt;- Pair of &#x27;String&#x27;: (one, two)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>然而，当在泛型上下文中使用 <code>oneAndTwo</code> 或将其作为 <code>Loggable</code> 协议的一个实例时，特定的实现版本不会被使用。Swift 在选择调用哪个 <code>log()</code> 实现时，只参考 <code>Pair</code> 遵循 <code>Loggable</code> 所需的最低要求。因此，使用的是 <code>Loggable</code> 协议提供的默认实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">doSomething</span>&lt;<span class="type">T</span>: <span class="type">Loggable</span>&gt;(<span class="params">with</span> <span class="params">x</span>: <span class="type">T</span>) &#123;</span><br><span class="line">    x.log()</span><br><span class="line">&#125;</span><br><span class="line">doSomething(with: oneAndTwo)</span><br><span class="line"><span class="comment">// 打印 &quot;(one, two)&quot;</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `conditional-conformance`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func doSomething&lt;T: Loggable&gt;(with x: T) &#123;</span><br><span class="line">      x.log()</span><br><span class="line">   &#125;</span><br><span class="line">   doSomething(with: oneAndTwo)</span><br><span class="line">&lt;- (one, two)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>当在传递给 <code>doSomething(_:)</code> 的实例上调用 <code>log()</code> 时，自定义标题会从日志字符串中省略。</p>
<h3 id="协议的遵循不应冗余"><a href="#协议的遵循不应冗余" class="headerlink" title="协议的遵循不应冗余"></a>协议的遵循不应冗余</h3><p>具体类型只能遵从某个协议一次。Swift 会将多余的协议遵从标记为错误。你可能会在两种情况下遇到这种错误。第一种情况是，当你以不同的要求多次显式地遵从同一个协议。第二种情况是，当你多次隐式地继承同一个协议。以下部分将讨论这些情况。</p>
<h4 id="解决显式冗余"><a href="#解决显式冗余" class="headerlink" title="解决显式冗余"></a>解决显式冗余</h4><p>对一个具体类型的多个扩展不能添加对同一协议的遵循，即使这些扩展的要求是互斥的。以下示例展示了这一限制。两个扩展声明试图为 <code>Serializable</code> 协议添加条件遵循，一个是针对包含 <code>Int</code> 元素的数组，另一个是针对包含 <code>String</code> 元素的数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">serialize</span>() -&gt; <span class="keyword">Any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">Serializable</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">serialize</span>() -&gt; <span class="keyword">Any</span> &#123;</span><br><span class="line">        <span class="comment">// 实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">Serializable</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">serialize</span>() -&gt; <span class="keyword">Any</span> &#123;</span><br><span class="line">        <span class="comment">// 实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误：&#x27;Array&lt;Element&gt;&#x27; 对协议 &#x27;Serializable&#x27; 的遵循是多余的</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `multiple-conformances`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol Serializable &#123;</span><br><span class="line">      func serialize() -&gt; Any</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">   extension Array: Serializable where Element == Int &#123;</span><br><span class="line">       func serialize() -&gt; Any &#123;</span><br><span class="line">           // implementation</span><br><span class="line">&gt;&gt;         return 0</span><br><span class="line">-&gt;     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   extension Array: Serializable where Element == String &#123;</span><br><span class="line">       func serialize() -&gt; Any &#123;</span><br><span class="line">           // implementation</span><br><span class="line">&gt;&gt;         return 0</span><br><span class="line">-&gt;     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">// Error: redundant conformance of &#x27;Array&lt;Element&gt;&#x27; to protocol &#x27;Serializable&#x27;</span><br><span class="line">!$ error: conflicting conformance of &#x27;Array&lt;Element&gt;&#x27; to protocol &#x27;Serializable&#x27;; there cannot be more than one conformance, even with different conditional bounds</span><br><span class="line">!! extension Array: Serializable where Element == String &#123;</span><br><span class="line">!! ^</span><br><span class="line">!$ note: &#x27;Array&lt;Element&gt;&#x27; declares conformance to protocol &#x27;Serializable&#x27; here</span><br><span class="line">!! extension Array: Serializable where Element == Int &#123;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>如果你需要根据多个具体类型添加条件遵循，请创建一个每个类型都可以遵循的新协议，并在声明条件遵循时使用该协议作为要求。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SerializableInArray</span> &#123; &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span>: <span class="title class_">SerializableInArray</span> &#123; &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">String</span>: <span class="title class_">SerializableInArray</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">Serializable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">SerializableInArray</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">serialize</span>() -&gt; <span class="keyword">Any</span> &#123;</span><br><span class="line">        <span class="comment">// 实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `multiple-conformances-success`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; protocol Serializable &#123; &#125;</span><br><span class="line">-&gt; protocol SerializableInArray &#123; &#125;</span><br><span class="line">   extension Int: SerializableInArray &#123; &#125;</span><br><span class="line">   extension String: SerializableInArray &#123; &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; extension Array: Serializable where Element: SerializableInArray &#123;</span><br><span class="line">       func serialize() -&gt; Any &#123;</span><br><span class="line">           // implementation</span><br><span class="line">&gt;&gt;         return 0</span><br><span class="line">-&gt;     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h4 id="解决隐式冗余"><a href="#解决隐式冗余" class="headerlink" title="解决隐式冗余"></a>解决隐式冗余</h4><p>当一个具体类型有条件地遵循一个协议时，该类型隐式地遵循任何具有相同要求的父协议。</p>
<p>如果你需要一个类型有条件地遵循两个继承自单一父协议的协议，请显式声明对父协议的遵循。这可以避免以不同的要求隐式地两次遵循父协议。</p>
<p>以下示例显式声明了 <code>Array</code> 对 <code>Loggable</code> 的条件遵循，以避免在声明其对 <code>TitledLoggable</code> 和新的 <code>MarkedLoggable</code> 协议的条件遵循时发生冲突。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">MarkedLoggable</span>: <span class="title class_">Loggable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">markAndLog</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">MarkedLoggable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">markAndLog</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line">        log()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">Loggable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Loggable</span> &#123; &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">TitledLoggable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">TitledLoggable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> logTitle: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Array of &#x27;<span class="subst">\(Element.logTitle)</span>&#x27;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">MarkedLoggable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">MarkedLoggable</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `conditional-conformance`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol MarkedLoggable: Loggable &#123;</span><br><span class="line">      func markAndLog()</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">   extension MarkedLoggable &#123;</span><br><span class="line">      func markAndLog() &#123;</span><br><span class="line">         print(&quot;----------&quot;)</span><br><span class="line">         log()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">   extension Array: Loggable where Element: Loggable &#123; &#125;</span><br><span class="line">   extension Array: TitledLoggable where Element: TitledLoggable &#123;</span><br><span class="line">      static var logTitle: String &#123;</span><br><span class="line">         return &quot;Array of &#x27;\(Element.logTitle)&#x27;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   extension Array: MarkedLoggable where Element: MarkedLoggable &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>在没有扩展显式声明对 <code>Loggable</code> 的条件遵循时，其他 <code>Array</code> 扩展会隐式创建这些声明，从而导致错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">Loggable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">TitledLoggable</span> &#123; &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">Loggable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">MarkedLoggable</span> &#123; &#125;</span><br><span class="line"><span class="comment">// 错误：&#x27;Array&lt;Element&gt;&#x27; 对协议 &#x27;Loggable&#x27; 的遵循是多余的</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `conditional-conformance-implicit-overlap`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; protocol Loggable &#123; &#125;</span><br><span class="line">&gt;&gt; protocol MarkedLoggable : Loggable &#123; &#125;</span><br><span class="line">&gt;&gt; protocol TitledLoggable : Loggable &#123; &#125;</span><br><span class="line">-&gt; extension Array: Loggable where Element: TitledLoggable &#123; &#125;</span><br><span class="line">   extension Array: Loggable where Element: MarkedLoggable &#123; &#125;</span><br><span class="line">// Error: redundant conformance of &#x27;Array&lt;Element&gt;&#x27; to protocol &#x27;Loggable&#x27;</span><br><span class="line">!$ error: conflicting conformance of &#x27;Array&lt;Element&gt;&#x27; to protocol &#x27;Loggable&#x27;; there cannot be more than one conformance, even with different conditional bounds</span><br><span class="line">!! extension Array: Loggable where Element: MarkedLoggable &#123; &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ note: &#x27;Array&lt;Element&gt;&#x27; declares conformance to protocol &#x27;Loggable&#x27; here</span><br><span class="line">!! extension Array: Loggable where Element: TitledLoggable &#123; &#125;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `types-cant-have-multiple-implicit-conformances`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; protocol Loggable &#123; &#125;</span><br><span class="line">   protocol TitledLoggable: Loggable &#123; &#125;</span><br><span class="line">   protocol MarkedLoggable: Loggable &#123; &#125;</span><br><span class="line">   extension Array: TitledLoggable where Element: TitledLoggable &#123;</span><br><span class="line">       // ...</span><br><span class="line">   &#125;</span><br><span class="line">   extension Array: MarkedLoggable where Element: MarkedLoggable &#123; &#125;</span><br><span class="line">!$ error: conditional conformance of type &#x27;Array&lt;Element&gt;&#x27; to protocol &#x27;TitledLoggable&#x27; does not imply conformance to inherited protocol &#x27;Loggable&#x27;</span><br><span class="line">!! extension Array: TitledLoggable where Element: TitledLoggable &#123;</span><br><span class="line">!! ^</span><br><span class="line">!$ note: did you mean to explicitly state the conformance like &#x27;extension Array: Loggable where ...&#x27;?</span><br><span class="line">!! extension Array: TitledLoggable where Element: TitledLoggable &#123;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: type &#x27;Array&lt;Element&gt;&#x27; does not conform to protocol &#x27;MarkedLoggable&#x27;</span><br><span class="line">!! extension Array: MarkedLoggable where Element: MarkedLoggable &#123; &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: type &#x27;Element&#x27; does not conform to protocol &#x27;TitledLoggable&#x27;</span><br><span class="line">!! extension Array: MarkedLoggable where Element: MarkedLoggable &#123; &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: &#x27;MarkedLoggable&#x27; requires that &#x27;Element&#x27; conform to &#x27;TitledLoggable&#x27;</span><br><span class="line">!! extension Array: MarkedLoggable where Element: MarkedLoggable &#123; &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ note: requirement specified as &#x27;Element&#x27; : &#x27;TitledLoggable&#x27;</span><br><span class="line">!! extension Array: MarkedLoggable where Element: MarkedLoggable &#123; &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ note: requirement from conditional conformance of &#x27;Array&lt;Element&gt;&#x27; to &#x27;Loggable&#x27;</span><br><span class="line">!! extension Array: MarkedLoggable where Element: MarkedLoggable &#123; &#125;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `extension-can-have-where-clause`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; extension Array where Element: Equatable &#123;</span><br><span class="line">       func f(x: Array) -&gt; Int &#123; return 7 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&gt; let x = [1, 2, 3]</span><br><span class="line">&gt;&gt; let y = [10, 20, 30]</span><br><span class="line">&gt;&gt; let r0 = x.f(x: y)</span><br><span class="line">&gt;&gt; assert(r0 == 7)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `extensions-can-have-where-clause-and-inheritance-together`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; protocol P &#123; func foo() -&gt; Int &#125;</span><br><span class="line">&gt;&gt; extension Array: P where Element: Equatable &#123;</span><br><span class="line">&gt;&gt;    func foo() -&gt; Int &#123; return 0 &#125;</span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line">&gt;&gt; let r0 = [1, 2, 3].foo()</span><br><span class="line">&gt;&gt; assert(r0 == 0)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<blockquote>
<p>扩展声明的语法:</p>
<p><em>extension-declaration</em> → <em>attributes</em><em>?</em> <em>access-level-modifier</em><em>?</em> <strong><code>extension</code></strong> <em>type-identifier</em> <em>type-inheritance-clause</em><em>?</em> <em>generic-where-clause</em><em>?</em> <em>extension-body</em> <br><em>extension-body</em> → <strong><code>&#123;</code></strong> <em>extension-members</em><em>?</em> <strong><code>&#125;</code></strong></p>
<p><em>extension-members</em> → <em>extension-member</em> <em>extension-members</em><em>?</em> <br><em>extension-member</em> → <em>declaration</em> | <em>compiler-control-statement</em></p>
</blockquote>
<h2 id="下标声明"><a href="#下标声明" class="headerlink" title="下标声明"></a>下标声明</h2><p><em>下标</em>声明允许你为特定类型的对象添加下标支持，通常用于提供一种方便的语法来访问集合、列表或序列中的元素。下标声明使用 <code>subscript</code> 关键字声明，具有以下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span> (<span class="operator">&lt;</span>#parameters#<span class="operator">&gt;</span>) -&gt; <span class="operator">&lt;</span>#return type#<span class="operator">&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(<span class="operator">&lt;</span>#setter name#<span class="operator">&gt;</span>) &#123;</span><br><span class="line">        <span class="operator">&lt;</span>#statements#<span class="operator">&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下标声明只能出现在类、结构体、枚举、扩展或协议声明的上下文中。</p>
<p><em>参数</em>指定了在下标表达式中用于访问对应类型元素的一个或多个索引（例如，在表达式 <code>object[i]</code> 中的 <code>i</code>）。尽管用于访问元素的索引可以是任意类型，但每个参数都必须包含一个类型注释，以指定每个索引的类型。<em>返回类型</em>指定了被访问元素的类型。</p>
<p>与计算属性一样，下标声明支持读取和写入所访问元素的值。getter 用于读取值，setter 用于写入值。setter 子句是可选的，当只需要 getter 时，可以省略两个子句，直接返回请求的值。也就是说，如果提供了 setter 子句，则必须同时提供 getter 子句。</p>
<p><em>setter 名称</em>和括号是可选的。如果你提供了 setter 名称，它将用作 setter 的参数名称。如果你不提供 setter 名称，setter 的默认参数名称是 <code>value</code>。setter 的参数类型与<em>返回类型</em>相同。</p>
<p>你可以在声明其类型的地方重载下标声明，只要<em>参数</em>或<em>返回类型</em>与要重载的下标不同。你也可以重写从超类继承的下标声明。在这样做时，必须使用 <code>override</code> 声明修饰符标记被重写的下标声明。</p>
<p>下标参数遵循与函数参数相同的规则，但有两个例外。默认情况下，使用下标的参数没有参数标签，这与函数、方法和构造器不同。然而，你可以使用与函数、方法和构造器相同的语法提供显式参数标签。此外，下标不能有 in-out 参数。下标参数可以具有默认值，参见 <a href="doc:Declarations#特殊类型的参数">doc:Declarations#特殊类型的参数</a>。</p>
<p>你还可以在协议声明的上下文中声明下标，参见 <a href="doc:Declarations#协议下标声明">doc:Declarations#协议下标声明</a>。</p>
<p>有关下标的更多信息以及下标声明的示例，请参见 <a href="doc:Subscripts">doc:Subscripts</a>。</p>
<h3 id="类型下标声明"><a href="#类型下标声明" class="headerlink" title="类型下标声明"></a>类型下标声明</h3><p>要声明由类型本身而非类型实例公开的下标，可以在下标声明中使用 <code>static</code> 声明修饰符。类可以使用 <code>class</code> 声明修饰符来标记类型计算属性，以允许子类重写超类的实现。在类声明中，<code>static</code> 关键字的效果与将声明标记为 <code>class</code> 和 <code>final</code> 声明修饰符相同。</p>
<!--
  - test: `cant-override-static-subscript-in-subclass`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt; class Super &#123; static subscript(i: Int) -&gt; Int &#123; return 10 &#125; &#125;</span><br><span class="line">-&gt; class Sub: Super &#123; override static subscript(i: Int) -&gt; Int &#123; return 100 &#125; &#125;</span><br><span class="line">!$ error: cannot override static subscript</span><br><span class="line">!! class Sub: Super &#123; override static subscript(i: Int) -&gt; Int &#123; return 100 &#125; &#125;</span><br><span class="line">!!                                    ^</span><br><span class="line">!$ note: overridden declaration is here</span><br><span class="line">!! class Super &#123; static subscript(i: Int) -&gt; Int &#123; return 10 &#125; &#125;</span><br><span class="line">!!                      ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<blockquote>
<p>下标声明的语法:</p>
<p><em>subscript-declaration</em> → <em>subscript-head</em> <em>subscript-result</em> <em>generic-where-clause</em><em>?</em> <em>code-block</em> <br><em>subscript-declaration</em> → <em>subscript-head</em> <em>subscript-result</em> <em>generic-where-clause</em><em>?</em> <em>getter-setter-block</em> <br><em>subscript-declaration</em> → <em>subscript-head</em> <em>subscript-result</em> <em>generic-where-clause</em><em>?</em> <em>getter-setter-keyword-block</em> <br><em>subscript-head</em> → <em>attributes</em><em>?</em> <em>declaration-modifiers</em><em>?</em> <strong><code>subscript</code></strong> <em>generic-parameter-clause</em><em>?</em> <em>parameter-clause</em> <br><em>subscript-result</em> → <strong><code>-&gt;</code></strong> <em>attributes</em><em>?</em> <em>type</em></p>
</blockquote>
<h2 id="宏声明"><a href="#宏声明" class="headerlink" title="宏声明"></a>宏声明</h2><p><em>宏声明</em>引入一个新的宏。它以 <code>macro</code> 关键字开始，具有以下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macro <span class="operator">&lt;</span>#name#<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>#macro implementation#<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>宏实现</em>是另一个宏，用于指示执行此宏扩展的代码位置。执行宏扩展的代码是一个独立的 Swift 程序，该程序使用 <a target="_blank" rel="noopener" href="http://github.com/apple/swift-syntax/">SwiftSyntax</a> 模块与 Swift 代码进行交互。调用 Swift 标准库中的 <code>externalMacro(module:type:)</code> 宏，并传入包含宏实现的类型名称以及包含该类型的模块名称。</p>
<p>宏可以被重载，遵循与函数相同的模型。宏声明仅在文件作用域内出现。</p>
<p>有关 Swift 中宏的概述，请参见 <a href="doc:Macros">doc:Macros</a>。</p>
<blockquote>
<p>宏声明的语法:</p>
<p><em>macro-declaration</em> → <em>macro-head</em> <em>identifier</em> <em>generic-parameter-clause</em><em>?</em> <em>macro-signature</em> <em>macro-definition</em><em>?</em> <em>generic-where-clause</em> <br><em>macro-head</em> → <em>attributes</em><em>?</em> <em>declaration-modifiers</em><em>?</em> <strong><code>macro</code></strong> <br><em>macro-signature</em> → <em>parameter-clause</em> <em>macro-function-signature-result</em><em>?</em> <br><em>macro-function-signature-result</em> → <strong><code>-&gt;</code></strong> <em>type</em> <br><em>macro-definition</em> → <strong><code>=</code></strong> <em>expression</em></p>
</blockquote>
<h2 id="运算符声明"><a href="#运算符声明" class="headerlink" title="运算符声明"></a>运算符声明</h2><p><em>运算符声明</em>将新的中缀、前缀或后缀运算符引入到你的程序中，并使用 <code>operator</code> 关键字进行声明。</p>
<p>你可以声明三种不同优先级的运算符：中缀、前缀和后缀。运算符的<em>优先级</em>指定了运算符相对于其操作数的相对位置。</p>
<p>运算符声明有三种基本形式，每种形式对应一种结合性。运算符的结合性通过在 <code>operator</code> 关键字之前标注 <code>infix</code>、<code>prefix</code> 或 <code>postfix</code> 声明修饰符来指定。在每种形式中，运算符的名称只能包含 <a href="doc:LexicalStructure#运算符">doc:LexicalStructure#运算符</a> 中定义的运算符字符。</p>
<p>以下形式声明了一个新的中缀运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">&lt;</span>#operator name#<span class="operator">&gt;</span>: <span class="operator">&lt;</span>#precedence group#<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>中缀运算符</em>是一个二元运算符，它写在两个操作数之间，例如在表达式 <code>1 + 2</code> 中熟悉的加法运算符<code>+</code>。</p>
<p>中缀运算符可以选择性地指定优先级组。如果你省略运算符的优先级组，Swift 将使用默认优先级组 <code>DefaultPrecedence</code>，该组的优先级仅高于 <code>TernaryPrecedence</code>。有关更多信息，请参见 <a href="doc:Declarations#优先级组声明">doc:Declarations#优先级组声明</a>。</p>
<p>以下形式声明了一个新的前缀运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> <span class="title">&lt;</span>#operator name#<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>前缀运算符</em>是一种一元运算符，它直接写在操作数之前，例如表达式 <code>!a</code> 中的前缀逻辑非运算符（<code>!</code>）。</p>
<p>前缀运算符声明不指定优先级。前缀运算符是非结合的。</p>
<p>以下形式声明了一个新的后缀运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">postfix</span> <span class="keyword">operator</span> <span class="title">&lt;</span>#operator name#<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>后缀运算符</em>是一种一元运算符，它紧跟在操作数后面，例如在表达式 <code>a!</code> 中的后缀强制解包运算符 <code>!</code>。</p>
<p>与前缀运算符一样，后缀运算符声明不指定优先级。后缀运算符是非结合的。</p>
<p>在声明一个新运算符后，你通过声明一个与运算符同名的静态方法来实现它。这个静态方法是运算符作为参数所接受的类型之一的成员——例如，一个将 <code>Double</code> 乘以 <code>Int</code> 的运算符是作为 <code>Double</code> 或 <code>Int</code> 结构上的静态方法实现的。如果你在实现前缀或后缀运算符，你还必须在方法声明中标记相应的 <code>prefix</code> 或 <code>postfix</code> 声明修饰符。要查看如何创建和实现新运算符的示例，请参见 <a href="doc:AdvancedOperators#自定义运算符">doc:AdvancedOperators#自定义运算符</a>。</p>
<blockquote>
<p>操作符声明的语法:</p>
<p><em>operator-declaration</em> → <em>prefix-operator-declaration</em> | <em>postfix-operator-declaration</em> | <em>infix-operator-declaration</em></p>
<p><em>prefix-operator-declaration</em> → <strong><code>prefix</code></strong> <strong><code>operator</code></strong> <em>operator</em> <br><em>postfix-operator-declaration</em> → <strong><code>postfix</code></strong> <strong><code>operator</code></strong> <em>operator</em> <br><em>infix-operator-declaration</em> → <strong><code>infix</code></strong> <strong><code>operator</code></strong> <em>operator</em> <em>infix-operator-group</em><em>?</em></p>
<p><em>infix-operator-group</em> → <strong><code>:</code></strong> <em>precedence-group-name</em></p>
</blockquote>
<h2 id="优先级组声明"><a href="#优先级组声明" class="headerlink" title="优先级组声明"></a>优先级组声明</h2><p><em>优先级组声明</em>在程序中引入了一个新的中缀运算符优先级分组。运算符的优先级指定了在没有分组括号的情况下，运算符与其操作数的绑定紧密程度。</p>
<p>优先级组声明具有以下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precedencegroup</span> <span class="operator">&lt;</span>#precedence group name#<span class="operator">&gt;</span> &#123;</span><br><span class="line">    higherThan: <span class="operator">&lt;</span>#lower group names#<span class="operator">&gt;</span></span><br><span class="line">    lowerThan: <span class="operator">&lt;</span>#higher group names#<span class="operator">&gt;</span></span><br><span class="line">    associativity: <span class="operator">&lt;</span>#associativity#<span class="operator">&gt;</span></span><br><span class="line">    assignment: <span class="operator">&lt;</span>#assignment#<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>低级组名称</em>和<em>高级组名称</em>列表指定了新优先级组与现有优先级组的关系。<code>lowerThan</code> 优先级组属性只能用于引用当前模块外声明的优先级组。当两个运算符争夺其操作数时，如在表达式 <code>2 + 3 * 5</code> 中，具有较高相对优先级的运算符会更紧密地绑定到其操作数上。</p>
<blockquote>
<p>注意:<br>使用<em>低级组名称</em>和<em>高级组名称</em>相关联的优先级组必须适合于单一的关系层次结构，但它们<em>不</em>必形成线性层次结构。这意味着可以有相对优先级未定义的优先级组。来自这些优先级组的运算符不能在没有分组括号的情况下相互使用。</p>
</blockquote>
<p>Swift 定义了许多优先级组，以配合 Swift 标准库提供的运算符。例如，加法 (<code>+</code>) 和减法 (<code>-</code>) 运算符属于 <code>AdditionPrecedence</code> 组，而乘法 (<code>*</code>) 和除法 (<code>/</code>) 运算符属于 <code>MultiplicationPrecedence</code> 组。有关 Swift 标准库提供的优先级组的完整列表，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/operator_declarations">运算符声明</a>。</p>
<p>运算符的<em>结合性</em>指定了在没有分组括号的情况下，具有相同优先级的运算符序列是如何分组的。通过写入上下文敏感的关键字之一来指定运算符的结合性：<code>left</code>、<code>right</code> 或 <code>none</code> ——如果你省略结合性，默认值为 <code>none</code>。左结合的运算符从左到右分组。例如，减法运算符（<code>-</code>）是左结合的，因此表达式<code>4 - 5 - 6</code> 被分组为 <code>(4 - 5) - 6</code>，并计算为 <code>-7</code>。右结合的运算符从右到左分组，而指定为 <code>none</code> 的运算符则完全不结合。相同优先级的非结合运算符不能相邻出现。例如，<code>&lt;</code> 运算符的结合性为 <code>none</code>，这意味着 <code>1 &lt; 2 &lt; 3</code> 不是一个有效的表达式。</p>
<p><em>赋值</em>优先级组的设置指定了运算符在包含可选链操作中的优先级。当设置为 <code>true</code> 时，对应优先级组中的运算符在可选链操作期间使用与 Swift 标准库中的赋值运算符相同的分组规则。否则，当设置为 <code>false</code> 或省略时，该优先级组中的运算符将遵循与不执行赋值的运算符相同的可选链规则。</p>
<blockquote>
<p>优先级组声明的语法:</p>
<p><em>precedence-group-declaration</em> → <strong><code>precedencegroup</code></strong> <em>precedence-group-name</em> <strong><code>&#123;</code></strong> <em>precedence-group-attributes</em><em>?</em> <strong><code>&#125;</code></strong></p>
<p><em>precedence-group-attributes</em> → <em>precedence-group-attribute</em> <em>precedence-group-attributes</em><em>?</em> <br><em>precedence-group-attribute</em> → <em>precedence-group-relation</em> <br><em>precedence-group-attribute</em> → <em>precedence-group-assignment</em> <br><em>precedence-group-attribute</em> → <em>precedence-group-associativity</em></p>
<p><em>precedence-group-relation</em> → <strong><code>higherThan</code></strong> <strong><code>:</code></strong> <em>precedence-group-names</em> <br><em>precedence-group-relation</em> → <strong><code>lowerThan</code></strong> <strong><code>:</code></strong> <em>precedence-group-names</em></p>
<p><em>precedence-group-assignment</em> → <strong><code>assignment</code></strong> <strong><code>:</code></strong> <em>boolean-literal</em></p>
<p><em>precedence-group-associativity</em> → <strong><code>associativity</code></strong> <strong><code>:</code></strong> <strong><code>left</code></strong> <br><em>precedence-group-associativity</em> → <strong><code>associativity</code></strong> <strong><code>:</code></strong> <strong><code>right</code></strong> <br><em>precedence-group-associativity</em> → <strong><code>associativity</code></strong> <strong><code>:</code></strong> <strong><code>none</code></strong></p>
<p><em>precedence-group-names</em> → <em>precedence-group-name</em> | <em>precedence-group-name</em> <strong><code>,</code></strong> <em>precedence-group-names</em> <br><em>precedence-group-name</em> → <em>identifier</em></p>
</blockquote>
<h2 id="声明修饰符"><a href="#声明修饰符" class="headerlink" title="声明修饰符"></a>声明修饰符</h2><p><em>声明修饰符</em> 是用于修改声明行为或意义的关键字或上下文相关关键字。你通过在声明的属性（如果有的话）和引入声明的关键字之间写入相应的关键字或上下文相关关键字来指定声明修饰符。</p>
<ul>
<li><p><code>class</code>：将此修饰符应用于类的成员，以指示该成员是类本身的成员，而不是类实例的成员。具有此修饰符且没有 <code>final</code> 修饰符的超类成员可以被子类重写。</p>
</li>
<li><p><code>dynamic</code>：将此修饰符应用于可以用 Objective-C 表示的类的任何成员。当你使用 <code>dynamic</code> 修饰符标记成员声明时，对该成员的访问始终通过 Objective-C 运行时动态分派。对该成员的访问永远不会被编译器内联或去虚拟化。</p>
</li>
</ul>
<p>因为带有 <code>dynamic</code> 修饰符的声明是通过 Objective-C 运行时进行调度的，因此它们必须标记为 <code>objc</code> 属性。</p>
<ul>
<li><p><code>final</code>：将此修饰符应用于类或类的属性、方法或下标成员。它应用于类以指示该类不能被子类化。它应用于类的属性、方法或下标，以指示类成员在任何子类中不能被重写。有关如何使用 <code>final</code> 属性的示例，请参见 <a href="doc:Inheritance#防止重写">doc:Inheritance#防止重写</a>。</p>
</li>
<li><p><code>lazy</code>：将此修饰符应用于类或结构体的存储变量属性，以指示该属性的初始值在第一次访问该属性时最多计算并存储一次。有关如何使用 <code>lazy</code> 修饰符的示例，请参见 <a href="doc:Properties#延时加载存储属性">doc:Properties#延时加载存储属性</a>。</p>
</li>
<li><p><code>optional</code>：将此修饰符应用于协议的属性、方法或下标成员，表示实现该协议的类型不必实现这些成员。</p>
</li>
</ul>
<p>你只能将 <code>optional</code> 修饰符应用于带有 <code>objc</code> 属性的协议。因此，只有类类型可以采用并遵循包含可选成员要求的协议。有关如何使用 <code>optional</code> 修饰符的更多信息，以及在不确定遵循类型是否实现了这些成员时如何访问可选协议成员的指导，请参见 <a href="doc:Protocols#可选协议要求">doc:Protocols#可选协议要求</a>。</p>
<!--
  TODO: Currently, you can't check for an optional initializer,
  so we're leaving those out of the documentation, even though you can mark
  an initializer with the @optional attribute. It's still being decided by the
  compiler team. Update this section if they decide to make everything work
  properly for optional initializer requirements.
-->

<ul>
<li><p><code>required</code>：将此修饰符应用于类的指定或便利构造器，以指示每个子类必须实现该构造器。子类对该构造器的实现也必须标记为 <code>required</code> 修饰符。</p>
</li>
<li><p><code>static</code>：将此修饰符应用于结构体、类、枚举或协议的成员，以指示该成员属于类型本身，而不是该类型实例的成员。在类声明的作用域内，将 <code>static</code> 修饰符应用于成员声明上，与在该成员声明上写 <code>class</code> 和 <code>final</code> 修饰符具有相同的效果。然而，类的常量类型属性是一个例外：在这种情况下，<code>static</code> 具有其通常的、非类相关的含义，因为在这些声明上不能使用 <code>class</code> 或 <code>final</code>。</p>
</li>
<li><p><code>unowned</code>：将此修饰符应用于存储变量、常量或存储属性，以指示该变量或属性对作为其值存储的对象具有一个无主引用。如果在对象被释放后尝试访问该变量或属性，将会引发运行时错误。与弱引用类似，属性或值的类型必须是类类型；与弱引用不同，类型是非可选的。有关 <code>unowned</code> 修饰符的示例和更多信息，请参见 <a href="doc:AutomaticReferenceCounting#无主引用">doc:AutomaticReferenceCounting#无主引用</a>。</p>
</li>
<li><p><code>unowned(safe)</code>：<code>unowned</code> 的显式拼写。</p>
</li>
<li><p><code>unowned(unsafe)</code>：将此修饰符应用于存储变量、常量或存储属性，以指示该变量或属性对作为其值存储的对象具有一个无主引用。如果在对象被释放后尝试访问该变量或属性，你将访问对象曾经所在位置的内存，这是一种不安全的内存操作。与弱引用类似，属性或值的类型必须是类类型；与弱引用不同，该类型是非可选的。有关 <code>unowned</code> 修饰符的示例和更多信息，请参见 <a href="doc:AutomaticReferenceCounting#无主引用">doc:AutomaticReferenceCounting#无主引用</a>。</p>
</li>
<li><p><code>weak</code>：将此修饰符应用于存储变量或存储变量属性，以指示该变量或属性对作为其值存储的对象具有弱引用。变量或属性的类型必须是可选类类型。如果在对象被释放后访问该变量或属性，其值为 <code>nil</code>。有关 <code>weak</code> 修饰符的示例和更多信息，请参见 <a href="doc:AutomaticReferenceCounting#弱引用">doc:AutomaticReferenceCounting#弱引用</a>。</p>
</li>
</ul>
<h3 id="访问控制级别"><a href="#访问控制级别" class="headerlink" title="访问控制级别"></a>访问控制级别</h3><p>Swift 提供五种访问控制级别：open、public、internal、file private 和 private。你可以使用以下访问级别修饰符之一标记声明，以指定声明的访问级别。访问控制的详细信息请参见 <a href="doc:AccessControl">doc:AccessControl</a>。</p>
<ul>
<li><p><code>open</code>：将此修饰符应用于声明，以指示该声明可以被与该声明位于同一模块中的代码访问和子类化。标记为 <code>open</code> 访问级别修饰符的声明也可以被导入包含该声明的模块的模块中的代码访问和子类化。</p>
</li>
<li><p><code>public</code>：将此修饰符应用于声明，以指示该声明可以被与该声明位于同一模块中的代码访问和子类化。标记为 <code>public</code> 访问级别修饰符的声明也可以被导入包含该声明的模块的模块中的代码访问（但不能被子类化）。</p>
</li>
<li><p><code>package</code>：将此修饰符应用于声明，以指示该声明只能被与声明在同一包中的代码访问。包是你在使用的构建系统中定义的代码分发单元。当构建系统编译代码时，它通过将 <code>-package-name</code> 标志传递给 Swift 编译器来指定包名称。如果构建系统在构建它们时指定相同的包名称，则两个模块属于同一个包。</p>
</li>
<li><p><code>internal</code>：将此修饰符应用于声明，以指示该声明只能被与声明在同一模块中的代码访问。默认情况下，大多数声明隐式标记为 <code>internal</code> 访问级别修饰符。</p>
</li>
<li><p><code>fileprivate</code>：将此修饰符应用于声明，以指示该声明只能被与声明在同一源文件中的代码访问。</p>
</li>
<li><p><code>private</code>：将此修饰符应用于声明，以指示该声明只能被声明的直接封闭作用域内的代码访问。</p>
</li>
</ul>
<p>出于访问控制的目的，扩展的行为如下：</p>
<ul>
<li><p>如果同一个文件中有多个扩展，并且这些扩展都扩展了相同的类型，那么所有这些扩展具有相同的访问控制作用域。这些扩展和它们扩展的类型可以在不同的文件中。</p>
</li>
<li><p>如果扩展与其扩展的类型在同一文件中，则扩展具有与其扩展的类型相同的访问控制作用域。</p>
</li>
<li><p>在类型声明中声明的私有成员可以从该类型的扩展中访问。在一个扩展中声明的私有成员可以从其他扩展和扩展类型的声明中访问。</p>
</li>
</ul>
<p>每个上述访问级别修饰符可选择性地接受一个参数，该参数由括号中包含的 <code>set</code> 关键字组成——例如，<code>private(set)</code>。当你想要为变量或下标的setter指定一个小于或等于变量或下标本身的访问级别时，请使用这种形式的访问级别修饰符，如 <a href="doc:AccessControl#Getters-和-Setters">doc:AccessControl#Getters-和-Setters</a> 中所讨论的。</p>
<blockquote>
<p>声明修饰语的语法:</p>
<p><em>declaration-modifier</em> → <strong><code>class</code></strong> | <strong><code>convenience</code></strong> | <strong><code>dynamic</code></strong> | <strong><code>final</code></strong> | <strong><code>infix</code></strong> | <strong><code>lazy</code></strong> | <strong><code>optional</code></strong> | <strong><code>override</code></strong> | <strong><code>postfix</code></strong> | <strong><code>prefix</code></strong> | <strong><code>required</code></strong> | <strong><code>static</code></strong> | <strong><code>unowned</code></strong> | <strong><code>unowned</code></strong> <strong><code>(</code></strong> <strong><code>safe</code></strong> <strong><code>)</code></strong> | <strong><code>unowned</code></strong> <strong><code>(</code></strong> <strong><code>unsafe</code></strong> <strong><code>)</code></strong> | <strong><code>weak</code></strong> <br><em>declaration-modifier</em> → <em>access-level-modifier</em> <br><em>declaration-modifier</em> → <em>mutation-modifier</em> <br><em>declaration-modifier</em> → <em>actor-isolation-modifier</em> <br><em>declaration-modifiers</em> → <em>declaration-modifier</em> <em>declaration-modifiers</em><em>?</em></p>
<p><em>access-level-modifier</em> → <strong><code>private</code></strong> | <strong><code>private</code></strong> <strong><code>(</code></strong> <strong><code>set</code></strong> <strong><code>)</code></strong> <br><em>access-level-modifier</em> → <strong><code>fileprivate</code></strong> | <strong><code>fileprivate</code></strong> <strong><code>(</code></strong> <strong><code>set</code></strong> <strong><code>)</code></strong> <br><em>access-level-modifier</em> → <strong><code>internal</code></strong> | <strong><code>internal</code></strong> <strong><code>(</code></strong> <strong><code>set</code></strong> <strong><code>)</code></strong> <br><em>access-level-modifier</em> → <strong><code>package</code></strong> | <strong><code>package</code></strong> <strong><code>(</code></strong> <strong><code>set</code></strong> <strong><code>)</code></strong> <br><em>access-level-modifier</em> → <strong><code>public</code></strong> | <strong><code>public</code></strong> <strong><code>(</code></strong> <strong><code>set</code></strong> <strong><code>)</code></strong> <br><em>access-level-modifier</em> → <strong><code>open</code></strong> | <strong><code>open</code></strong> <strong><code>(</code></strong> <strong><code>set</code></strong> <strong><code>)</code></strong></p>
<p><em>mutation-modifier</em> → <strong><code>mutating</code></strong> | <strong><code>nonmutating</code></strong></p>
<p><em>actor-isolation-modifier</em> → <strong><code>nonisolated</code></strong></p>
</blockquote>
<!--
This source file is part of the Swift.org open source project

Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
Licensed under Apache License v2.0 with Runtime Library Exception

See https://swift.org/LICENSE.txt for license information
See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-->
</body></html>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/course/">COURSE</a></li>
            <li><a href="/course/ios/">IOS</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/">THE-SWIFT-PROGRAMMING-LANGUAGE-IN-CHINESE-6.0</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/ReferenceManual/">REFERENCEMANUAL</a></li>
            <li>DECLARATIONS</li>
          
  </ul>

    
    
    
  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">声明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B6%E7%BA%A7%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.</span> <span class="nav-text">顶级代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.2.</span> <span class="nav-text">代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%A3%B0%E6%98%8E"><span class="nav-number">1.3.</span> <span class="nav-text">导入声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">1.4.</span> <span class="nav-text">常量声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E"><span class="nav-number">1.5.</span> <span class="nav-text">类型别名声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.6.</span> <span class="nav-text">函数声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0"><span class="nav-number">1.6.1.</span> <span class="nav-text">参数名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">1.6.2.</span> <span class="nav-text">特殊类型的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.3.</span> <span class="nav-text">异步函数和方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%A3%B0%E6%98%8E"><span class="nav-number">1.7.</span> <span class="nav-text">枚举声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98"><span class="nav-number">1.7.1.</span> <span class="nav-text">任意类型的枚举成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">间接枚举</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.7.2.</span> <span class="nav-text">带有原始值类型的枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%A3%B0%E6%98%8E"><span class="nav-number">1.8.</span> <span class="nav-text">结构体声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%A3%B0%E6%98%8E"><span class="nav-number">1.9.</span> <span class="nav-text">类声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%A3%B0%E6%98%8E"><span class="nav-number">1.10.</span> <span class="nav-text">协议声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0%E5%99%A8%E5%A3%B0%E6%98%8E"><span class="nav-number">1.10.1.</span> <span class="nav-text">协议构造器声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E4%B8%8B%E6%A0%87%E5%A3%B0%E6%98%8E"><span class="nav-number">1.10.2.</span> <span class="nav-text">协议下标声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="nav-number">1.10.3.</span> <span class="nav-text">协议关联类型声明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%A3%B0%E6%98%8E"><span class="nav-number">1.11.</span> <span class="nav-text">构造器声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.11.1.</span> <span class="nav-text">可失败的构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%BA%A7%E5%88%AB"><span class="nav-number">1.11.2.</span> <span class="nav-text">访问控制级别</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="joe"
      src="/images/me.png">
  <p class="site-author-name" itemprop="name">joe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangdongyang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangdongyang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wf_pinbo@163.com" title="E-Mail → wf_pinbo@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备2021004873号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">joe</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'vrpizpRNUt6dhU7r9k6mBGRy-gzGzoHsz',
    appKey: '5lIjR9cSntdE9MvI7DIf55Xn',
    placeholder: "ヾﾉ≧∀≦)o 来呀！吐槽一番吧！",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
