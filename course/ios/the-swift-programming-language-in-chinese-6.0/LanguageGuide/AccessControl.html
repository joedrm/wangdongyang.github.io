<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="那年星空" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="访问控制通过声明、文件和模块来管理代码的可见性 访问控制可以限制其它源文件或模块对你的代码的访问。这个特性让你能够隐藏代码的实现细节，并指定一个接口来让别人访问和使用你的代码。 你可以给单个类型（类、结构体和枚举）设置特定的访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议可以被限制在特定的上下文中，全局常量、变量和函数也可以如此。 Swift 不仅提供了多种访问级别，还为典">
<meta property="og:type" content="website">
<meta property="og:title" content="那年星空">
<meta property="og:url" content="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AccessControl.html">
<meta property="og:site_name" content="那年星空">
<meta property="og:description" content="访问控制通过声明、文件和模块来管理代码的可见性 访问控制可以限制其它源文件或模块对你的代码的访问。这个特性让你能够隐藏代码的实现细节，并指定一个接口来让别人访问和使用你的代码。 你可以给单个类型（类、结构体和枚举）设置特定的访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议可以被限制在特定的上下文中，全局常量、变量和函数也可以如此。 Swift 不仅提供了多种访问级别，还为典">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-08T08:32:48.691Z">
<meta property="article:modified_time" content="2025-03-08T08:32:48.691Z">
<meta property="article:author" content="joe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AccessControl">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | 那年星空
  </title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6ad7c0c3175207d3b8885d6a63355af1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">那年星空</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content">
            

  <div class="posts-expand">
    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/course/">COURSE</a></li>
            <li><a href="/course/ios/">IOS</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/">THE-SWIFT-PROGRAMMING-LANGUAGE-IN-CHINESE-6.0</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/">LANGUAGEGUIDE</a></li>
            <li>ACCESSCONTROL</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <html><head></head><body></body></html><html><head></head><body><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>通过声明、文件和模块来管理代码的可见性</p>
<p><strong>访问控制</strong>可以限制其它源文件或模块对你的代码的访问。这个特性让你能够隐藏代码的实现细节，并指定一个接口来让别人访问和使用你的代码。</p>
<p>你可以给单个类型（类、结构体和枚举）设置特定的访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议可以被限制在特定的上下文中，全局常量、变量和函数也可以如此。</p>
<p>Swift 不仅提供了多种访问级别，还为典型场景提供了默认的访问级别，这样就减少了我们需要显式指定访问级别的情况。实际上，如果你在开发一个单 target 的应用程序，可能完全不需要显式指定访问级别。</p>
<blockquote>
<p>注意: 为了简洁起见，代码里可以应用访问控制的各个部分（属性、类型、函数等）在接下来的内容中将被统称为“实体”。</p>
</blockquote>
<h2 id="模块、源文件和包"><a href="#模块、源文件和包" class="headerlink" title="模块、源文件和包"></a>模块、源文件和包</h2><p>Swift 的访问控制模型是基于模块、源文件和包（packages）这三个概念的。</p>
<p><strong>模块</strong>是代码分发的独立单元，例如将一个框架或应用程序作为一个整体构建和发布，并且可以通过 Swift 的 <code>import</code> 关键字被其他模块导入。</p>
<p>在 Swift 中，Xcode 的每个构建目标（例如应用程序或框架）都被视为一个独立的模块。如果你将应用程序中的部分代码打包成一个独立的框架——以便封装这些代码并在多个应用程序中重用，那么当这个框架被导入到某个应用程序或其他框架中使用时，你在框架中定义的所有内容都将属于这个独立的模块。</p>
<p><strong>源文件</strong>是模块中的一个 Swift 源代码文件（实际上是应用程序或框架中的一个文件）。虽然通常会将不同的类型分别定义在不同的源文件中，但同一个源文件也可以包含多个类型、函数等的定义。</p>
<p><strong>包</strong>是一组模块的集合，这些模块作为一个整体进行开发。选择哪些模块来构成一个包，是在我们所使用的构建系统中配置的，而不是在 Swift 源代码中。例如，如果使用 Swift Package Manager 构建代码，你会在 <code>Package.swift</code> 文件中使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/packagedescription">PackageDescription</a> 模块的 API 来定义包；如果使用 Xcode，你会在“Package Access Identifier”构建设置中指定包名。</p>
<h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>Swift 为代码中的实体提供了六种不同的<strong>访问级别</strong>。这些访问级别取决于实体所在的源文件、源文件所属的模块，以及模块所属的包。</p>
<ul>
<li><em>open</em> 和 <em>public</em> 允许实体被同一模块内的任意源文件使用，也可以在导入该模块的其他模块的源文件内使用。通常使用 open 或 public 访问级别来指定框架的公共接口。open 和 public 访问级别的区别将在下文中说明。</li>
<li><em>package</em> 允许实体被同一模块内的任意源文件使用，但不能在包外的源文件内使用。通常在包含多个模块的应用或框架中使用 package。</li>
<li><em>internal</em> 允许实体被同一模块内的任意源文件使用，但不能在模块外的源文件中使用。通常在定义应用或框架的内部结构体时使用 internal。</li>
<li><em>fileprivate</em> 将对实体的使用限制在定义它的源文件内。当某个功能的实现细节只需要在当前文件中使用时，可以使用 fileprivate 来隐藏这些实现细节。</li>
<li><em>private</em> 将对实体的使用限制在其声明的作用域内，以及同一文件中该声明的扩展（extension）内。当某个功能的实现细节只在单个声明内部使用时，可以使用 private 来隐藏这些实现细节。</li>
</ul>
<p>open 是最高（限制最少）的访问级别，而 private 是最低（限制最多）的访问级别。</p>
<p>open 仅适用于类及类的成员，它与 public 的不同之处在于 open 允许模块外的代码进行继承和重写，如下文 <a href="doc:AccessControl#子类">doc:AccessControl#子类</a> 中所述。将类显式指定为 open 表明你已考虑到其他模块的代码将该类用作父类的影响，并为此相应地设计了类的代码。</p>
<h3 id="访问级别的指导原则"><a href="#访问级别的指导原则" class="headerlink" title="访问级别的指导原则"></a>访问级别的指导原则</h3><p>Swift 的访问级别遵循一个指导原则：<strong>实体的定义都不能依赖于访问级别更低（更严格）的其他实体</strong>。</p>
<p>例如:</p>
<ul>
<li>一个 public 的变量，其类型的访问级别不能是 internal，fileprivate 或 private，因为在 public 变量被使用的地方，这些类型可能无法访问。</li>
<li>函数的访问级别不能高于它的参数类型和返回类型的访问级别，因为函数可能会在这些类型不可用的情况下被调用。</li>
</ul>
<p>这一指导原则对语言不同方面的具体影响将在下文中详细说明。</p>
<h3 id="默认访问级别"><a href="#默认访问级别" class="headerlink" title="默认访问级别"></a>默认访问级别</h3><p>在代码中，所有实体（除了一些本章稍后会提到的特例）如果没有显式指定访问级别，那么默认的访问级别是 internal。因此，在多数情况下你不需要在代码中显式指定访问级别。</p>
<h3 id="单-Target-应用程序的访问级别"><a href="#单-Target-应用程序的访问级别" class="headerlink" title="单 Target 应用程序的访问级别"></a>单 Target 应用程序的访问级别</h3><p>当你编写一个简单的单 target 应用程序时，这些代码通常都是只供自己使用，而不需要在应用模块之外使用。因为默认的 internal 访问级别已经满足了这个需求，所以无需额外指定访问级别。但是，你也可以将某些代码的访问级别指定为 fileprivate 或 private，以便在模块内隐藏这部分代码的实现细节。</p>
<h3 id="框架的访问级别"><a href="#框架的访问级别" class="headerlink" title="框架的访问级别"></a>框架的访问级别</h3><p>当你开发框架时，应将框架的对外接口指定为 open 或 public，以便其他模块（如导入该框架的应用）可以查看和访问这些接口。这个对外接口就是框架的应用程序接口（application programming interface，即 API）。</p>
<blockquote>
<p>注意: 框架的内部实现细节仍然可以使用默认的访问级别 internal，当你需要对框架内部其它部分隐藏细节时可以使用 private 或 fileprivate。对于框架的 API 部分，你就需要将它们设置为 open 或 public 了。</p>
</blockquote>
<h3 id="单元测试-Target-的访问级别"><a href="#单元测试-Target-的访问级别" class="headerlink" title="单元测试 Target 的访问级别"></a>单元测试 Target 的访问级别</h3><p>当你编写包含单元测试 target 的应用程序时，需要将应用程序中的代码暴露给该模块以便进行测试。默认情况下，只有指定为 open 或 public 的实体才能被其他模块访问。不过，如果你在导入产品模块时使用了 <code>@testable</code> 属性，并且在编译时启用了测试选项，那么单元测试 target 就可以访问所有 internal 实体。</p>
<h2 id="访问控制语法"><a href="#访问控制语法" class="headerlink" title="访问控制语法"></a>访问控制语法</h2><p>在实体声明的前面添加修饰符 <code>open</code>、<code>public</code>、<code>internal</code>、<code>fileprivate</code> 或 <code>private</code> 来定义该实体的访问级别。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SomeOpenClass</span> {}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomePublicClass</span> {}</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">SomeInternalClass</span> {}</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">class</span> <span class="title class_">SomeFilePrivateClass</span> {}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SomePrivateClass</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> someOpenVariable <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> somePublicVariable <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">let</span> someInternalConstant <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someFilePrivateFunction</span>() {}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">somePrivateFunction</span>() {}</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `accessControlSyntax`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-&gt; open class SomeOpenClass &#123;&#125;</span><br><span class="line">-&gt; public class SomePublicClass &#123;&#125;</span><br><span class="line">-&gt; internal class SomeInternalClass &#123;&#125;</span><br><span class="line">-&gt; fileprivate class SomeFilePrivateClass &#123;&#125;</span><br><span class="line">-&gt; private class SomePrivateClass &#123;&#125;</span><br><span class="line">---</span><br><span class="line">-&gt; open var someOpenVariable = 0</span><br><span class="line">-&gt; public var somePublicVariable = 0</span><br><span class="line">-&gt; internal let someInternalConstant = 0</span><br><span class="line">-&gt; fileprivate func someFilePrivateFunction() &#123;&#125;</span><br><span class="line">-&gt; private func somePrivateFunction() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>除非专门指定，否则默认的访问级别是 <code>internal</code>，如在 <a href="doc:AccessControl#默认访问级别">doc:AccessControl#默认访问级别</a> 中所述。这意味着在不使用修饰符显式指定访问级别的情况下，<code>SomeInternalClass</code> 和 <code>someInternalConstant</code> 的访问级别仍然是 <code>internal</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeInternalClass</span> &#123;&#125;              <span class="comment">// 隐式指定为 internal</span></span><br><span class="line"><span class="keyword">let</span> someInternalConstant <span class="operator">=</span> <span class="number">0</span>            <span class="comment">// 隐式指定为 internal</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `accessControlDefaulted`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; class SomeInternalClass &#123;&#125;              // implicitly internal</span><br><span class="line">-&gt; let someInternalConstant = 0            // implicitly internal</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。这个新类型就可以在其访问级别允许的地方使用。例如，你定义了一个 fileprivate 访问级别的类，那么该类只能在定义它的源文件中使用——可以作为属性的类型、函数的参数类型或函数的返回类型。</p>
<p>一个类型的访问级别也会影响该类型的成员（其属性、方法、构造器和下标）的默认访问级别。如果你将一个类型的访问级别定义为 <code>private</code> 或 <code>fileprivate</code>，那么该类型的成员的默认访问级别也会是 <code>private</code> 或 <code>fileprivate</code>。如果你将一个类型的访问级别定义为 <code>internal</code> 或 <code>public</code>（或者使用 <code>internal</code> 的默认访问级别，而不显式指定访问级别），那么该类型的成员的默认访问级别将是 <code>internal</code>。</p>
<blockquote>
<p>重要提示: <code>public</code> 类型的成员默认具有 <code>internal</code> 访问级别，而不是 <code>public</code>。如果你想让某个成员是 <code>public</code>，必须显式地将其指定为 <code>public</code>。这样可以确保公共 API 都是你经过选择才发布的，避免错误地将内部使用的接口公开。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomePublicClass</span> &#123;                   <span class="comment">// 显式指定为 public 类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> somePublicProperty <span class="operator">=</span> <span class="number">0</span>            <span class="comment">// 显式指定为 public 类成员</span></span><br><span class="line">    <span class="keyword">var</span> someInternalProperty <span class="operator">=</span> <span class="number">0</span>                 <span class="comment">// 隐式指定为 internal 类成员</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someFilePrivateMethod</span>() &#123;&#125;  <span class="comment">// 显式指定为 fileprivate 类成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">somePrivateMethod</span>() &#123;&#125;          <span class="comment">// 显式指定为 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeInternalClass</span> &#123;                        <span class="comment">// 隐式指定为 internal 类</span></span><br><span class="line">    <span class="keyword">var</span> someInternalProperty <span class="operator">=</span> <span class="number">0</span>                 <span class="comment">// 隐式指定为 internal 类成员</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someFilePrivateMethod</span>() &#123;&#125;  <span class="comment">// 显式指定为 fileprivate 类成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">somePrivateMethod</span>() &#123;&#125;          <span class="comment">// 显式指定为 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">class</span> <span class="title class_">SomeFilePrivateClass</span> &#123;         <span class="comment">// 显式指定为 fileprivate 类</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">someFilePrivateMethod</span>() &#123;&#125;              <span class="comment">// 隐式指定为 fileprivate 类成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">somePrivateMethod</span>() &#123;&#125;          <span class="comment">// 显式指定为 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SomePrivateClass</span> &#123;                 <span class="comment">// 显式指定为 private 类</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">somePrivateMethod</span>() &#123;&#125;                  <span class="comment">// 隐式指定为 private 类成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `accessControl, accessControlWrong`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public class SomePublicClass &#123;                  // explicitly public class</span><br><span class="line">      public var somePublicProperty = 0            // explicitly public class member</span><br><span class="line">      var someInternalProperty = 0                 // implicitly internal class member</span><br><span class="line">      fileprivate func someFilePrivateMethod() &#123;&#125;  // explicitly file-private class member</span><br><span class="line">      private func somePrivateMethod() &#123;&#125;          // explicitly private class member</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; class SomeInternalClass &#123;                       // implicitly internal class</span><br><span class="line">      var someInternalProperty = 0                 // implicitly internal class member</span><br><span class="line">      fileprivate func someFilePrivateMethod() &#123;&#125;  // explicitly file-private class member</span><br><span class="line">      private func somePrivateMethod() &#123;&#125;          // explicitly private class member</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; fileprivate class SomeFilePrivateClass &#123;        // explicitly file-private class</span><br><span class="line">      func someFilePrivateMethod() &#123;&#125;              // implicitly file-private class member</span><br><span class="line">      private func somePrivateMethod() &#123;&#125;          // explicitly private class member</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; private class SomePrivateClass &#123;                // explicitly private class</span><br><span class="line">      func somePrivateMethod() &#123;&#125;                  // implicitly private class member</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组类型的访问级别是由元组中访问级别最严格的类型决定的。例如，你构建了一个包含两种不同类型的元组，其中一个是 <code>internal</code> 访问级别，另一个是 <code>private</code> 访问级别，那么这个元组的访问级别将是 <code>private</code>。</p>
<!--
  - test: `tupleTypes_Module1, tupleTypes_Module1_PublicAndInternal, tupleTypes_Module1_Private`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public struct PublicStruct &#123;&#125;</span><br><span class="line">-&gt; internal struct InternalStruct &#123;&#125;</span><br><span class="line">-&gt; fileprivate struct FilePrivateStruct &#123;&#125;</span><br><span class="line">-&gt; public func returnPublicTuple() -&gt; (PublicStruct, PublicStruct) &#123;</span><br><span class="line">      return (PublicStruct(), PublicStruct())</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; func returnInternalTuple() -&gt; (PublicStruct, InternalStruct) &#123;</span><br><span class="line">      return (PublicStruct(), InternalStruct())</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; fileprivate func returnFilePrivateTuple() -&gt; (PublicStruct, FilePrivateStruct) &#123;</span><br><span class="line">      return (PublicStruct(), FilePrivateStruct())</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `tupleTypes_Module1_PublicAndInternal`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// tuples with (at least) internal members can be accessed within their own module</span><br><span class="line">-&gt; let publicTuple = returnPublicTuple()</span><br><span class="line">-&gt; let internalTuple = returnInternalTuple()</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `tupleTypes_Module1_Private`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// a tuple with one or more private members can&#x27;t be accessed from outside of its source file</span><br><span class="line">-&gt; let privateTuple = returnFilePrivateTuple()</span><br><span class="line">!$ error: cannot find &#x27;returnFilePrivateTuple&#x27; in scope</span><br><span class="line">!! let privateTuple = returnFilePrivateTuple()</span><br><span class="line">!!                    ^~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `tupleTypes_Module2_Public`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// a public tuple with all-public members can be used in another module</span><br><span class="line">-&gt; import tupleTypes_Module1</span><br><span class="line">-&gt; let publicTuple = returnPublicTuple()</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `tupleTypes_Module2_InternalAndPrivate`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// tuples with internal or private members can&#x27;t be used outside of their own module</span><br><span class="line">-&gt; import tupleTypes_Module1</span><br><span class="line">-&gt; let internalTuple = returnInternalTuple()</span><br><span class="line">-&gt; let privateTuple = returnFilePrivateTuple()</span><br><span class="line">!$ error: cannot find &#x27;returnInternalTuple&#x27; in scope</span><br><span class="line">!! let internalTuple = returnInternalTuple()</span><br><span class="line">!!                     ^~~~~~~~~~~~~~~~~~~</span><br><span class="line">!$ error: cannot find &#x27;returnFilePrivateTuple&#x27; in scope</span><br><span class="line">!! let privateTuple = returnFilePrivateTuple()</span><br><span class="line">!!                    ^~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<blockquote>
<p>注意: 元组类型不像类、结构体、枚举和函数那样有单独的定义。元组类型的访问级别是根据构成该元组类型的各个类型的访问级别自动确定的，不能显式指定。</p>
</blockquote>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数类型的访问级别是根据函数的参数类型和返回类型中最严格的访问级别计算得出的。如果函数计算出的访问级别与上下文默认值不匹配，则必须在函数定义中显式指定访问级别。</p>
<p>下面的例子定义了一个名为 <code>someFunction()</code> 的全局函数，并且没有明确地指定其访问级别。你可能会认为这个函数会具有 <code>internal</code> 的默认访问级别，但事实并非如此。实际上，<code>someFunction()</code> 按照下面这种写法将无法编译：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>() -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处是函数实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `accessControlWrong`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123;</span><br><span class="line">      // function implementation goes here</span><br><span class="line">&gt;&gt;    return (SomeInternalClass(), SomePrivateClass())</span><br><span class="line">   &#125;</span><br><span class="line">!! /tmp/swifttest.swift:19:6: error: function must be declared private or fileprivate because its result uses a private type</span><br><span class="line">!! func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>该函数的返回类型是一个元组类型，由上面 <a href="doc:AccessControl#自定义类型">doc:AccessControl#自定义类型</a> 中定义的两个自定义类组成。其中一个类被定义为 <code>internal</code>，另一个类被定义为 <code>private</code>。因此，这个元组类型的访问级别是 <code>private</code>（组成元组的类型中最严格的访问级别）。</p>
<p>因为函数的返回类型是 <code>private</code>，所以你必须在函数声明中使用 <code>private</code> 修饰符指定函数的访问级别，这样才能使函数声明有效：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">someFunction</span>() -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处是函数实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `accessControl`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123;</span><br><span class="line">      // function implementation goes here</span><br><span class="line">&gt;&gt;    return (SomeInternalClass(), SomePrivateClass())</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>将 <code>someFunction()</code> 函数指定为 <code>public</code> 或 <code>internal</code>，或者使用默认的 <code>internal</code> 访问级别都是非法的，因为函数的 <code>public</code> 或 <code>internal</code> 使用者可能无法访问函数返回类型中的 <code>private</code> 类。</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举成员的访问级别和其所属的枚举类型相同。你不能为单个枚举成员指定不同的访问级别。</p>
<p>在下面的例子中，<code>CompassPoint</code> 枚举被显式指定为 <code>public</code> 访问级别。因此，枚举成员 <code>north</code>、<code>south</code>、<code>east</code> 和 <code>west</code> 也具有 <code>public</code> 访问级别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `enumerationCases`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public enum CompassPoint &#123;</span><br><span class="line">      case north</span><br><span class="line">      case south</span><br><span class="line">      case east</span><br><span class="line">      case west</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `enumerationCases_Module1`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public enum CompassPoint &#123;</span><br><span class="line">      case north</span><br><span class="line">      case south</span><br><span class="line">      case east</span><br><span class="line">      case west</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `enumerationCases_Module2`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; import enumerationCases_Module1</span><br><span class="line">-&gt; let north = CompassPoint.north</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h4 id="原始值和关联值"><a href="#原始值和关联值" class="headerlink" title="原始值和关联值"></a>原始值和关联值</h4><p>枚举定义中的原始值或关联值的类型，其访问级别至少不能低于该枚举的访问级别。例如，你不能在访问级别为 <code>internal</code> 的枚举中使用 <code>private</code> 类型作为原始值类型。</p>
<h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>嵌套类型的访问级别和包含它的类型的访问级别相同，除非包含它的类型是 <code>public</code>。定义在 <code>public</code> 类型中的嵌套类型，其访问级别默认是 <code>internal</code>。如果你想让这个嵌套类型拥有 <code>public</code> 访问级别，那么必须显式将其声明为 <code>public</code>。</p>
<!--
  - test: `nestedTypes_Module1, nestedTypes_Module1_PublicAndInternal, nestedTypes_Module1_Private`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public struct PublicStruct &#123;</span><br><span class="line">      public enum PublicEnumInsidePublicStruct &#123; case a, b &#125;</span><br><span class="line">      internal enum InternalEnumInsidePublicStruct &#123; case a, b &#125;</span><br><span class="line">      private enum PrivateEnumInsidePublicStruct &#123; case a, b &#125;</span><br><span class="line">      enum AutomaticEnumInsidePublicStruct &#123; case a, b &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; internal struct InternalStruct &#123;</span><br><span class="line">      internal enum InternalEnumInsideInternalStruct &#123; case a, b &#125;</span><br><span class="line">      private enum PrivateEnumInsideInternalStruct &#123; case a, b &#125;</span><br><span class="line">      enum AutomaticEnumInsideInternalStruct &#123; case a, b &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; private struct FilePrivateStruct &#123;</span><br><span class="line">      enum AutomaticEnumInsideFilePrivateStruct &#123; case a, b &#125;</span><br><span class="line">      private enum PrivateEnumInsideFilePrivateStruct &#123; case a, b &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; private struct PrivateStruct &#123;</span><br><span class="line">      enum AutomaticEnumInsidePrivateStruct &#123; case a, b &#125;</span><br><span class="line">      private enum PrivateEnumInsidePrivateStruct &#123; case a, b &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `nestedTypes_Module1_PublicAndInternal`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// these are all expected to succeed within the same module</span><br><span class="line">-&gt; let publicNestedInsidePublic = PublicStruct.PublicEnumInsidePublicStruct.a</span><br><span class="line">-&gt; let internalNestedInsidePublic = PublicStruct.InternalEnumInsidePublicStruct.a</span><br><span class="line">-&gt; let automaticNestedInsidePublic = PublicStruct.AutomaticEnumInsidePublicStruct.a</span><br><span class="line">---</span><br><span class="line">-&gt; let internalNestedInsideInternal = InternalStruct.InternalEnumInsideInternalStruct.a</span><br><span class="line">-&gt; let automaticNestedInsideInternal = InternalStruct.AutomaticEnumInsideInternalStruct.a</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `nestedTypes_Module1_Private`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// these are all expected to fail, because they&#x27;re private to the other file</span><br><span class="line">-&gt; let privateNestedInsidePublic = PublicStruct.PrivateEnumInsidePublicStruct.a</span><br><span class="line">---</span><br><span class="line">-&gt; let privateNestedInsideInternal = InternalStruct.PrivateEnumInsideInternalStruct.a</span><br><span class="line">---</span><br><span class="line">-&gt; let privateNestedInsidePrivate = PrivateStruct.PrivateEnumInsidePrivateStruct.a</span><br><span class="line">-&gt; let automaticNestedInsidePrivate = PrivateStruct.AutomaticEnumInsidePrivateStruct.a</span><br><span class="line">---</span><br><span class="line">!$ error: &#x27;PrivateEnumInsidePublicStruct&#x27; is inaccessible due to &#x27;private&#x27; protection level</span><br><span class="line">!! let privateNestedInsidePublic = PublicStruct.PrivateEnumInsidePublicStruct.a</span><br><span class="line">!!                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">!$ note: &#x27;PrivateEnumInsidePublicStruct&#x27; declared here</span><br><span class="line">!! private enum PrivateEnumInsidePublicStruct &#123; case a, b &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: &#x27;PrivateEnumInsideInternalStruct&#x27; is inaccessible due to &#x27;private&#x27; protection level</span><br><span class="line">!! let privateNestedInsideInternal = InternalStruct.PrivateEnumInsideInternalStruct.a</span><br><span class="line">!!                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">!$ note: &#x27;PrivateEnumInsideInternalStruct&#x27; declared here</span><br><span class="line">!! private enum PrivateEnumInsideInternalStruct &#123; case a, b &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: cannot find &#x27;PrivateStruct&#x27; in scope</span><br><span class="line">!! let privateNestedInsidePrivate = PrivateStruct.PrivateEnumInsidePrivateStruct.a</span><br><span class="line">!!                                  ^~~~~~~~~~~~~</span><br><span class="line">!$ error: cannot find &#x27;PrivateStruct&#x27; in scope</span><br><span class="line">!! let automaticNestedInsidePrivate = PrivateStruct.AutomaticEnumInsidePrivateStruct.a</span><br><span class="line">!!                                    ^~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `nestedTypes_Module2_Public`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// this is the only expected to succeed within the second module</span><br><span class="line">-&gt; import nestedTypes_Module1</span><br><span class="line">-&gt; let publicNestedInsidePublic = PublicStruct.PublicEnumInsidePublicStruct.a</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `nestedTypes_Module2_InternalAndPrivate`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// these are all expected to fail, because they&#x27;re private or internal to the other module</span><br><span class="line">-&gt; import nestedTypes_Module1</span><br><span class="line">-&gt; let internalNestedInsidePublic = PublicStruct.InternalEnumInsidePublicStruct.a</span><br><span class="line">-&gt; let automaticNestedInsidePublic = PublicStruct.AutomaticEnumInsidePublicStruct.a</span><br><span class="line">-&gt; let privateNestedInsidePublic = PublicStruct.PrivateEnumInsidePublicStruct.a</span><br><span class="line">---</span><br><span class="line">-&gt; let internalNestedInsideInternal = InternalStruct.InternalEnumInsideInternalStruct.a</span><br><span class="line">-&gt; let automaticNestedInsideInternal = InternalStruct.AutomaticEnumInsideInternalStruct.a</span><br><span class="line">-&gt; let privateNestedInsideInternal = InternalStruct.PrivateEnumInsideInternalStruct.a</span><br><span class="line">---</span><br><span class="line">-&gt; let privateNestedInsidePrivate = PrivateStruct.PrivateEnumInsidePrivateStruct.a</span><br><span class="line">-&gt; let automaticNestedInsidePrivate = PrivateStruct.AutomaticEnumInsidePrivateStruct.a</span><br><span class="line">---</span><br><span class="line">!$ error: &#x27;InternalEnumInsidePublicStruct&#x27; is inaccessible due to &#x27;internal&#x27; protection level</span><br><span class="line">!! let internalNestedInsidePublic = PublicStruct.InternalEnumInsidePublicStruct.a</span><br><span class="line">!!                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">!$ note: &#x27;InternalEnumInsidePublicStruct&#x27; declared here</span><br><span class="line">!! internal enum InternalEnumInsidePublicStruct &#123;</span><br><span class="line">!!               ^</span><br><span class="line">!$ error: &#x27;AutomaticEnumInsidePublicStruct&#x27; is inaccessible due to &#x27;internal&#x27; protection level</span><br><span class="line">!! let automaticNestedInsidePublic = PublicStruct.AutomaticEnumInsidePublicStruct.a</span><br><span class="line">!!                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">!$ note: &#x27;AutomaticEnumInsidePublicStruct&#x27; declared here</span><br><span class="line">!! internal enum AutomaticEnumInsidePublicStruct &#123;</span><br><span class="line">!!               ^</span><br><span class="line">!$ error: &#x27;PrivateEnumInsidePublicStruct&#x27; is inaccessible due to &#x27;private&#x27; protection level</span><br><span class="line">!! let privateNestedInsidePublic = PublicStruct.PrivateEnumInsidePublicStruct.a</span><br><span class="line">!!                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">!$ note: &#x27;PrivateEnumInsidePublicStruct&#x27; declared here</span><br><span class="line">!! private enum PrivateEnumInsidePublicStruct &#123;</span><br><span class="line">!!              ^</span><br><span class="line">!$ error: cannot find &#x27;InternalStruct&#x27; in scope</span><br><span class="line">!! let internalNestedInsideInternal = InternalStruct.InternalEnumInsideInternalStruct.a</span><br><span class="line">!!                                    ^~~~~~~~~~~~~~</span><br><span class="line">!$ error: cannot find &#x27;InternalStruct&#x27; in scope</span><br><span class="line">!! let automaticNestedInsideInternal = InternalStruct.AutomaticEnumInsideInternalStruct.a</span><br><span class="line">!!                                     ^~~~~~~~~~~~~~</span><br><span class="line">!$ error: cannot find &#x27;InternalStruct&#x27; in scope</span><br><span class="line">!! let privateNestedInsideInternal = InternalStruct.PrivateEnumInsideInternalStruct.a</span><br><span class="line">!!                                   ^~~~~~~~~~~~~~</span><br><span class="line">!$ error: cannot find &#x27;PrivateStruct&#x27; in scope</span><br><span class="line">!! let privateNestedInsidePrivate = PrivateStruct.PrivateEnumInsidePrivateStruct.a</span><br><span class="line">!!                                  ^~~~~~~~~~~~~</span><br><span class="line">!$ error: cannot find &#x27;PrivateStruct&#x27; in scope</span><br><span class="line">!! let automaticNestedInsidePrivate = PrivateStruct.AutomaticEnumInsidePrivateStruct.a</span><br><span class="line">!!                                    ^~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><p>你可以继承同一模块中的所有有访问权限的类，也可以继承不同模块中被 <code>open</code> 修饰的类。子类的访问级别不得高于父类的访问级别。例如，你不能写一个 <code>public</code> 的子类来继承 <code>internal</code> 的父类。</p>
<p>此外，对于同一模块中定义的类，你可以重写在上下文中可访问的任意类成员（方法、属性、构造器或下标）。对于在其他模块中定义的类，你可以重写访问级别为 <code>open</code> 的任意类成员。</p>
<p>通过重写可以给子类的成员提供更高的访问级别。下面的例子中，类 <code>A</code> 是一个 <code>public</code> 类，它有一个 <code>fileprivate</code> 的方法 <code>someMethod()</code>。类 <code>B</code> 是 <code>A</code> 的子类，其访问级别降低为 <code>internal</code>。但是，类 <code>B</code> 将 <code>someMethod()</code> 的访问级别重写为 <code>internal</code>，其访问级别高于原来的访问级别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">B</span>: <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `subclassingNoCall`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public class A &#123;</span><br><span class="line">      fileprivate func someMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; internal class B: A &#123;</span><br><span class="line">      override internal func someMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>即使子类成员的访问级别高于父类成员，只要调用父类成员的操作发生在允许的访问级别上下文中（例如，在同一源文件中调用父类 <code>fileprivate</code> 成员，在同一模块内调用父类 <code>internal</code> 成员），那么子类成员调用访问权限较低的父类成员也是合法的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">B</span>: <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.someMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `subclassingWithCall`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public class A &#123;</span><br><span class="line">      fileprivate func someMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; internal class B: A &#123;</span><br><span class="line">      override internal func someMethod() &#123;</span><br><span class="line">         super.someMethod()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>因为父类 <code>A</code> 和子类 <code>B</code> 定义在同一个源文件中，所以子类 <code>B</code> 可以在重写的 <code>someMethod()</code> 方法中调用 <code>super.someMethod()</code>。</p>
<h2 id="常量、变量、属性、下标"><a href="#常量、变量、属性、下标" class="headerlink" title="常量、变量、属性、下标"></a>常量、变量、属性、下标</h2><p>常量、变量或属性的访问级别不能高于其类型的访问级别。例如，如果一个属性的类型的访问级别是 <code>private</code>，那么不能将这个属性的访问级别指定为 <code>public</code>。同样，下标的访问级别不能高于其索引类型或返回类型的访问级别。</p>
<p>如果常量、变量、属性或下标的类型的访问级别是 <code>private</code>，那么也必须将它们的访问级别指定为 <code>private</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> privateInstance <span class="operator">=</span> <span class="type">SomePrivateClass</span>()</span><br></pre></td></tr></table></figure>

<!--
  - test: `accessControl`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; private var privateInstance = SomePrivateClass()</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `useOfPrivateTypeRequiresPrivateModifier`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-&gt; class Scope &#123;  // Need to be in a scope to meaningfully use private (vs fileprivate)</span><br><span class="line">-&gt; private class SomePrivateClass &#123;&#125;</span><br><span class="line">-&gt; let privateConstant = SomePrivateClass()</span><br><span class="line">!! /tmp/swifttest.swift:3:5: error: property must be declared private because its type &#x27;Scope.SomePrivateClass&#x27; uses a private type</span><br><span class="line">!! let privateConstant = SomePrivateClass()</span><br><span class="line">!! ^</span><br><span class="line">-&gt; var privateVariable = SomePrivateClass()</span><br><span class="line">!! /tmp/swifttest.swift:4:5: error: property must be declared private because its type &#x27;Scope.SomePrivateClass&#x27; uses a private type</span><br><span class="line">!! var privateVariable = SomePrivateClass()</span><br><span class="line">!! ^</span><br><span class="line">-&gt; class C &#123;</span><br><span class="line">      var privateProperty = SomePrivateClass()</span><br><span class="line">      subscript(index: Int) -&gt; SomePrivateClass &#123;</span><br><span class="line">         return SomePrivateClass()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; &#125;  // End surrounding scope</span><br><span class="line">!! /tmp/swifttest.swift:6:8: error: property must be declared private because its type &#x27;Scope.SomePrivateClass&#x27; uses a private type</span><br><span class="line">!! var privateProperty = SomePrivateClass()</span><br><span class="line">!! ^</span><br><span class="line">!! /tmp/swifttest.swift:7:4: error: subscript must be declared private because its element type uses a private type</span><br><span class="line">!! subscript(index: Int) -&gt; SomePrivateClass &#123;</span><br><span class="line">!! ^                        ~~~~~~~~~~~~~~~~</span><br><span class="line">!! /tmp/swifttest.swift:2:15: note: type declared here</span><br><span class="line">!! private class SomePrivateClass &#123;&#125;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="Getters-和-Setters"><a href="#Getters-和-Setters" class="headerlink" title="Getters 和 Setters"></a>Getters 和 Setters</h3><p>常量、变量、属性和下标的 <code>getter</code> 和 <code>setter</code> 会自动获得与它们所属的常量、变量、属性或下标相同的访问级别。</p>
<p>你可以为 <code>setter</code> 指定一个比对应 <code>getter</code> 更低的访问级别，以限制该变量、属性或下标的读写范围。你可以通过在 <code>var</code> 或 <code>subscript</code> 关键字之前写上 <code>fileprivate(set)</code>、<code>private(set)</code>、<code>internal(set)</code> 或 <code>package(set)</code> 来指定较低的访问级别。</p>
<blockquote>
<p>注意: 这个规则同时适用于存储属性和计算属性。即使你没有为存储属性显式编写 <code>getter</code> 和 <code>setter</code>，Swift 仍会为你合成一个隐式的 <code>getter</code> 和 <code>setter</code>，用于访问该属性的存储内容。无论是隐式合成的 <code>setter</code>，还是像计算属性中显式编写的 <code>setter</code>，使用 <code>fileprivate(set)</code>、<code>private(set)</code>、<code>internal(set)</code> 和 <code>package(set)</code> 都可以改变 <code>setter</code> 的访问级别。</p>
</blockquote>
<p>下面的例子定义了一个名为 <code>TrackedString</code> 的结构体，它记录了一个字符串属性被修改的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrackedString</span> &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> numberOfEdits <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            numberOfEdits <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `reducedSetterScope, reducedSetterScope_error`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt; struct TrackedString &#123;</span><br><span class="line">      private(set) var numberOfEdits = 0</span><br><span class="line">      var value: String = &quot;&quot; &#123;</span><br><span class="line">         didSet &#123;</span><br><span class="line">            numberOfEdits += 1</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>TrackedString</code> 结构体定义了一个用于存储 <code>String</code> 的属性 <code>value</code>，并将初始值设为 <code>&quot;&quot;</code>（空字符串）。该结构体还定义了一个用于存储 <code>Int</code> 的属性 <code>numberOfEdits</code>，它用于记录属性 <code>value</code> 被修改的次数。这个功能是通过 <code>value</code> 属性上的 <code>didSet</code> 属性观察器实现的，每当给 <code>value</code> 赋新值时，<code>numberOfEdits</code> 都会递增。</p>
<p>结构体 <code>TrackedString</code> 和它的属性 <code>value</code> 都没有显式指定访问级别，所以它们都具有默认的访问级别 <code>internal</code>。然而，<code>numberOfEdits</code> 属性的访问级别被指定为 <code>private(set)</code>，这意味该属性的 <code>getter</code> 仍然具有 <code>internal</code> 的默认访问级别，但只能在 <code>TrackedString</code> 结构体内部进行赋值。这使得该属性只能在结构体内部修改，而在结构体的外部呈现为一个只读属性。</p>
<!--
  - test: `reducedSetterScope_error`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; extension TrackedString &#123;</span><br><span class="line">       mutating func f() &#123; numberOfEdits += 1 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">// check that we can&#x27;t set its value with from the same file</span><br><span class="line">-&gt; var s = TrackedString()</span><br><span class="line">-&gt; let resultA: Void = &#123; s.numberOfEdits += 1 &#125;()</span><br><span class="line">!! /tmp/swifttest.swift:13:39: error: left side of mutating operator isn&#x27;t mutable: &#x27;numberOfEdits&#x27; setter is inaccessible</span><br><span class="line">!! let resultA: Void = &#123; s.numberOfEdits += 1 &#125;()</span><br><span class="line">!!                       ~~~~~~~~~~~~~~~ ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  The assertion above must be compiled because of a REPL bug
  <rdar://problem/54089342> REPL fails to enforce private(set) on struct property
-->

<p>如果你创建一个 <code>TrackedString</code> 实例并多次修改它的字符串值，你就会看到 <code>numberOfEdits</code> 属性的值和修改次数一致：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringToEdit <span class="operator">=</span> <span class="type">TrackedString</span>()</span><br><span class="line">stringToEdit.value <span class="operator">=</span> <span class="string">"This string will be tracked."</span></span><br><span class="line">stringToEdit.value <span class="operator">+=</span> <span class="string">" This edit will increment numberOfEdits."</span></span><br><span class="line">stringToEdit.value <span class="operator">+=</span> <span class="string">" So will this one."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The number of edits is <span class="subst">\(stringToEdit.numberOfEdits)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印“The number of edits is 3”</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `reducedSetterScope`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; var stringToEdit = TrackedString()</span><br><span class="line">-&gt; stringToEdit.value = &quot;This string will be tracked.&quot;</span><br><span class="line">-&gt; stringToEdit.value += &quot; This edit will increment numberOfEdits.&quot;</span><br><span class="line">-&gt; stringToEdit.value += &quot; So will this one.&quot;</span><br><span class="line">-&gt; print(&quot;The number of edits is \(stringToEdit.numberOfEdits)&quot;)</span><br><span class="line">&lt;- The number of edits is 3</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>虽然你可以从其他源文件中查询 <code>numberOfEdits</code> 属性的当前值，但不能从其他源文件中<strong>修改</strong>该属性。这个限制保护了 <code>TrackedString</code> 的编辑跟踪功能的实现细节，同时还提供了该功能方便的访问方式。</p>
<p>需要注意的是，你可以在必要时为 <code>getter</code> 和 <code>setter</code> 分别指定显式的访问级别。下面的例子将 <code>TrackedString</code> 结构体显式指定为了 <code>public</code> 访问级别。结构体的成员（包括 <code>numberOfEdits</code> 属性）拥有默认的访问级别 <code>internal</code>。你可以组合 <code>public</code> 和 <code>private(set)</code> 修饰符把结构体中的 <code>numberOfEdits</code> 属性的 <code>getter</code> 的访问级别设置为 <code>public</code>，而 <code>setter</code> 的访问级别设置为 <code>private</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">TrackedString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> numberOfEdits <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            numberOfEdits <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `reducedSetterScopePublic`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public struct TrackedString &#123;</span><br><span class="line">      public private(set) var numberOfEdits = 0</span><br><span class="line">      public var value: String = &quot;&quot; &#123;</span><br><span class="line">         didSet &#123;</span><br><span class="line">            numberOfEdits += 1</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public init() &#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `reducedSetterScopePublic_Module1_Allowed, reducedSetterScopePublic_Module1_NotAllowed`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public struct TrackedString &#123;</span><br><span class="line">      public private(set) var numberOfEdits = 0</span><br><span class="line">      public var value: String = &quot;&quot; &#123;</span><br><span class="line">         didSet &#123;</span><br><span class="line">            numberOfEdits += 1</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public init() &#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `reducedSetterScopePublic_Module1_Allowed`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// check that we can retrieve its value with the public getter from another file in the same module</span><br><span class="line">-&gt; var stringToEdit_Module1B = TrackedString()</span><br><span class="line">-&gt; let resultB = stringToEdit_Module1B.numberOfEdits</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `reducedSetterScopePublic_Module1_NotAllowed`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// check that we can&#x27;t set its value from another file in the same module</span><br><span class="line">-&gt; var stringToEdit_Module1C = TrackedString()</span><br><span class="line">-&gt; let resultC: Void = &#123; stringToEdit_Module1C.numberOfEdits += 1 &#125;()</span><br><span class="line">!$ error: left side of mutating operator isn&#x27;t mutable: &#x27;numberOfEdits&#x27; setter is inaccessible</span><br><span class="line">!! let resultC: Void = &#123; stringToEdit_Module1C.numberOfEdits += 1 &#125;()</span><br><span class="line">!!                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `reducedSetterScopePublic_Module2`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// check that we can retrieve its value with the public getter from a different module</span><br><span class="line">-&gt; import reducedSetterScopePublic_Module1_Allowed</span><br><span class="line">-&gt; var stringToEdit_Module2 = TrackedString()</span><br><span class="line">-&gt; let result2Read = stringToEdit_Module2.numberOfEdits</span><br><span class="line">// check that we can&#x27;t change its value from another module</span><br><span class="line">-&gt; let result2Write: Void = &#123; stringToEdit_Module2.numberOfEdits += 1 &#125;()</span><br><span class="line">!$ error: left side of mutating operator isn&#x27;t mutable: &#x27;numberOfEdits&#x27; setter is inaccessible</span><br><span class="line">!! let result2Write: Void = &#123; stringToEdit_Module2.numberOfEdits += 1 &#125;()</span><br><span class="line">!!                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>自定义构造器的访问级别可以低于或等于它所初始化的类型。唯一的例外是必要构造器（如 <a href="doc:Initialization#必要构造器">doc:Initialization#必要构造器</a> 中定义的）。必要构造器必须具有与其所属类相同的访问级别。</p>
<p>与函数和方法的参数一样，构造器的参数类型的访问级别不能比构造器自身的访问级别更严格。</p>
<h3 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h3><p>如 <a href="doc:Initialization#默认构造器">doc:Initialization#默认构造器</a> 中所述，Swift 会为结构体和类自动生成一个不带参数的<strong>默认构造器</strong>，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。</p>
<p>默认构造器的访问级别与它所初始化的类型相同，除非该类型被定义为 <code>public</code>。对于 <code>public</code> 类型，默认构造器的访问级别将为 <code>internal</code>。如果你想让 <code>public</code> 类型在另一个模块中可以通过无参数构造器进行初始化，则必须在类型定义中显式提供一个 <code>public</code> 访问级别的无参数构造器。</p>
<h3 id="结构体默认的成员逐一构造器"><a href="#结构体默认的成员逐一构造器" class="headerlink" title="结构体默认的成员逐一构造器"></a>结构体默认的成员逐一构造器</h3><p>对于结构体类型，如果结构体中的任何一个存储属性是 <code>private</code>，则默认的成员逐一构造器的为 <code>private</code>。同样，如果任何存储属性是 <code>fileprivate</code>，则默认的成员逐一构造器为 <code>fileprivate</code>。否则，默认的成员逐一构造器为 <code>internal</code>。</p>
<p>与前面提到的默认构造器一样，如果你想让 <code>public</code> 结构体类型在其他模块中可以通过成员逐一构造器进行初始化，则必须在类型定义中显式提供一个 <code>public</code> 的成员逐一构造器。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>如果你想为协议类型显式指定访问级别，需要在定义协议时进行指定。这将限制该协议只能在特定的访问级别范围内被遵循。</p>
<p>协议定义中的每个要求都必须具有和该协议相同的访问级别。你不能将协议要求的访问级别设置为其他访问级别。这样才能确保遵循该协议的任何类型都能访问协议中的所有要求。</p>
<!--
  - test: `protocolRequirementsCannotBeDifferentThanTheProtocol`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public protocol PublicProtocol &#123;</span><br><span class="line">      public var publicProperty: Int &#123; get &#125;</span><br><span class="line">      internal var internalProperty: Int &#123; get &#125;</span><br><span class="line">      fileprivate var filePrivateProperty: Int &#123; get &#125;</span><br><span class="line">      private var privateProperty: Int &#123; get &#125;</span><br><span class="line">   &#125;</span><br><span class="line">!$ error: &#x27;public&#x27; modifier cannot be used in protocols</span><br><span class="line">!! public var publicProperty: Int &#123; get &#125;</span><br><span class="line">!! ^~~~~~~</span><br><span class="line">!!-</span><br><span class="line">!$ note: protocol requirements implicitly have the same access as the protocol itself</span><br><span class="line">!! public var publicProperty: Int &#123; get &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: &#x27;internal&#x27; modifier cannot be used in protocols</span><br><span class="line">!! internal var internalProperty: Int &#123; get &#125;</span><br><span class="line">!! ^~~~~~~~~</span><br><span class="line">!!-</span><br><span class="line">!$ note: protocol requirements implicitly have the same access as the protocol itself</span><br><span class="line">!! internal var internalProperty: Int &#123; get &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: &#x27;fileprivate&#x27; modifier cannot be used in protocols</span><br><span class="line">!! fileprivate var filePrivateProperty: Int &#123; get &#125;</span><br><span class="line">!! ^~~~~~~~~~~~</span><br><span class="line">!!-</span><br><span class="line">!$ note: protocol requirements implicitly have the same access as the protocol itself</span><br><span class="line">!! fileprivate var filePrivateProperty: Int &#123; get &#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: &#x27;private&#x27; modifier cannot be used in protocols</span><br><span class="line">!! private var privateProperty: Int &#123; get &#125;</span><br><span class="line">!! ^~~~~~~~</span><br><span class="line">!!-</span><br><span class="line">!$ note: protocol requirements implicitly have the same access as the protocol itself</span><br><span class="line">!! private var privateProperty: Int &#123; get &#125;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<blockquote>
<p>注意: 如果你定义了一个 <code>public</code> 协议，那么在实现该协议时，协议的所有要求也需要具有 <code>public</code> 访问级别。这点与其他类型不同，在其他类型中，如果类型的访问级别是 <code>public</code>，通常意味着该类型的成员具有 <code>internal</code> 访问级别。</p>
</blockquote>
<!--
  - test: `protocols_Module1, protocols_Module1_PublicAndInternal, protocols_Module1_Private`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public protocol PublicProtocol &#123;</span><br><span class="line">      var publicProperty: Int &#123; get &#125;</span><br><span class="line">      func publicMethod()</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; internal protocol InternalProtocol &#123;</span><br><span class="line">      var internalProperty: Int &#123; get &#125;</span><br><span class="line">      func internalMethod()</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; fileprivate protocol FilePrivateProtocol &#123;</span><br><span class="line">      var filePrivateProperty: Int &#123; get &#125;</span><br><span class="line">      func filePrivateMethod()</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; private protocol PrivateProtocol &#123;</span><br><span class="line">      var privateProperty: Int &#123; get &#125;</span><br><span class="line">      func privateMethod()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `protocols_Module1_PublicAndInternal`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// these should all be allowed without problem</span><br><span class="line">-&gt; public class PublicClassConformingToPublicProtocol: PublicProtocol &#123;</span><br><span class="line">      public var publicProperty = 0</span><br><span class="line">      public func publicMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; internal class InternalClassConformingToPublicProtocol: PublicProtocol &#123;</span><br><span class="line">      var publicProperty = 0</span><br><span class="line">      func publicMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; private class PrivateClassConformingToPublicProtocol: PublicProtocol &#123;</span><br><span class="line">      var publicProperty = 0</span><br><span class="line">      func publicMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; public class PublicClassConformingToInternalProtocol: InternalProtocol &#123;</span><br><span class="line">      var internalProperty = 0</span><br><span class="line">      func internalMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; internal class InternalClassConformingToInternalProtocol: InternalProtocol &#123;</span><br><span class="line">      var internalProperty = 0</span><br><span class="line">      func internalMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; private class PrivateClassConformingToInternalProtocol: InternalProtocol &#123;</span><br><span class="line">      var internalProperty = 0</span><br><span class="line">      func internalMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `protocols_Module1_Private`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// these will fail, because FilePrivateProtocol isn&#x27;t visible outside of its file</span><br><span class="line">-&gt; public class PublicClassConformingToFilePrivateProtocol: FilePrivateProtocol &#123;</span><br><span class="line">      var filePrivateProperty = 0</span><br><span class="line">      func filePrivateMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">!$ error: cannot find type &#x27;FilePrivateProtocol&#x27; in scope</span><br><span class="line">!! public class PublicClassConformingToFilePrivateProtocol: FilePrivateProtocol &#123;</span><br><span class="line">!! ^~~~~~~~~~~~~~~~~~~</span><br><span class="line">---</span><br><span class="line">// these will fail, because PrivateProtocol isn&#x27;t visible outside of its file</span><br><span class="line">-&gt; public class PublicClassConformingToPrivateProtocol: PrivateProtocol &#123;</span><br><span class="line">      var privateProperty = 0</span><br><span class="line">      func privateMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">!$ error: cannot find type &#x27;PrivateProtocol&#x27; in scope</span><br><span class="line">!! public class PublicClassConformingToPrivateProtocol: PrivateProtocol &#123;</span><br><span class="line">!! ^~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `protocols_Module2_Public`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// these should all be allowed without problem</span><br><span class="line">-&gt; import protocols_Module1</span><br><span class="line">-&gt; public class PublicClassConformingToPublicProtocol: PublicProtocol &#123;</span><br><span class="line">      public var publicProperty = 0</span><br><span class="line">      public func publicMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; internal class InternalClassConformingToPublicProtocol: PublicProtocol &#123;</span><br><span class="line">      var publicProperty = 0</span><br><span class="line">      func publicMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; private class PrivateClassConformingToPublicProtocol: PublicProtocol &#123;</span><br><span class="line">      var publicProperty = 0</span><br><span class="line">      func publicMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `protocols_Module2_InternalAndPrivate`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// these will all fail, because InternalProtocol, FilePrivateProtocol, and PrivateProtocol</span><br><span class="line">// aren&#x27;t visible to other modules</span><br><span class="line">-&gt; import protocols_Module1</span><br><span class="line">-&gt; public class PublicClassConformingToInternalProtocol: InternalProtocol &#123;</span><br><span class="line">      var internalProperty = 0</span><br><span class="line">      func internalMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; public class PublicClassConformingToFilePrivateProtocol: FilePrivateProtocol &#123;</span><br><span class="line">      var filePrivateProperty = 0</span><br><span class="line">      func filePrivateMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; public class PublicClassConformingToPrivateProtocol: PrivateProtocol &#123;</span><br><span class="line">      var privateProperty = 0</span><br><span class="line">      func privateMethod() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">!$ error: cannot find type &#x27;InternalProtocol&#x27; in scope</span><br><span class="line">!! public class PublicClassConformingToInternalProtocol: InternalProtocol &#123;</span><br><span class="line">!! ^~~~~~~~~~~~~~~~</span><br><span class="line">!$ error: cannot find type &#x27;FilePrivateProtocol&#x27; in scope</span><br><span class="line">!! public class PublicClassConformingToFilePrivateProtocol: FilePrivateProtocol &#123;</span><br><span class="line">!! ^~~~~~~~~~~~~~~~~~~</span><br><span class="line">!$ error: cannot find type &#x27;PrivateProtocol&#x27; in scope</span><br><span class="line">!! public class PublicClassConformingToPrivateProtocol: PrivateProtocol &#123;</span><br><span class="line">!! ^~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h3><p>如果你定义了一个继承自其他协议的新协议，那么新协议的访问级别最高也只能与其继承的协议相同。例如，你不能定义一个继承自 <code>internal</code> 协议的 <code>public</code> 协议。</p>
<h3 id="协议遵循"><a href="#协议遵循" class="headerlink" title="协议遵循"></a>协议遵循</h3><p>一个类型可以遵循比其自身访问级别更低的协议。例如，你可以定义一个 <code>public</code> 类型，使其可以在其他模块中使用，但该类型对 <code>internal</code> 协议的遵循只能在定义该 <code>internal</code> 协议的模块中使用。</p>
<p>遵循协议时的上下文访问级别是类型和协议中访问级别最低的那个。例如，如果一个类型是 <code>public</code> 的，但它遵循 <code>internal</code> 协议，那么这个类型对该协议遵循的上下文访问级别也是 <code>internal</code> 的。</p>
<p>当你编写或扩展一个类型让它遵循一个协议时，你必须确保该类型对协议每一个要求的实现至少与协议的访问级别一致。例如，如果一个 <code>public</code> 类型遵循一个 <code>internal</code> 协议，那么该类型对协议每一个要求的实现必须至少是 <code>internal</code>。</p>
<blockquote>
<p>注意: Swift 和 Objective-C 一样，协议遵循是全局的。在同一程序中，一个类型不可能用两种不同的方式遵循同一个协议。</p>
</blockquote>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>可以在访问级别允许的情况下对类、结构体或枚举进行扩展。在扩展中添加的类型成员具有与原始类型中声明的类型成员相同的默认访问级别。如果你扩展的是 <code>public</code> 或 <code>internal</code> 类型，那么任何新增的类型成员默认的访问级别是 <code>internal</code>。如果你扩展的是 <code>fileprivate</code> 类型，那么新增的类型成员默认的访问级别是 <code>fileprivate</code>。如果你扩展的是 <code>private</code> 类型，那么新增的类型成员默认的访问级别是 <code>private</code>。</p>
<p>或者，你可以使用显式的访问级别修饰符（例如 <code>private</code>）标记一个扩展，从而为扩展内定义的所有成员指定一个新的默认访问级别。在此扩展内，这个新的默认级别仍然可以被单个类型成员显式指定的访问级别所覆盖。</p>
<p>如果你使用扩展来遵循协议的话，就不能为扩展提供显式的访问级别修饰符。在这种情况下，协议自身的访问级别将被用作扩展中每个协议要求的实现的默认访问级别。</p>
<!--
  - test: `extensions_Module1, extensions_Module1_PublicAndInternal, extensions_Module1_Private`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public struct PublicStruct &#123;</span><br><span class="line">      public init() &#123;&#125;</span><br><span class="line">      func implicitlyInternalMethodFromStruct() -&gt; Int &#123; return 0 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; extension PublicStruct &#123;</span><br><span class="line">      func implicitlyInternalMethodFromExtension() -&gt; Int &#123; return 0 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; fileprivate extension PublicStruct &#123;</span><br><span class="line">      func filePrivateMethod() -&gt; Int &#123; return 0 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; var publicStructInSameFile = PublicStruct()</span><br><span class="line">-&gt; let sameFileA = publicStructInSameFile.implicitlyInternalMethodFromStruct()</span><br><span class="line">-&gt; let sameFileB = publicStructInSameFile.implicitlyInternalMethodFromExtension()</span><br><span class="line">-&gt; let sameFileC = publicStructInSameFile.filePrivateMethod()</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `extensions_Module1_PublicAndInternal`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; var publicStructInDifferentFile = PublicStruct()</span><br><span class="line">-&gt; let differentFileA = publicStructInDifferentFile.implicitlyInternalMethodFromStruct()</span><br><span class="line">-&gt; let differentFileB = publicStructInDifferentFile.implicitlyInternalMethodFromExtension()</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `extensions_Module1_Private`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt; var publicStructInDifferentFile = PublicStruct()</span><br><span class="line">-&gt; let differentFileC = publicStructInDifferentFile.filePrivateMethod()</span><br><span class="line">!$ error: &#x27;filePrivateMethod&#x27; is inaccessible due to &#x27;fileprivate&#x27; protection level</span><br><span class="line">!! let differentFileC = publicStructInDifferentFile.filePrivateMethod()</span><br><span class="line">!!                                                  ^~~~~~~~~~~~~~~~~</span><br><span class="line">!$ note: &#x27;filePrivateMethod()&#x27; declared here</span><br><span class="line">!! func filePrivateMethod() -&gt; Int &#123; return 0 &#125;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  - test: `extensions_Module2`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-&gt; import extensions_Module1</span><br><span class="line">-&gt; var publicStructInDifferentModule = PublicStruct()</span><br><span class="line">-&gt; let differentModuleA = publicStructInDifferentModule.implicitlyInternalMethodFromStruct()</span><br><span class="line">!$ error: &#x27;implicitlyInternalMethodFromStruct&#x27; is inaccessible due to &#x27;internal&#x27; protection level</span><br><span class="line">!! let differentModuleA = publicStructInDifferentModule.implicitlyInternalMethodFromStruct()</span><br><span class="line">!!                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">!$ note: &#x27;implicitlyInternalMethodFromStruct()&#x27; declared here</span><br><span class="line">!! internal func implicitlyInternalMethodFromStruct() -&gt; Int</span><br><span class="line">!!               ^</span><br><span class="line">-&gt; let differentModuleB = publicStructInDifferentModule.implicitlyInternalMethodFromExtension()</span><br><span class="line">!$ error: &#x27;implicitlyInternalMethodFromExtension&#x27; is inaccessible due to &#x27;internal&#x27; protection level</span><br><span class="line">!! let differentModuleB = publicStructInDifferentModule.implicitlyInternalMethodFromExtension()</span><br><span class="line">!!                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">!$ note: &#x27;implicitlyInternalMethodFromExtension()&#x27; declared here</span><br><span class="line">!! internal func implicitlyInternalMethodFromExtension() -&gt; Int</span><br><span class="line">!!               ^</span><br><span class="line">-&gt; let differentModuleC = publicStructInDifferentModule.filePrivateMethod()</span><br><span class="line">!$ error: &#x27;filePrivateMethod&#x27; is inaccessible due to &#x27;fileprivate&#x27; protection level</span><br><span class="line">!! let differentModuleC = publicStructInDifferentModule.filePrivateMethod()</span><br><span class="line">!!                                                      ^~~~~~~~~~~~~~~~~</span><br><span class="line">!$ note: &#x27;filePrivateMethod()&#x27; declared here</span><br><span class="line">!! fileprivate func filePrivateMethod() -&gt; Int</span><br><span class="line">!!                  ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="扩展的私有成员"><a href="#扩展的私有成员" class="headerlink" title="扩展的私有成员"></a>扩展的私有成员</h3><p>扩展同一文件内的类，结构体或者枚举，扩展里的代码会表现得跟声明在原始类型里的一模一样。因此，你可以：</p>
<ul>
<li>在原始声明中声明一个 <code>private</code> 成员，并在同一文件中的扩展中访问该成员。</li>
<li>在一个扩展中声明一个 <code>private</code> 成员，并在同一文件中的另一个扩展中访问该成员。</li>
<li>在扩展中声明一个 <code>private</code> 成员，并在同一文件中的原始声明中访问该成员。</li>
</ul>
<p>这意味着你可以使用扩展来组织你的代码，无论你的类型是否包含 <code>private</code> 成员。例如，给定下面这样一个简单的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `extensions_privatemembers`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol SomeProtocol &#123;</span><br><span class="line">       func doSomething()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>你可以使用扩展来添加协议遵循，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStruct</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> privateVariable <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">SomeStruct</span>: <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(privateVariable)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `extensions_privatemembers`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-&gt; struct SomeStruct &#123;</span><br><span class="line">       private var privateVariable = 12</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; extension SomeStruct: SomeProtocol &#123;</span><br><span class="line">       func doSomething() &#123;</span><br><span class="line">           print(privateVariable)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&gt; let s = SomeStruct()</span><br><span class="line">&gt;&gt; s.doSomething()</span><br><span class="line">&lt;&lt; 12</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型类型或泛型函数的访问级别取决于它本身的访问级别和其类型参数的类型约束的访问级别，最终由这些访问级别中的最低者决定。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>在访问控制层面，你定义的任何类型别名都被视为独立的类型。类型别名的访问级别不可以高于其表示的类型的访问级别。例如，一个 <code>private</code> 类型别名可以作为 <code>private</code>、<code>fileprivate</code>、<code>internal</code>、<code>public</code> 或 <code>open</code> 类型的别名，但一个 <code>public</code> 类型别名不能作为 <code>internal</code>、<code>fileprivate</code> 或 <code>private</code> 类型的别名。</p>
<blockquote>
<p>注意: 这条规则也适用于为满足协议遵循而将类型别名用于关联类型的情况。</p>
</blockquote>
<!--
  - test: `typeAliases`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-&gt; public struct PublicStruct &#123;&#125;</span><br><span class="line">-&gt; internal struct InternalStruct &#123;&#125;</span><br><span class="line">-&gt; private struct PrivateStruct &#123;&#125;</span><br><span class="line">---</span><br><span class="line">-&gt; public typealias PublicAliasOfPublicType = PublicStruct</span><br><span class="line">-&gt; internal typealias InternalAliasOfPublicType = PublicStruct</span><br><span class="line">-&gt; private typealias PrivateAliasOfPublicType = PublicStruct</span><br><span class="line">---</span><br><span class="line">-&gt; public typealias PublicAliasOfInternalType = InternalStruct     // not allowed</span><br><span class="line">-&gt; internal typealias InternalAliasOfInternalType = InternalStruct</span><br><span class="line">-&gt; private typealias PrivateAliasOfInternalType = InternalStruct</span><br><span class="line">---</span><br><span class="line">-&gt; public typealias PublicAliasOfPrivateType = PrivateStruct       // not allowed</span><br><span class="line">-&gt; internal typealias InternalAliasOfPrivateType = PrivateStruct   // not allowed</span><br><span class="line">-&gt; private typealias PrivateAliasOfPrivateType = PrivateStruct</span><br><span class="line">---</span><br><span class="line">!$ error: type alias cannot be declared public because its underlying type uses an internal type</span><br><span class="line">!! public typealias PublicAliasOfInternalType = InternalStruct     // not allowed</span><br><span class="line">!! ^                           ~~~~~~~~~~~~~~</span><br><span class="line">!$ note: type declared here</span><br><span class="line">!! internal struct InternalStruct &#123;&#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: type alias cannot be declared public because its underlying type uses a private type</span><br><span class="line">!! public typealias PublicAliasOfPrivateType = PrivateStruct       // not allowed</span><br><span class="line">!! ^                          ~~~~~~~~~~~~~</span><br><span class="line">!$ note: type declared here</span><br><span class="line">!! private struct PrivateStruct &#123;&#125;</span><br><span class="line">!! ^</span><br><span class="line">!$ error: type alias cannot be declared internal because its underlying type uses a private type</span><br><span class="line">!! internal typealias InternalAliasOfPrivateType = PrivateStruct   // not allowed</span><br><span class="line">!! ^                            ~~~~~~~~~~~~~</span><br><span class="line">!$ note: type declared here</span><br><span class="line">!! private struct PrivateStruct &#123;&#125;</span><br><span class="line">!! ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
This source file is part of the Swift.org open source project

Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
Licensed under Apache License v2.0 with Runtime Library Exception

See https://swift.org/LICENSE.txt for license information
See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-->
</body></html>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/course/">COURSE</a></li>
            <li><a href="/course/ios/">IOS</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/">THE-SWIFT-PROGRAMMING-LANGUAGE-IN-CHINESE-6.0</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/">LANGUAGEGUIDE</a></li>
            <li>ACCESSCONTROL</li>
          
  </ul>

    
    
    
  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E3%80%81%E6%BA%90%E6%96%87%E4%BB%B6%E5%92%8C%E5%8C%85"><span class="nav-number">1.1.</span> <span class="nav-text">模块、源文件和包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">访问级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB%E7%9A%84%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99"><span class="nav-number">1.2.1.</span> <span class="nav-text">访问级别的指导原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">默认访问级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95-Target-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.3.</span> <span class="nav-text">单 Target 应用程序的访问级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.4.</span> <span class="nav-text">框架的访问级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Target-%E7%9A%84%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.5.</span> <span class="nav-text">单元测试 Target 的访问级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">访问控制语法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="joe"
      src="/images/me.png">
  <p class="site-author-name" itemprop="name">joe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangdongyang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangdongyang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wf_pinbo@163.com" title="E-Mail → wf_pinbo@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备2021004873号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">joe</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'vrpizpRNUt6dhU7r9k6mBGRy-gzGzoHsz',
    appKey: '5lIjR9cSntdE9MvI7DIf55Xn',
    placeholder: "ヾﾉ≧∀≦)o 来呀！吐槽一番吧！",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
