<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="那年星空" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="高级运算符定义自定义运算符、执行位运算和使用构建器语法。 除了doc:BasicOperators中描述的运算符外,Swift 还提供了几种执行更复杂值操作的高级运算符。这些包括您在 C 和 Objective-C 中熟悉的所有位运算符和移位运算符。 与 C 中的算术运算符不同,Swift 中的算术运算符默认不会溢出。溢出行为会被捕获并报告为错误。要选择溢出行为，请使用 Swift 的第二组默认溢">
<meta property="og:type" content="website">
<meta property="og:title" content="那年星空">
<meta property="og:url" content="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AdvancedOperators.html">
<meta property="og:site_name" content="那年星空">
<meta property="og:description" content="高级运算符定义自定义运算符、执行位运算和使用构建器语法。 除了doc:BasicOperators中描述的运算符外,Swift 还提供了几种执行更复杂值操作的高级运算符。这些包括您在 C 和 Objective-C 中熟悉的所有位运算符和移位运算符。 与 C 中的算术运算符不同,Swift 中的算术运算符默认不会溢出。溢出行为会被捕获并报告为错误。要选择溢出行为，请使用 Swift 的第二组默认溢">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AdvancedOperators/bitwiseNOT">
<meta property="og:image" content="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AdvancedOperators/bitwiseAND">
<meta property="og:image" content="https://wanflutter.netlify.app/bitwiseOR">
<meta property="og:image" content="https://wanflutter.netlify.app/bitwiseXOR">
<meta property="og:image" content="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AdvancedOperators/bitshiftUnsigned">
<meta property="og:image" content="https://wanflutter.netlify.app/bitshiftSignedFour">
<meta property="og:image" content="https://wanflutter.netlify.app/bitshiftSignedMinusFour">
<meta property="og:image" content="https://wanflutter.netlify.app/bitshiftSignedMinusFourValue">
<meta property="og:image" content="https://wanflutter.netlify.app/bitshiftSignedAddition">
<meta property="og:image" content="https://wanflutter.netlify.app/bitshiftSigned">
<meta property="og:image" content="https://wanflutter.netlify.app/overflowAddition">
<meta property="og:image" content="https://wanflutter.netlify.app/overflowUnsignedSubtraction">
<meta property="og:image" content="https://wanflutter.netlify.app/overflowSignedSubtraction">
<meta property="og:image" content="https://wanflutter.netlify.app/vectorAddition">
<meta property="article:published_time" content="2025-03-08T08:32:48.692Z">
<meta property="article:modified_time" content="2025-03-08T08:32:48.692Z">
<meta property="article:author" content="joe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AdvancedOperators/bitwiseNOT">

<link rel="canonical" href="https://wanflutter.netlify.app/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AdvancedOperators">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | 那年星空
  </title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6ad7c0c3175207d3b8885d6a63355af1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">那年星空</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content">
            

  <div class="posts-expand">
    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/course/">COURSE</a></li>
            <li><a href="/course/ios/">IOS</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/">THE-SWIFT-PROGRAMMING-LANGUAGE-IN-CHINESE-6.0</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/">LANGUAGEGUIDE</a></li>
            <li>ADVANCEDOPERATORS</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <html><head></head><body></body></html><html><head></head><body><h1 id="高级运算符"><a href="#高级运算符" class="headerlink" title="高级运算符"></a>高级运算符</h1><p>定义自定义运算符、执行位运算和使用构建器语法。</p>
<p>除了<a href="doc:BasicOperators">doc:BasicOperators</a>中描述的运算符外,Swift 还提供了几种执行更复杂值操作的高级运算符。这些包括您在 C 和 Objective-C 中熟悉的所有位运算符和移位运算符。</p>
<p>与 C 中的算术运算符不同,Swift 中的算术运算符默认不会溢出。溢出行为会被捕获并报告为错误。要选择溢出行为，请使用 Swift 的第二组默认溢出的算术运算符，例如溢出加法运算符（ <code>&amp;+</code> ）。所有这些溢出运算符都以 <code>&amp;</code> 符号开头。</p>
<p>当您定义自己的结构体、类和枚举时，为这些自定义类型提供 Swift 标准运算符的自己实现可能会很有用。Swift 使为这些运算符提供量身定制的实现变得容易，并可以精确地确定它们对您创建的每种类型的行为应该是什么。</p>
<p>您并不局限于预定义的运算符。Swift 给予您自由定义自己的自定义中缀、前缀、后缀和赋值运算符的能力，并带有自定义优先级和结合性值。这些运算符可以像任何预定义运算符一样在您的代码中使用和采用，您甚至可以扩展现有类型以支持您定义的自定义运算符。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><strong>位运算符</strong> 使您能够操作数据结构内的单个原始数据位。它们经常用于底层编程，如图形编程和设备驱动程序创建。当您处理来自外部源的原始数据时，位运算符也可能很有用，例如为通过自定义协议进行通信而编码和解码数据。</p>
<p>Swift 支持 C 中的所有位运算符，如下所述。</p>
<h3 id="按位取反运算符"><a href="#按位取反运算符" class="headerlink" title="按位取反运算符"></a>按位取反运算符</h3><p><strong>按位取反运算符</strong> （ <code>~</code> ）对一个数字中的所有位进行取反：</p>
<p><img src="/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AdvancedOperators/bitwiseNOT"></p>
<p>按位取反运算符是一个前缀运算符，它出现在其操作的值之前，中间没有任何空格：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initialBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00001111</span></span><br><span class="line"><span class="keyword">let</span> invertedBits <span class="operator">=</span> <span class="operator">~</span>initialBits  <span class="comment">// equals 11110000</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `bitwiseOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let initialBits: UInt8 = 0b00001111</span><br><span class="line">&gt;&gt; assert(initialBits == 15)</span><br><span class="line">-&gt; let invertedBits = ~initialBits  // equals 11110000</span><br><span class="line">&gt;&gt; assert(invertedBits == 240)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>UInt8</code> 整数有八位，可以存储 <code>0</code> 到 <code>255</code> 之间的任何值。这个例子用二进制值 <code>00001111</code> 初始化一个 <code>UInt8</code> 整数，其前四位设置为 <code>0</code> ，后四位设置为 <code>1</code> 。这相当于十进制值 <code>15</code> 。</p>
<!-- Apple Books screenshot begins here. -->

<p>然后使用按位取反运算符创建一个名为 <code>invertedBits</code> 的新常量，它等于 <code>initialBits</code> ，但所有位都被取反。零变成一，一变成零。<code>invertedBits</code> 的值是 <code>11110000</code> ，等于无符号十进制值 <code>240</code> 。</p>
<h3 id="按位与运算符"><a href="#按位与运算符" class="headerlink" title="按位与运算符"></a>按位与运算符</h3><p><strong>按位与运算符</strong> (<code>&amp;</code> ）组合两个数字的位。它返回一个新数字，只有在两个输入数字中相应的位都等于 1 时，新数字的相应位才设置为 1:</p>
<p><img src="/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AdvancedOperators/bitwiseAND"></p>
<p>在下面的例子中，<code>firstSixBits</code> 和 <code>lastSixBits</code> 的值在中间四位都等于 <code>1</code> 。按位与运算符将它们组合成数字 <code>00111100</code> ，等于无符号十进制值 <code>60</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstSixBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b11111100</span></span><br><span class="line"><span class="keyword">let</span> lastSixBits: <span class="type">UInt8</span>  <span class="operator">=</span> <span class="number">0b00111111</span></span><br><span class="line"><span class="keyword">let</span> middleFourBits <span class="operator">=</span> firstSixBits <span class="operator">&amp;</span> lastSixBits  <span class="comment">// equals 00111100</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `bitwiseOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let firstSixBits: UInt8 = 0b11111100</span><br><span class="line">-&gt; let lastSixBits: UInt8  = 0b00111111</span><br><span class="line">-&gt; let middleFourBits = firstSixBits &amp; lastSixBits  // equals 00111100</span><br><span class="line">&gt;&gt; assert(middleFourBits == 0b00111100)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="按位或运算符"><a href="#按位或运算符" class="headerlink" title="按位或运算符"></a>按位或运算符</h3><p><strong>按位或运算符</strong> （ <code>|</code> ）比较两个数字的位。如果 <strong>任一</strong> 输入数字中的位等于 <code>1</code> ，则运算符返回一个新数字，其相应位设置为 <code>1</code> ：</p>
<p><img src="/bitwiseOR"></p>
<!-- Apple Books screenshot ends here. -->

<p>在下面的例子中， <code>someBits</code> 和 <code>moreBits</code> 的值在不同的位上设置为 <code>1</code> 。按位或运算符将它们组合成数字 <code>11111110</code> ，等于无符号十进制值 <code>254</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b10110010</span></span><br><span class="line"><span class="keyword">let</span> moreBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b01011110</span></span><br><span class="line"><span class="keyword">let</span> combinedbits <span class="operator">=</span> someBits <span class="operator">|</span> moreBits  <span class="comment">// equals 11111110</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `bitwiseOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let someBits: UInt8 = 0b10110010</span><br><span class="line">-&gt; let moreBits: UInt8 = 0b01011110</span><br><span class="line">-&gt; let combinedbits = someBits | moreBits  // equals 11111110</span><br><span class="line">&gt;&gt; assert(combinedbits == 0b11111110)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="按位异或运算符"><a href="#按位异或运算符" class="headerlink" title="按位异或运算符"></a>按位异或运算符</h3><p><strong>按位异或运算符</strong> ，或 “异或运算符” （ <code>^</code> ），比较两个数字的位。运算符返回一个新数字，在输入位不同的地方，新数字的相应位设置为 <code>1</code> ，在输入位相同的地方，新数字的相应位设置为 <code>0</code> :</p>
<p><img src="/bitwiseXOR"></p>
<p>在下面的例子中， <code>firstBits</code> 和 <code>otherBits</code> 的值在对方没有的位置各有一位设置为 <code>1</code> 。按位异或运算符在其输出值中将这两位都设置为 <code>1</code> 。<code>firstBits</code> 和 <code>otherBits</code> 中的所有其他位都匹配，在输出值中设置为 <code>0</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00010100</span></span><br><span class="line"><span class="keyword">let</span> otherBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00000101</span></span><br><span class="line"><span class="keyword">let</span> outputBits <span class="operator">=</span> firstBits <span class="operator">^</span> otherBits  <span class="comment">// equals 00010001</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `bitwiseOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let firstBits: UInt8 = 0b00010100</span><br><span class="line">-&gt; let otherBits: UInt8 = 0b00000101</span><br><span class="line">-&gt; let outputBits = firstBits ^ otherBits  // equals 00010001</span><br><span class="line">&gt;&gt; assert(outputBits == 0b00010001)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="按位左移和右移运算符"><a href="#按位左移和右移运算符" class="headerlink" title="按位左移和右移运算符"></a>按位左移和右移运算符</h3><p><strong>按位左移运算符</strong> (<code>&lt;&lt;</code> ）和 <strong>按位右移运算符</strong> (<code>&gt;&gt;</code> ）根据下面定义的规则，将数字中的所有位向左或向右移动特定数量的位置。</p>
<p>按位左移和右移相当于将整数乘以或除以 2 的幂。将整数的位向左移动一位会使其值翻倍，而向右移动一位会将其值减半。</p>
<!--
  TODO: mention the caveats to this claim.
-->

<h4 id="无符号整数的移位行为"><a href="#无符号整数的移位行为" class="headerlink" title="无符号整数的移位行为"></a>无符号整数的移位行为</h4><p>无符号整数的位移行为如下：</p>
<ol>
<li>现有的位按请求的位数向左或向右移动。</li>
<li>任何移动超出整数存储边界的位都会被丢弃。</li>
<li>在原始位向左或向右移动后留下的空位中插入零。</li>
</ol>
<p>这种方法被称为 <strong>逻辑移位</strong>。</p>
<p>下图显示了 <code>11111111 &lt;&lt; 1</code> (即 <code>11111111</code> 向左移动 1 位）和 <code>11111111 &gt;&gt; 1</code> (即 <code>11111111</code> 向右移动 1 位）的结果。绿色数字是移位的，灰色数字被丢弃，插入的粉色零：</p>
<p><img src="/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/AdvancedOperators/bitshiftUnsigned"></p>
<p>以下是 Swift 代码中位移的样子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shiftBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">4</span>   <span class="comment">// 00000100 in binary</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">1</span>             <span class="comment">// 00001000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">2</span>             <span class="comment">// 00010000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">5</span>             <span class="comment">// 10000000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">6</span>             <span class="comment">// 00000000</span></span><br><span class="line">shiftBits <span class="operator">&gt;&gt;</span> <span class="number">2</span>             <span class="comment">// 00000001</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `bitwiseShiftOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let shiftBits: UInt8 = 4   // 00000100 in binary</span><br><span class="line">&gt;&gt; let r0 =</span><br><span class="line">-&gt; shiftBits &lt;&lt; 1             // 00001000</span><br><span class="line">&gt;&gt; assert(r0 == 8)</span><br><span class="line">&gt;&gt; let r1 =</span><br><span class="line">-&gt; shiftBits &lt;&lt; 2             // 00010000</span><br><span class="line">&gt;&gt; assert(r1 == 16)</span><br><span class="line">&gt;&gt; let r2 =</span><br><span class="line">-&gt; shiftBits &lt;&lt; 5             // 10000000</span><br><span class="line">&gt;&gt; assert(r2 == 128)</span><br><span class="line">&gt;&gt; let r3 =</span><br><span class="line">-&gt; shiftBits &lt;&lt; 6             // 00000000</span><br><span class="line">&gt;&gt; assert(r3 == 0)</span><br><span class="line">&gt;&gt; let r4 =</span><br><span class="line">-&gt; shiftBits &gt;&gt; 2             // 00000001</span><br><span class="line">&gt;&gt; assert(r4 == 1)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  Rewrite the above to avoid bare expressions.
  Tracking bug is <rdar://problem/35301593>
-->

<p>您可以使用位移来编码和解码其他数据类型中的值：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pink: <span class="type">UInt32</span> <span class="operator">=</span> <span class="number">0xCC6699</span></span><br><span class="line"><span class="keyword">let</span> redComponent <span class="operator">=</span> (pink <span class="operator">&amp;</span> <span class="number">0xFF0000</span>) <span class="operator">&gt;&gt;</span> <span class="number">16</span>    <span class="comment">// redComponent is 0xCC, or 204</span></span><br><span class="line"><span class="keyword">let</span> greenComponent <span class="operator">=</span> (pink <span class="operator">&amp;</span> <span class="number">0x00FF00</span>) <span class="operator">&gt;&gt;</span> <span class="number">8</span>   <span class="comment">// greenComponent is 0x66, or 102</span></span><br><span class="line"><span class="keyword">let</span> blueComponent <span class="operator">=</span> pink <span class="operator">&amp;</span> <span class="number">0x0000FF</span>           <span class="comment">// blueComponent is 0x99, or 153</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `bitwiseShiftOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let pink: UInt32 = 0xCC6699</span><br><span class="line">-&gt; let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16    // redComponent is 0xCC, or 204</span><br><span class="line">-&gt; let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8   // greenComponent is 0x66, or 102</span><br><span class="line">-&gt; let blueComponent = pink &amp; 0x0000FF           // blueComponent is 0x99, or 153</span><br><span class="line">&gt;&gt; assert(redComponent == 204)</span><br><span class="line">&gt;&gt; assert(greenComponent == 102)</span><br><span class="line">&gt;&gt; assert(blueComponent == 153)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>这个例子使用一个名为 <code>pink</code> 的 <code>UInt32</code> 常量来存储粉红色的级联样式表（CSS）颜色值。CSS 颜色值 <code>#CC6699</code> 在 Swift 的十六进制数字表示中写作 <code>0xCC6699</code> 。然后，通过按位与运算符（ <code>&amp;</code> ）和按位右移运算符（ <code>&gt;&gt;</code> ）将这个颜色分解为红（ <code>CC</code> ）、绿（ <code>66</code> ）和蓝（ <code>99</code> ）分量。</p>
<p>红色分量是通过对数字 <code>0xCC6699</code> 和 <code>0xFF0000</code> 执行按位与运算得到的。<code>0xFF0000</code> 中的零有效地”掩蔽”了 <code>0xCC6699</code> 的第二和第三个字节，导致 <code>6699</code> 被忽略，留下 <code>0xCC0000</code> 作为结果。</p>
<p>然后，这个数字向右移动 16 位（ <code>&gt;&gt; 16</code>)。十六进制数中的每对字符使用 8 位，所以向右移动 16 位会将 <code>0xCC0000</code> 转换为 <code>0x0000CC</code> 。这与 <code>0xCC</code> 相同，十进制值为 204。</p>
<p>类似地，绿色分量是通过对数字 <code>0xCC6699</code> 和 <code>0x00FF00</code> 执行按位与运算得到的，得到输出值 <code>0x006600</code> 。然后将这个输出值向右移动八位，得到值 <code>0x66</code> ，十进制值为 102。</p>
<p>最后，蓝色分量是通过对数字 <code>0xCC6699</code> 和 <code>0x0000FF</code> 执行按位与运算得到的，得到输出值 <code>0x000099</code> 。因为 <code>0x000099</code> 已经等于 <code>0x99</code> ，十进制值为 153,所以这个值不需要向右移位就可以使用。</p>
<h4 id="有符号整数的移位行为"><a href="#有符号整数的移位行为" class="headerlink" title="有符号整数的移位行为"></a>有符号整数的移位行为</h4><p>有符号整数的移位行为比无符号整数更复杂，因为有符号整数在二进制中的表示方式。(为简单起见，下面的例子基于 8 位有符号整数，但相同的原理适用于任何大小的有符号整数。)</p>
<p>有符号整数使用它们的第一位（称为 <strong>符号位</strong> ）来表示整数是正数还是负数。符号位为 0 表示正数，符号位为 1 表示负数。</p>
<p>剩余的位（称为 <strong>值位</strong> ）存储实际值。正数的存储方式与无符号整数完全相同，从 0 开始向上计数。以下是 <code>Int8</code> 中数字 4 的位的样子：</p>
<p><img src="/bitshiftSignedFour"></p>
<p>符号位是 0(表示”正”),七个值位只是数字 4 的二进制表示。</p>
<p>然而，负数的存储方式不同。它们通过从 2 的 n 次方中减去它们的绝对值来存储，其中 n 是值位的数量。8 位数字有 7 个值位，所以这意味着 2 的 7 次方，即 128。</p>
<p>以下是数字 -4 在 Int8 类型中的二进制表示形式：</p>
<p><img src="/bitshiftSignedMinusFour"></p>
<p>这次，符号位是 <code>1</code>(表示”负数”),七个值位的二进制值是 <code>124</code>(即 <code>128 - 4</code>):</p>
<p><img src="/bitshiftSignedMinusFourValue"></p>
<p>这种编码负数的方法被称为 <strong>二进制补码</strong> 表示。虽然这看起来是一种不寻常的表示负数的方式，但它有几个优点。</p>
<p>首先，你可以将 <code>-1</code> 加到 <code>-4</code> 上，只需对所有八个位（包括符号位）执行标准的二进制加法，并在完成后丢弃任何不适合八位的内容：</p>
<p><img src="/bitshiftSignedAddition"></p>
<p>其次，二进制补码表示还允许你像正数一样将负数的位向左和向右移动，并且每向左移动一位仍然会使其加倍，每向右移动一位则会将其减半。为了实现这一点，在对有符号整数进行右移时使用了一个额外的规则：当你将有符号整数向右移动时，应用与无符号整数相同的规则，但用 <strong>符号位</strong> 填充左侧的任何空位，而不是用零填充。</p>
<p><img src="/bitshiftSigned"></p>
<p>这个操作确保了有符号整数在向右移动后保持相同的符号，这被称为 <strong>算术移位</strong>。</p>
<p>由于正数和负数的存储方式特殊，将它们中的任何一个向右移动都会使它们更接近零。在这个移位过程中保持符号位不变意味着负整数在其值接近零时仍然保持为负数。</p>
<h2 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h2><p>如果你试图将一个数字插入到无法容纳该值的整数常量或变量中，默认情况下 Swift 会报告一个错误，而不是允许创建一个无效的值。当你处理太大或太小的数字时，这种行为提供了额外的安全性。</p>
<p>例如，<code>Int16</code> 整数类型可以保存介于 <code>-32768</code> 和 <code>32767</code> 之间的任何有符号整数。试图将 <code>Int16</code> 常量或变量设置为超出此范围的数字会导致错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> potentialOverflow <span class="operator">=</span> <span class="type">Int16</span>.max</span><br><span class="line"><span class="comment">// potentialOverflow 等于 32767,这是 Int16 可以容纳的最大值</span></span><br><span class="line">potentialOverflow <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// this causes an error</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `overflowOperatorsWillFailToOverflow`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; var potentialOverflow = Int16.max</span><br><span class="line">/&gt; potentialOverflow equals \(potentialOverflow), which is the maximum value an Int16 can hold</span><br><span class="line">&lt;/ potentialOverflow equals 32767, which is the maximum value an Int16 can hold</span><br><span class="line">-&gt; potentialOverflow += 1</span><br><span class="line">xx overflow</span><br><span class="line">// this causes an error</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>当值变得过大或过小时提供错误处理，可以让你在编写边界值条件时拥有更大的灵活性。</p>
<p>然而，当你特别希望溢出条件截断可用位数时，你可以选择这种行为而不会触发错误。Swift 提供了三个算术 <strong>溢出运算符</strong>,可以选择整数计算的溢出行为。这些运算符都以 &amp; 符号开头：</p>
<ul>
<li>溢出加法（ <code>&amp;+</code>)</li>
<li>溢出减法（ <code>&amp;-</code>)</li>
<li>溢出乘法（ <code>&amp;*</code>)</li>
</ul>
<h3 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h3><p>数字可以在正方向和负方向上溢出。</p>
<p>这里有一个例子，展示了当允许无符号整数在正方向上溢出时会发生什么，使用溢出加法运算符（ <code>&amp;+</code>):</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow <span class="operator">=</span> <span class="type">UInt8</span>.max</span><br><span class="line"><span class="comment">// unsignedOverflow 等于 255,这是 UInt8 可以容纳的最大值</span></span><br><span class="line">unsignedOverflow <span class="operator">=</span> unsignedOverflow <span class="operator">&amp;+</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// unsignedOverflow 现在等于 0</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `overflowOperatorsWillOverflowInPositiveDirection`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; var unsignedOverflow = UInt8.max</span><br><span class="line">/&gt; unsignedOverflow equals \(unsignedOverflow), which is the maximum value a UInt8 can hold</span><br><span class="line">&lt;/ unsignedOverflow equals 255, which is the maximum value a UInt8 can hold</span><br><span class="line">-&gt; unsignedOverflow = unsignedOverflow &amp;+ 1</span><br><span class="line">/&gt; unsignedOverflow is now equal to \(unsignedOverflow)</span><br><span class="line">&lt;/ unsignedOverflow is now equal to 0</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>变量 <code>unsignedOverflow</code> 被初始化为 <code>UInt8</code> 可以容纳的最大值(<code>255</code> ，或二进制的 <code>11111111</code>)。然后使用溢出加法运算符（ <code>&amp;+</code> ）将其加 1。这将其二进制表示推到了 <code>UInt8</code> 可以容纳的大小之外，导致它溢出超出其边界，如下图所示。溢出加法后留在 <code>UInt8</code> 边界内的值是 <code>00000000</code> ，或零。</p>
<p><img src="/overflowAddition"></p>
<p>当允许无符号整数在负方向上溢出时，也会发生类似的情况。这里有一个使用溢出减法运算符（ <code>&amp;-</code> ）的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow <span class="operator">=</span> <span class="type">UInt8</span>.min</span><br><span class="line"><span class="comment">// unsignedOverflow 等于 0,这是 UInt8 可以容纳的最小值</span></span><br><span class="line">unsignedOverflow <span class="operator">=</span> unsignedOverflow <span class="operator">&amp;-</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// unsignedOverflow 现在等于 255</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `overflowOperatorsWillOverflowInNegativeDirection`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; var unsignedOverflow = UInt8.min</span><br><span class="line">/&gt; unsignedOverflow equals \(unsignedOverflow), which is the minimum value a UInt8 can hold</span><br><span class="line">&lt;/ unsignedOverflow equals 0, which is the minimum value a UInt8 can hold</span><br><span class="line">-&gt; unsignedOverflow = unsignedOverflow &amp;- 1</span><br><span class="line">/&gt; unsignedOverflow is now equal to \(unsignedOverflow)</span><br><span class="line">&lt;/ unsignedOverflow is now equal to 255</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>UInt8</code> 可以容纳的最小值是零，或二进制的 <code>00000000</code> 。如果你使用溢出减法运算符（ <code>&amp;-</code> ）从 <code>00000000</code> 中减去 1,这个数字将会溢出并绕回到 <code>11111111</code> ，或十进制的 <code>255</code> 。</p>
<p><img src="/overflowUnsignedSubtraction"></p>
<p>有符号整数也会发生溢出。所有有符号整数的加法和减法都以按位方式执行，符号位作为被加或被减数字的一部分包含在内，如 <a href="doc:AdvancedOperators#按位左移和右移运算符">doc:AdvancedOperators#按位左移和右移运算符</a> 中所述。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> signedOverflow <span class="operator">=</span> <span class="type">Int8</span>.min</span><br><span class="line"><span class="comment">// signedOverflow 等于 -128,这是 Int8 可以容纳的最小值</span></span><br><span class="line">signedOverflow <span class="operator">=</span> signedOverflow <span class="operator">&amp;-</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// signedOverflow 现在等于 127</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `overflowOperatorsWillOverflowSigned`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; var signedOverflow = Int8.min</span><br><span class="line">/&gt; signedOverflow equals \(signedOverflow), which is the minimum value an Int8 can hold</span><br><span class="line">&lt;/ signedOverflow equals -128, which is the minimum value an Int8 can hold</span><br><span class="line">-&gt; signedOverflow = signedOverflow &amp;- 1</span><br><span class="line">/&gt; signedOverflow is now equal to \(signedOverflow)</span><br><span class="line">&lt;/ signedOverflow is now equal to 127</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>Int8</code> 可以容纳的最小值是 <code>-128</code> ，或二进制的 <code>10000000</code> 。使用溢出运算符从这个二进制数中减去 1 得到二进制值 <code>01111111</code> ，这会切换符号位并得到正 <code>127</code> ，这是 <code>Int8</code> 可以容纳的最大正值。</p>
<p><img src="/overflowSignedSubtraction"></p>
<p>对于有符号和无符号整数，正方向的溢出会从最大有效整数值绕回到最小值，而负方向的溢出会从最小值绕回到最大值。</p>
<h2 id="优先级和结合性"><a href="#优先级和结合性" class="headerlink" title="优先级和结合性"></a>优先级和结合性</h2><p>运算符 <strong>优先级</strong> 给予某些运算符比其他运算符更高的优先级;这些运算符会首先被应用。</p>
<p>运算符 <strong>结合性</strong> 定义了具有相同优先级的运算符如何组合在一起 — 要么从左边组合，要么从右边组合。可以将其理解为”它们与左边的表达式相关联”,或”它们与右边的表达式相关联”。</p>
<p>在计算复合表达式的顺序时，考虑每个运算符的优先级和结合性很重要。例如，运算符优先级解释了为什么下面的表达式等于 <code>17</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span> <span class="operator">%</span> <span class="number">4</span> <span class="operator">*</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 这等于 17</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `evaluationOrder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; let r0 =</span><br><span class="line">-&gt; 2 + 3 % 4 * 5</span><br><span class="line">&gt;&gt; assert(r0 == 17)</span><br><span class="line">/&gt; this equals \(2 + 3 % 4 * 5)</span><br><span class="line">&lt;/ this equals 17</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  Rewrite the above to avoid bare expressions.
  Tracking bug is <rdar://problem/35301593>
-->

<p>如果你严格从左到右读，你可能会期望表达式按如下方式计算：</p>
<ul>
<li><code>2</code> 加 <code>3</code> 等于 <code>5</code></li>
<li><code>5</code> 除以 <code>4</code> 余 <code>1</code></li>
<li><code>1</code> 乘以 <code>5</code> 等于 <code>5</code></li>
</ul>
<p>然而，实际答案是 <code>17</code> ，而不是 <code>5</code> 。优先级更高的运算符在优先级较低的运算符之前被计算。在 Swift 中，就像在 C 语言中一样，余数运算符（ <code>%</code> ）和乘法运算符（ <code>*</code> ）的优先级高于加法运算符（ <code>+</code>)。因此，它们都在考虑加法之前被计算。</p>
<p>然而，余数和乘法具有 <strong>相同</strong> 的优先级。要确定使用的确切计算顺序，你还需要考虑它们的结合性。余数和乘法都与它们左边的表达式相关联。可以将其理解为在表达式的这些部分周围添加隐式括号，从左边开始：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> ((<span class="number">3</span> <span class="operator">%</span> <span class="number">4</span>) <span class="operator">*</span> <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `evaluationOrder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; let r1 =</span><br><span class="line">-&gt; 2 + ((3 % 4) * 5)</span><br><span class="line">&gt;&gt; assert(r1 == 17)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  Rewrite the above to avoid bare expressions.
  Tracking bug is <rdar://problem/35301593>
-->

<p><code>(3 % 4)</code> is <code>3</code>, so this is equivalent to:</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> (<span class="number">3</span> <span class="operator">*</span> <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `evaluationOrder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; let r2 =</span><br><span class="line">-&gt; 2 + (3 * 5)</span><br><span class="line">&gt;&gt; assert(r2 == 17)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  Rewrite the above to avoid bare expressions.
  Tracking bug is <rdar://problem/35301593>
-->

<p><code>(3 * 5)</code> is <code>15</code>, so this is equivalent to:</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> <span class="number">15</span></span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `evaluationOrder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; let r3 =</span><br><span class="line">-&gt; 2 + 15</span><br><span class="line">&gt;&gt; assert(r3 == 17)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
  Rewrite the above to avoid bare expressions.
  Tracking bug is <rdar://problem/35301593>
-->

<p>这个计算得出的最终答案是 <code>17</code> 。</p>
<p>有关 Swift 标准库提供的运算符的信息，包括运算符优先级组和结合性设置的完整列表，请参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/operator_declarations">运算符声明</a>。</p>
<blockquote>
<p>注意：Swift 的运算符优先级和结合性规则比 C 和 Objective-C 中的更简单和可预测。 然而，这意味着它们与基于 C 的语言并不完全相同。 在将现有代码移植到 Swift 时，请注意确保运算符交互仍然按照您预期的方式运行。</p>
</blockquote>
<h2 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h2><p>类和结构体可以为现有运算符提供自定义的实现。这被称为 <strong>重载</strong> 现有运算符。</p>
<p>下面的示例展示了如何为自定义结构体实现算术加法运算符（ <code>+</code> ）。算术加法运算符是一个二元运算符，因为它操作两个目标，并且它是一个中缀运算符，因为它出现在这两个目标之间。</p>
<p>该示例定义了一个 <code>Vector2D</code> 结构体，用于表示二维位置向量 <code>(x, y)</code> ，然后定义了一个 <strong>运算符方法</strong> 来将 <code>Vector2D</code> 结构体的实例相加：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2D</span> {</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">+</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> {</span><br><span class="line">       <span class="keyword">return</span> <span class="type">Vector2D</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">+</span> right.y)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; struct Vector2D &#123;</span><br><span class="line">      var x = 0.0, y = 0.0</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; extension Vector2D &#123;</span><br><span class="line">       static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">          return Vector2D(x: left.x + right.x, y: left.y + right.y)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>运算符方法被定义为 <code>Vector2D</code> 的类型方法，方法名称与要重载的运算符（ <code>+</code> ）相匹配。 由于加法不是向量的基本行为，所以类型方法在 <code>Vector2D</code> 的扩展中定义，而不是在 <code>Vector2D</code> 的主结构声明中定义。 因为算术加法运算符是一个二元运算符，所以这个运算符方法接受两个类型为 <code>Vector2D</code> 的输入参数，并返回一个单一的输出值，也是 <code>Vector2D</code> 类型。</p>
<p>在这个实现中，输入参数被命名为 <code>left</code> 和 <code>right</code> ，代表 <code>+</code> 运算符左侧和右侧的 <code>Vector2D</code> 实例。 该方法返回一个新的 <code>Vector2D</code> 实例，其 <code>x</code> 和 <code>y</code> 属性初始化为相加的两个 <code>Vector2D</code> 实例的 <code>x</code> 和 <code>y</code> 属性之和。</p>
<p>这个类型方法可以作为现有 <code>Vector2D</code> 实例之间的中缀运算符使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> combinedVector <span class="operator">=</span> vector <span class="operator">+</span> anotherVector</span><br><span class="line"><span class="comment">// combinedVector 是一个 Vector2D 实例，值为 (5.0, 5.0)</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let vector = Vector2D(x: 3.0, y: 1.0)</span><br><span class="line">-&gt; let anotherVector = Vector2D(x: 2.0, y: 4.0)</span><br><span class="line">-&gt; let combinedVector = vector + anotherVector</span><br><span class="line">/&gt; combinedVector is a Vector2D instance with values of (\(combinedVector.x), \(combinedVector.y))</span><br><span class="line">&lt;/ combinedVector is a Vector2D instance with values of (5.0, 5.0)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>这个例子将向量 <code>(3.0, 1.0)</code> 和 <code>(2.0, 4.0)</code> 相加，得到向量 <code>(5.0, 5.0)</code> ，如下图所示。</p>
<p><img src="/vectorAddition"></p>
<h3 id="前缀和后缀运算符"><a href="#前缀和后缀运算符" class="headerlink" title="前缀和后缀运算符"></a>前缀和后缀运算符</h3><p>上面的例子展示了自定义实现二元中缀运算符。 类和结构体还可以提供标准 <strong>一元运算符</strong> 的实现。 一元运算符操作单个目标。 如果它们在目标之前，则是 <strong>前缀</strong> 运算符（如 <code>-a</code> ），如果在目标之后，则是 <strong>后缀</strong> 运算符（如 <code>b!</code> ）。</p>
<p>通过在声明运算符方法时在 <code>func</code> 关键字之前写入 <code>prefix</code> 或 <code>postfix</code> 修饰符来实现前缀或后缀一元运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="keyword">func</span> <span class="title function_">-</span> (<span class="params">vector</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="operator">-</span>vector.x, y: <span class="operator">-</span>vector.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; extension Vector2D &#123;</span><br><span class="line">       static prefix func - (vector: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">           return Vector2D(x: -vector.x, y: -vector.y)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>上面的例子为 <code>Vector2D</code> 实例实现了一元减运算符（ <code>-a</code> ）。 一元减运算符是一个前缀运算符，因此这个方法必须用 <code>prefix</code> 修饰符限定。</p>
<p>对于简单的数值，一元减运算符将正数转换为其负数等价物，反之亦然。 <code>Vector2D</code> 实例的相应实现对 <code>x</code> 和 <code>y</code> 属性执行此操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positive <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> negative <span class="operator">=</span> <span class="operator">-</span>positive</span><br><span class="line"><span class="comment">// negative 是一个 Vector2D 实例，值为 (-3.0, -4.0)</span></span><br><span class="line"><span class="keyword">let</span> alsoPositive <span class="operator">=</span> <span class="operator">-</span>negative</span><br><span class="line"><span class="comment">// alsoPositive 是一个 Vector2D 实例，值为 (3.0, 4.0)</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let positive = Vector2D(x: 3.0, y: 4.0)</span><br><span class="line">-&gt; let negative = -positive</span><br><span class="line">/&gt; negative is a Vector2D instance with values of (\(negative.x), \(negative.y))</span><br><span class="line">&lt;/ negative is a Vector2D instance with values of (-3.0, -4.0)</span><br><span class="line">-&gt; let alsoPositive = -negative</span><br><span class="line">/&gt; alsoPositive is a Vector2D instance with values of (\(alsoPositive.x), \(alsoPositive.y))</span><br><span class="line">&lt;/ alsoPositive is a Vector2D instance with values of (3.0, 4.0)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p><strong>复合赋值运算符</strong> 将赋值（ <code>=</code> ）与另一个操作结合在一起。 例如，加法赋值运算符（ <code>+=</code> ）将加法和赋值组合成一个操作。 你将复合赋值运算符的左输入参数类型标记为 <code>inout</code> ，因为参数的值将直接从运算符方法内部修改。</p>
<p>下面的例子为 <code>Vector2D</code> 实例实现了一个加法赋值运算符方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">+=</span> (<span class="params">left</span>: <span class="keyword">inout</span> <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) &#123;</span><br><span class="line">        left <span class="operator">=</span> left <span class="operator">+</span> right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; extension Vector2D &#123;</span><br><span class="line">       static func += (left: inout Vector2D, right: Vector2D) &#123;</span><br><span class="line">           left = left + right</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>因为之前定义了加法运算符，所以这里不需要重新实现加法过程。 相反，加法赋值运算符方法利用现有的加法运算符方法，并使用它将左值设置为左值加右值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> vectorToAdd <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line">original <span class="operator">+=</span> vectorToAdd</span><br><span class="line"><span class="comment">// original 现在的值为 (4.0, 6.0)</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; var original = Vector2D(x: 1.0, y: 2.0)</span><br><span class="line">-&gt; let vectorToAdd = Vector2D(x: 3.0, y: 4.0)</span><br><span class="line">-&gt; original += vectorToAdd</span><br><span class="line">/&gt; original now has values of (\(original.x), \(original.y))</span><br><span class="line">&lt;/ original now has values of (4.0, 6.0)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<blockquote>
<p>注意：不能重载默认赋值运算符（ <code>=</code> ）。 只有复合赋值运算符可以被重载。 同样，三元条件运算符（ <code>a ? b : c</code> ）也不能被重载。</p>
</blockquote>
<!--
  - test: `cant-overload-assignment`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; struct Vector2D &#123;</span><br><span class="line">&gt;&gt;    var x = 0.0, y = 0.0</span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line">&gt;&gt; extension Vector2D &#123;</span><br><span class="line">&gt;&gt;     static func = (left: inout Vector2D, right: Vector2D) &#123;</span><br><span class="line">&gt;&gt;         left = right</span><br><span class="line">&gt;&gt;     &#125;</span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line">!$ error: expected identifier in function declaration</span><br><span class="line">!! static func = (left: inout Vector2D, right: Vector2D) &#123;</span><br><span class="line">!!             ^</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="等价运算符"><a href="#等价运算符" class="headerlink" title="等价运算符"></a>等价运算符</h3><p>默认情况下，自定义类和结构体没有 <strong>等价运算符</strong> 的实现，这些运算符包括 <strong>相等</strong> 运算符（ <code>==</code> ）和 <strong>不相等</strong> 运算符（ <code>!=</code> ）。通常你需要实现 <code>==</code> 运算符，并使用 Swift 标准库的默认 <code>!=</code> 运算符实现，它会对 <code>==</code> 运算符的结果进行取反。 有两种方法可以实现 <code>==</code> 运算符：你可以自己实现它，或者对于许多类型，你可以要求 Swift 为你合成一个实现。 在这两种情况下，你都需要添加对 Swift 标准库的 <code>Equatable</code> 协议的遵循。</p>
<p>你可以像实现其他中缀运算符一样提供 <code>==</code> 运算符的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (left.x <span class="operator">==</span> right.x) <span class="operator">&amp;&amp;</span> (left.y <span class="operator">==</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; extension Vector2D: Equatable &#123;</span><br><span class="line">       static func == (left: Vector2D, right: Vector2D) -&gt; Bool &#123;</span><br><span class="line">          return (left.x == right.x) &amp;&amp; (left.y == right.y)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>上面的例子实现了一个 <code>==</code> 运算符来检查两个 <code>Vector2D</code> 实例是否具有相等的值。 在 <code>Vector2D</code> 的上下文中，将”相等”理解为”两个实例具有相同的 <code>x</code> 值和 <code>y</code> 值”是有意义的，因此这就是运算符实现所使用的逻辑。</p>
<p>现在你可以使用这个运算符来检查两个 <code>Vector2D</code> 实例是否相等：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThree <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThree <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThree <span class="operator">==</span> anotherTwoThree &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;These two vectors are equivalent.&quot;</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let twoThree = Vector2D(x: 2.0, y: 3.0)</span><br><span class="line">-&gt; let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)</span><br><span class="line">-&gt; if twoThree == anotherTwoThree &#123;</span><br><span class="line">      print(&quot;These two vectors are equivalent.&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&lt;- These two vectors are equivalent.</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>在许多简单的情况下，你可以要求 Swift 为你提供等价运算符的合成实现，如 <a href="doc:Protocols#使用合成实现来遵循协议">doc:Protocols#使用合成实现来遵循协议</a> 中所述。</p>
<h2 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h2><p>除了 Swift 提供的标准运算符外，你还可以声明和实现自己的 <strong>自定义运算符</strong>。有关可用于定义自定义运算符的字符列表，请参见 <a href="doc:LexicalStructure#运算符">doc:LexicalStructure#运算符</a>。</p>
<p>新运算符使用 <code>operator</code> 关键字在全局级别声明，并用 <code>prefix</code>、<code>infix</code> 或 <code>postfix</code> 修饰符标记：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> <span class="title">+++</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; prefix operator +++</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>上面的例子定义了一个名为 <code>+++</code> 的新前缀运算符。这个运算符在 Swift 中没有现有的含义，因此在下面特定的 <code>Vector2D</code> 实例工作环境中给予了它自己的自定义含义。出于本例的目的，<code>+++</code> 被视为一个新的”前缀加倍”运算符。它通过使用先前定义的加法赋值运算符将向量加到自身上，从而将 <code>Vector2D</code> 实例的 <code>x</code> 和 <code>y</code> 值加倍。要实现 <code>+++</code> 运算符，你需要向 <code>Vector2D</code> 添加一个名为 <code>+++</code> 的类型方法，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="keyword">func</span> <span class="title function_">+++</span> (<span class="params">vector</span>: <span class="keyword">inout</span> <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        vector <span class="operator">+=</span> vector</span><br><span class="line">        <span class="keyword">return</span> vector</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toBeDoubled <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> afterDoubling <span class="operator">=</span> <span class="operator">+++</span>toBeDoubled</span><br><span class="line"><span class="comment">// toBeDoubled 现在的值为 (2.0, 8.0)</span></span><br><span class="line"><span class="comment">// afterDoubling 值也为 (2.0, 8.0)</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-&gt; extension Vector2D &#123;</span><br><span class="line">      static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">         vector += vector</span><br><span class="line">         return vector</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; var toBeDoubled = Vector2D(x: 1.0, y: 4.0)</span><br><span class="line">-&gt; let afterDoubling = +++toBeDoubled</span><br><span class="line">/&gt; toBeDoubled now has values of (\(toBeDoubled.x), \(toBeDoubled.y))</span><br><span class="line">&lt;/ toBeDoubled now has values of (2.0, 8.0)</span><br><span class="line">/&gt; afterDoubling also has values of (\(afterDoubling.x), \(afterDoubling.y))</span><br><span class="line">&lt;/ afterDoubling also has values of (2.0, 8.0)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="自定义中缀运算符的优先级"><a href="#自定义中缀运算符的优先级" class="headerlink" title="自定义中缀运算符的优先级"></a>自定义中缀运算符的优先级</h3><p>每个自定义中缀运算符都属于一个优先级组。优先级组指定了一个运算符相对于其他中缀运算符的优先级，以及运算符的结合性。有关这些特性如何影响中缀运算符与其他中缀运算符交互的解释，请参见 <a href="doc:AdvancedOperators#优先级和结合性">doc:AdvancedOperators#优先级和结合性</a>。</p>
<p>没有被明确放入优先级组的自定义中缀运算符会被赋予一个默认优先级组，其优先级紧高于三元条件运算符的优先级。</p>
<p>下面的例子定义了一个名为 <code>+-</code> 的新自定义中缀运算符，它属于 <code>AdditionPrecedence</code> 优先级组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">+-</span>: <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">+-</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">-</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> firstVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> secondVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> plusMinusVector <span class="operator">=</span> firstVector <span class="operator">+-</span> secondVector</span><br><span class="line"><span class="comment">// plusMinusVector 是一个 Vector2D 实例，其值为 (4.0, -2.0)</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `customOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-&gt; infix operator +-: AdditionPrecedence</span><br><span class="line">-&gt; extension Vector2D &#123;</span><br><span class="line">      static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">         return Vector2D(x: left.x + right.x, y: left.y - right.y)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; let firstVector = Vector2D(x: 1.0, y: 2.0)</span><br><span class="line">-&gt; let secondVector = Vector2D(x: 3.0, y: 4.0)</span><br><span class="line">-&gt; let plusMinusVector = firstVector +- secondVector</span><br><span class="line">/&gt; plusMinusVector is a Vector2D instance with values of (\(plusMinusVector.x), \(plusMinusVector.y))</span><br><span class="line">&lt;/ plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>这个运算符将两个向量的 <code>x</code> 值相加，并从第一个向量的 <code>y</code> 值中减去第二个向量的 <code>y</code> 值。由于它本质上是一个”加法”运算符，因此它被赋予了与加法中缀运算符（如 <code>+</code> 和 <code>-</code>)相同的优先级组。有关 Swift 标准库提供的运算符的信息，包括运算符优先级组和结合性设置的完整列表，请参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>。有关优先级组的更多信息以及定义自己的运算符和优先级组的语法，请参见 <a href="doc:Declarations#操作符声明">doc:Declarations#操作符声明</a>。</p>
<blockquote>
<p>注意： 在定义前缀或后缀运算符时，你不需要指定优先级。但是，如果你对同一个操作数同时应用前缀和后缀运算符，后缀运算符会先被应用。</p>
</blockquote>
<!--
  - test: `postfixOperatorsAreAppliedBeforePrefixOperators`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-&gt; prefix operator +++</span><br><span class="line">-&gt; postfix operator ---</span><br><span class="line">-&gt; extension Int &#123;</span><br><span class="line">       static prefix func +++ (x: Int) -&gt; Int &#123;</span><br><span class="line">           return x * 2</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; extension Int &#123;</span><br><span class="line">       static postfix func --- (x: Int) -&gt; Int &#123;</span><br><span class="line">           return x - 1</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; let x = +++1---</span><br><span class="line">-&gt; let y = +++(1---)</span><br><span class="line">-&gt; let z = (+++1)---</span><br><span class="line">-&gt; print(x, y, z)</span><br><span class="line">&lt;- 0 0 1</span><br><span class="line">// Note that x==y</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h2 id="结果构建器"><a href="#结果构建器" class="headerlink" title="结果构建器"></a>结果构建器</h2><p><strong>结果构建器</strong> 是你定义的一种类型，它为以自然、声明式的方式创建嵌套数据（如列表或树）添加语法。使用结果构建器的代码可以包含普通的 Swift 语法，如 <code>if</code> 和 <code>for</code> ，以处理条件或重复的数据片段。</p>
<p>下面的代码定义了几种类型，用于使用星号和文本在单行上绘图。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>: <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">Drawable</span>]</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements.map &#123; <span class="variable">$0</span>.draw() &#125;.joined(separator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Text</span>: <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">content</span>: <span class="type">String</span>) &#123; <span class="keyword">self</span>.content <span class="operator">=</span> content &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() -&gt; <span class="type">String</span> &#123; <span class="keyword">return</span> content &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Space</span>: <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() -&gt; <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">&quot; &quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stars</span>: <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> length: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() -&gt; <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="type">String</span>(repeating: <span class="string">&quot;*&quot;</span>, count: length) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllCaps</span>: <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">Drawable</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() -&gt; <span class="type">String</span> &#123; <span class="keyword">return</span> content.draw().uppercased() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `result-builder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-&gt; protocol Drawable &#123;</span><br><span class="line">       func draw() -&gt; String</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; struct Line: Drawable &#123;</span><br><span class="line">       var elements: [Drawable]</span><br><span class="line">       func draw() -&gt; String &#123;</span><br><span class="line">           return elements.map &#123; $0.draw() &#125;.joined(separator: &quot;&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; struct Text: Drawable &#123;</span><br><span class="line">       var content: String</span><br><span class="line">       init(_ content: String) &#123; self.content = content &#125;</span><br><span class="line">       func draw() -&gt; String &#123; return content &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; struct Space: Drawable &#123;</span><br><span class="line">       func draw() -&gt; String &#123; return &quot; &quot; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; struct Stars: Drawable &#123;</span><br><span class="line">       var length: Int</span><br><span class="line">       func draw() -&gt; String &#123; return String(repeating: &quot;*&quot;, count: length) &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; struct AllCaps: Drawable &#123;</span><br><span class="line">       var content: Drawable</span><br><span class="line">       func draw() -&gt; String &#123; return content.draw().uppercased() &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>Drawable</code> 协议定义了可以被绘制的东西（如线条或形状）的要求：该类型必须实现一个 <code>draw()</code> 方法。<code>Line</code> 结构表示单行绘图，它作为大多数绘图的顶层容器。要绘制一个 <code>Line</code> ，该结构调用线条的每个组件的 <code>draw()</code> 方法，然后将结果字符串连接成一个单一的字符串。<code>Text</code> 结构包装一个字符串，使其成为绘图的一部分。<code>AllCaps</code> 结构包装并修改另一个绘图，将绘图中的任何文本转换为大写。</p>
<p>通过调用这些类型的初始化器，可以创建一个绘图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Ravi Patel&quot;</span></span><br><span class="line"><span class="keyword">let</span> manualDrawing <span class="operator">=</span> <span class="type">Line</span>(elements: [</span><br><span class="line">     <span class="type">Stars</span>(length: <span class="number">3</span>),</span><br><span class="line">     <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>),</span><br><span class="line">     <span class="type">Space</span>(),</span><br><span class="line">     <span class="type">AllCaps</span>(content: <span class="type">Text</span>((name <span class="operator">??</span> <span class="string">&quot;World&quot;</span>) <span class="operator">+</span> <span class="string">&quot;!&quot;</span>)),</span><br><span class="line">     <span class="type">Stars</span>(length: <span class="number">2</span>),</span><br><span class="line">])</span><br><span class="line"><span class="built_in">print</span>(manualDrawing.draw())</span><br><span class="line"><span class="comment">// 打印 &quot;***Hello RAVI PATEL!**&quot;</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `result-builder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let name: String? = &quot;Ravi Patel&quot;</span><br><span class="line">-&gt; let manualDrawing = Line(elements: [</span><br><span class="line">        Stars(length: 3),</span><br><span class="line">        Text(&quot;Hello&quot;),</span><br><span class="line">        Space(),</span><br><span class="line">        AllCaps(content: Text((name ?? &quot;World&quot;) + &quot;!&quot;)),</span><br><span class="line">        Stars(length: 2),</span><br><span class="line">   ])</span><br><span class="line">-&gt; print(manualDrawing.draw())</span><br><span class="line">&lt;- ***Hello RAVI PATEL!**</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>这段代码是可行的，但有点笨拙。<code>AllCaps</code> 之后的深度嵌套括号很难阅读。当 <code>name</code> 为 <code>nil</code> 时使用 “World” 的后备逻辑必须使用 <code>??</code> 运算符内联完成，如果有更复杂的内容，这将变得很困难。如果你需要包含 switch 或 <code>for</code> 循环来构建部分绘图，就无法做到这一点。结果构建器让你可以重写这样的代码，使其看起来像普通的 Swift 代码。</p>
<p>要定义一个结果构建器，你需要在类型声明上写 <code>@resultBuilder</code> 属性。例如，这段代码定义了一个名为 <code>DrawingBuilder</code> 的结果构建器，它让你可以使用声明式语法来描述一个绘图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@resultBuilder</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DrawingBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">Drawable</span>...) -&gt; <span class="type">Drawable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Line</span>(elements: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">buildEither</span>(<span class="params">first</span>: <span class="type">Drawable</span>) -&gt; <span class="type">Drawable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">buildEither</span>(<span class="params">second</span>: <span class="type">Drawable</span>) -&gt; <span class="type">Drawable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `result-builder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-&gt; @resultBuilder</span><br><span class="line">-&gt; struct DrawingBuilder &#123;</span><br><span class="line">       static func buildBlock(_ components: Drawable...) -&gt; Drawable &#123;</span><br><span class="line">           return Line(elements: components)</span><br><span class="line">       &#125;</span><br><span class="line">       static func buildEither(first: Drawable) -&gt; Drawable &#123;</span><br><span class="line">           return first</span><br><span class="line">       &#125;</span><br><span class="line">       static func buildEither(second: Drawable) -&gt; Drawable &#123;</span><br><span class="line">           return second</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>DrawingBuilder</code> 结构定义了三个方法来实现结果构建器语法的部分功能。<code>buildBlock(_:)</code> 方法支持在代码块中编写一系列行。它将该块中的组件组合成一个 <code>Line</code> 。<code>buildEither(first:)</code> 和 <code>buildEither(second:)</code> 方法为 <code>if</code>-<code>else</code> 提供支持。</p>
<p>你可以将 <code>@DrawingBuilder</code> 属性应用于函数的参数，这会将传递给函数的闭包转换为结果构建器从该闭包创建的值。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">draw</span>(<span class="meta">@DrawingBuilder</span> <span class="params">content</span>: () -&gt; <span class="type">Drawable</span>) -&gt; <span class="type">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> content()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">caps</span>(<span class="meta">@DrawingBuilder</span> <span class="params">content</span>: () -&gt; <span class="type">Drawable</span>) -&gt; <span class="type">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AllCaps</span>(content: content())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">makeGreeting</span>(<span class="params">for</span> <span class="params">name</span>: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting <span class="operator">=</span> draw &#123;</span><br><span class="line">        <span class="type">Stars</span>(length: <span class="number">3</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        <span class="type">Space</span>()</span><br><span class="line">        caps &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> name &#123;</span><br><span class="line">                <span class="type">Text</span>(name <span class="operator">+</span> <span class="string">&quot;!&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Stars</span>(length: <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> genericGreeting <span class="operator">=</span> makeGreeting()</span><br><span class="line"><span class="built_in">print</span>(genericGreeting.draw())</span><br><span class="line"><span class="comment">// 打印 &quot;***Hello WORLD!**&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personalGreeting <span class="operator">=</span> makeGreeting(for: <span class="string">&quot;Ravi Patel&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(personalGreeting.draw())</span><br><span class="line"><span class="comment">// 打印 &quot;***Hello RAVI PATEL!**&quot;</span></span><br></pre></td></tr></table></figure>

<!--
  - test: `result-builder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-&gt; func draw(@DrawingBuilder content: () -&gt; Drawable) -&gt; Drawable &#123;</span><br><span class="line">       return content()</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; func caps(@DrawingBuilder content: () -&gt; Drawable) -&gt; Drawable &#123;</span><br><span class="line">       return AllCaps(content: content())</span><br><span class="line">   &#125;</span><br><span class="line">---</span><br><span class="line">-&gt; func makeGreeting(for name: String? = nil) -&gt; Drawable &#123;</span><br><span class="line">       let greeting = draw &#123;</span><br><span class="line">           Stars(length: 3)</span><br><span class="line">           Text(&quot;Hello&quot;)</span><br><span class="line">           Space()</span><br><span class="line">           caps &#123;</span><br><span class="line">               if let name = name &#123;</span><br><span class="line">                   Text(name + &quot;!&quot;)</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   Text(&quot;World!&quot;)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           Stars(length: 2)</span><br><span class="line">       &#125;</span><br><span class="line">       return greeting</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; let genericGreeting = makeGreeting()</span><br><span class="line">-&gt; print(genericGreeting.draw())</span><br><span class="line">&lt;- ***Hello WORLD!**</span><br><span class="line">---</span><br><span class="line">-&gt; let personalGreeting = makeGreeting(for: &quot;Ravi Patel&quot;)</span><br><span class="line">-&gt; print(personalGreeting.draw())</span><br><span class="line">&lt;- ***Hello RAVI PATEL!**</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p><code>makeGreeting(for:)</code> 函数接受一个 <code>name</code> 参数并使用它来绘制个性化的问候语。<code>draw(_:)</code> 和 <code>caps(_:)</code> 函数都接受一个标记为 <code>@DrawingBuilder</code> 属性的单个闭包作为参数。当你调用这些函数时，你使用 <code>DrawingBuilder</code> 定义的特殊语法。Swift 将绘图的声明性描述转换为对 <code>DrawingBuilder</code> 方法的一系列调用，以构建作为函数参数传递的值。例如，Swift 将示例中对 <code>caps(_:)</code> 的调用转换为类似以下的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> capsDrawing <span class="operator">=</span> caps &#123;</span><br><span class="line">    <span class="keyword">let</span> partialDrawing: <span class="type">Drawable</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> name &#123;</span><br><span class="line">        <span class="keyword">let</span> text <span class="operator">=</span> <span class="type">Text</span>(name <span class="operator">+</span> <span class="string">&quot;!&quot;</span>)</span><br><span class="line">        partialDrawing <span class="operator">=</span> <span class="type">DrawingBuilder</span>.buildEither(first: text)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> text <span class="operator">=</span> <span class="type">Text</span>(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">        partialDrawing <span class="operator">=</span> <span class="type">DrawingBuilder</span>.buildEither(second: text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partialDrawing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `result-builder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-&gt; let capsDrawing = caps &#123;</span><br><span class="line">       let partialDrawing: Drawable</span><br><span class="line">       if let name = name &#123;</span><br><span class="line">           let text = Text(name + &quot;!&quot;)</span><br><span class="line">           partialDrawing = DrawingBuilder.buildEither(first: text)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           let text = Text(&quot;World!&quot;)</span><br><span class="line">           partialDrawing = DrawingBuilder.buildEither(second: text)</span><br><span class="line">       &#125;</span><br><span class="line">       return partialDrawing</span><br><span class="line">-&gt; &#125;</span><br><span class="line">&gt;&gt; print(capsDrawing.draw())</span><br><span class="line">&lt;&lt; RAVI PATEL!</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>Swift 将 <code>if</code>-<code>else</code> 块转换为对 <code>buildEither(first:)</code> 和 <code>buildEither(second:)</code> 方法的调用。尽管你在自己的代码中不会调用这些方法，但展示转换的结果可以更容易地看到 Swift 在你使用 <code>DrawingBuilder</code> 语法时如何转换你的代码。</p>
<p>要为在特殊绘图语法中编写 <code>for</code> 循环添加支持，请添加一个 <code>buildArray(_:)</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">DrawingBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">buildArray</span>(<span class="keyword">_</span> <span class="params">components</span>: [<span class="type">Drawable</span>]) -&gt; <span class="type">Drawable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Line</span>(elements: components)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> manyStars <span class="operator">=</span> draw &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Stars:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> length <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">3</span> &#123;</span><br><span class="line">        <span class="type">Space</span>()</span><br><span class="line">        <span class="type">Stars</span>(length: length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
  - test: `result-builder`

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-&gt; extension DrawingBuilder &#123;</span><br><span class="line">       static func buildArray(_ components: [Drawable]) -&gt; Drawable &#123;</span><br><span class="line">           return Line(elements: components)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">-&gt; let manyStars = draw &#123;</span><br><span class="line">       Text(&quot;Stars:&quot;)</span><br><span class="line">       for length in 1...3 &#123;</span><br><span class="line">           Space()</span><br><span class="line">           Stars(length: length)</span><br><span class="line">       &#125;</span><br><span class="line">-&gt; &#125;</span><br><span class="line">&gt;&gt; print(manyStars.draw())</span><br><span class="line">&lt;&lt; Stars: * ** ***</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>在上面的代码中，<code>for</code> 循环创建了一个绘图数组，<code>buildArray(_:)</code> 方法将该数组转换为一个 <code>Line</code> 。</p>
<p>有关 Swift 如何将构建器语法转换为对构建器类型方法的调用的完整列表，请参阅 <a href="doc:Attributes#resultBuilder">doc:Attributes#resultBuilder</a>。</p>
<!--
  The following needs more work...

   Protocol Operator Requirements
   ------------------------------

   You can include operators in the requirements of a protocol.
   A type conforms to the protocol
   only if there's an implementation of the operator for that type.
   You use ``Self`` to refer to the type that will conform to the protocol,
   just like you do in other protocol requirements.
   For example, the Swift standard library defines the ``Equatable`` protocol
   which requires the ``==`` operator:

   .. testcode:: protocolOperator

      -> protocol Equatable {
             static func == (lhs: Self, rhs: Self) -> Bool
         }

   To make a type conform to the protocol,
   you need to implement the ``==`` operator for that type.
   For example:

   .. testcode:: protocolOperator

  -> struct Vector3D {
        var x = 0.0, y = 0.0, z = 0.0
     }
  -> extension Vector3D: Equatable {
         static func == (left: Vector3D, right: Vector3D) -> Bool {
             return (left.x == right.x) && (left.y == right.y) && (left.z == right.z)
         }
     }
  >> let r0 =
  >> Vector3D(x: 1.1, y: 2.3, z: 12) == Vector3D(x: 1.1, y: 2.3, z: 12)
  >> assert(r0)
-->

<!--
  FIXME: This doesn't work
  <rdar://problem/27536066> SE-0091 -- can't have protocol conformance & operator implementation in different types

   For operators that take values of two different types,
   the operator's implementation doesn't have to be
   a member of the type that conforms to the protocol ---
   the implementation can also be a member of the other type.
   For example,
   the code below defines the ``*`` operator
   to scale a vector by a given amount.
   The ``Vector2D`` structure conforms to this protocol
   because there's an implementation of the operator
   that takes a ``Vector2D`` as its second argument,
   even though that implementation is a member of ``Double``.

   .. testcode:: customOperators

  -> infix operator *** {}
  -> protocol AnotherProtocol {
         // static func * (scale: Double, vector: Self) -> Self
         static func *** (scale: Double, vector: Vector2D) -> Vector2D
     }
  ---
  -> extension Double {
         static func *** (scale: Double, vector: Vector2D) -> Vector2D {
             return Vector2D(x: scale * vector.x, y: scale * vector.y)
         }
     }
  -> extension Vector2D: AnotherProtocol {}
  -> let unitVector = Vector2D(x: 1.0, y: 1.0)
  -> print(2.5 *** unitVector)
  <- Vector2D(x: 2.5, y: 2.5)
-->

<!--
  TODO: However, Doug thought that this might be better covered by Generics,
  where you know that two things are definitely of the same type.
  Perhaps mention it here, but don't actually show an example?
-->

<!--
  TODO: generic operators
-->

<!--
This source file is part of the Swift.org open source project

Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
Licensed under Apache License v2.0 with Runtime Library Exception

See https://swift.org/LICENSE.txt for license information
See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-->
</body></html>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/course/">COURSE</a></li>
            <li><a href="/course/ios/">IOS</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/">THE-SWIFT-PROGRAMMING-LANGUAGE-IN-CHINESE-6.0</a></li>
            <li><a href="/course/ios/the-swift-programming-language-in-chinese-6.0/LanguageGuide/">LANGUAGEGUIDE</a></li>
            <li>ADVANCEDOPERATORS</li>
          
  </ul>

    
    
    
  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.</span> <span class="nav-text">高级运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.</span> <span class="nav-text">位运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.1.</span> <span class="nav-text">按位取反运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">按位与运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E7%A7%BB%E4%BD%8D%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">无符号整数的移位行为</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">运算符方法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="joe"
      src="/images/me.png">
  <p class="site-author-name" itemprop="name">joe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangdongyang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangdongyang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wf_pinbo@163.com" title="E-Mail → wf_pinbo@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备2021004873号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">joe</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'vrpizpRNUt6dhU7r9k6mBGRy-gzGzoHsz',
    appKey: '5lIjR9cSntdE9MvI7DIf55Xn',
    placeholder: "ヾﾉ≧∀≦)o 来呀！吐槽一番吧！",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
