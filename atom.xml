<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那年星空</title>
  
  
  <link href="http://www.nnxkcloud.com/atom.xml" rel="self"/>
  
  <link href="http://www.nnxkcloud.com/"/>
  <updated>2025-01-23T03:32:26.704Z</updated>
  <id>http://www.nnxkcloud.com/</id>
  
  <author>
    <name>joe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dart 语法原来这么好玩儿（三）</title>
    <link href="http://www.nnxkcloud.com/2025/01/23/Dart-%E8%AF%AD%E6%B3%95%E5%8E%9F%E6%9D%A5%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9%E5%84%BF%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.nnxkcloud.com/2025/01/23/Dart-%E8%AF%AD%E6%B3%95%E5%8E%9F%E6%9D%A5%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9%E5%84%BF%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2025-01-23T03:31:32.000Z</published>
    <updated>2025-01-23T03:32:26.704Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body></body></html><html><head></head><body><p>今天来讲讲 <code>Dart</code> 中枚举（<code>Enum</code>），可能有的同学会说这个很常见也很简单，常把它用于定义一些状态、类型、级别等等，其用法一看就懂，直接 <code>switch-case</code> 一把梭哈到底，和其它的编程语言差别不大，没啥新鲜感，可是真的是这样吗？本篇文章结合实际项目开发中的场景来梳理一下 <code>Dart</code> 枚举的核心功能和使用技巧，尤其是在文章的末尾处对枚举的运用，为你在解决类似的实际业务场景提供了全新的思路。</p><h3 id="Flutter-2-x-x-的枚举"><a href="#Flutter-2-x-x-的枚举" class="headerlink" title="Flutter 2.x.x 的枚举"></a><code>Flutter</code> 2.x.x 的枚举</h3><p><code>Flutter</code> 2.x.x 的时候，<code>enum</code> 用起来确实很鸡肋，枚举值只能表示静态的常量集合，不能为每个枚举值附加额外的属性，如果想要添加额外的属性则需要借助 <code>Map</code> 映射来实现。其内部无法添加方法，需要借助 <code>Extension</code> 来实现。还有缺少编译时检查导致 <code>switch-case</code> 枚举时出现漏处理等问题。这些也是我前段时间刚结束的 <code>App</code> 项目中 <code>Flutter</code> 版本升级改造遇到和处理过的问题，借着这次也来分享一下。</p><p><img src="https://s2.loli.net/2025/01/22/j56ZVRbaMCevrgX.jpg"></p><p>在刚刚改造完的智能设备的项目中，常常需要区分不同的设备，代码中到处都要用到设备类型，此时使用枚举来罗列多个设备类型（<code>DeviceType</code>）就是很好的应用场景，下面是项目中定义的枚举：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DeviceType {</span><br><span class="line">  lamp,             <span class="comment">// 灯，1</span></span><br><span class="line">  airConditioner,   <span class="comment">// 空调，2</span></span><br><span class="line">  camera,           <span class="comment">// 摄像头，3</span></span><br><span class="line">  doorLock,         <span class="comment">// 智能门锁，4</span></span><br><span class="line">  gateway,  <span class="comment">// 网关，5</span></span><br><span class="line">  fridge,   <span class="comment">// 冰箱，6</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这些设备类型只是项目中的一部分，此时和后端 <code>Api</code> 接口返回的设备类型编号对应，例如 <code>1</code> 表示 <code>lamp</code> 等，解析 <code>json</code> 数据的时候将数字转成枚举类型 <code>DeviceType</code>，方便在其它地方使用，但是如果我们需要用到和设备类型相关的更多参数的时候，如设备名称国际化、设备图标、是否可以被分组及枚举的嵌套，在 <code>Flutter</code> 2.x.x 的时候，只能单独定义一个 <code>Map</code> 来做映射，我在这里先定义了 <code>List</code>，再将它转成 <code>Map</code>。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&gt; allDeviceTypes = </span><br><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"灯"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"type"</span>: DeviceType.lamp,</span><br><span class="line">    <span class="string">"icon"</span>: <span class="string">"lamp_icon"</span>,</span><br><span class="line">    <span class="string">"is_group"</span>: <span class="keyword">true</span></span><br><span class="line">  },</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">这里将上面的 List 转成 Map</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">其结构为：{"lamp": {"name":"灯","value":1,"type":DeviceType.lamp,"icon":"lamp<span class="emphasis">_icon","is_</span>group":true}}</span></span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; <span class="keyword">get</span> allDeviceTypesMap =&gt; allDeviceTypes.asMap().map(</span><br><span class="line">    (key, value) =&gt; MapEntry((value[<span class="string">"type"</span>] <span class="keyword">as</span> DeviceType).typeName, value));</span><br></pre></td></tr></tbody></table></figure><p>然后借助 <code>extension</code> 来实现，当用到设备名称文案的时候，可以直接 <code>DeviceType.lamp.name</code>来获取名称，实现代码如下。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> DeviceTypeExtension <span class="keyword">on</span> DeviceType {</span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> typeName =&gt; toString().split(<span class="string">"."</span>).last;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> value =&gt; allDeviceTypesMap[typeName][<span class="string">"value"</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name =&gt; allDeviceTypesMap[typeName][<span class="string">"name"</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> icon =&gt; allDeviceTypesMap[typeName][<span class="string">"icon"</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Dart</code> 2.17 之前想要实现上述类似逻辑，除了上面这种写法之外，还可以使用类的静态构造函数来实现，具体写法以参考此系列的上一篇文章《Dart 语法原来这么好玩儿（二）》。</p><h3 id="属性字段"><a href="#属性字段" class="headerlink" title="属性字段"></a>属性字段</h3><p>这么一套下来是不是着实有点麻烦，那会儿从 <code>Swift</code> 转到 <code>Dart</code> 的时候，很不适应，这也太鸡肋了，经常吐槽。但是将 <code>Flutter</code> 升级更新，<code>Dart</code> 2.17之后引入了 <code>Enhanced Enum Classes</code>，不再需要额外的 <code>Map</code> 映射和借助 <code>extension</code> 了，直接在 <code>enum</code> 内部定义其属性，并在构造函数中初始化其属性字段，这样修改后的代码瞬间看起来清爽多了，代码如下：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DeviceType {</span><br><span class="line">  lamp(<span class="string">"灯光"</span>, <span class="string">"lamp_icon"</span>, <span class="number">1</span>, <span class="keyword">true</span>), <span class="comment">// 灯光</span></span><br><span class="line">  airConditioner(<span class="string">"空调"</span>, <span class="string">"air_conditioner_icon"</span>, <span class="number">2</span>, <span class="keyword">true</span>), <span class="comment">// 空调</span></span><br><span class="line">  camera(<span class="string">"摄像头"</span>, <span class="string">"camera_icon"</span>, <span class="number">3</span>, <span class="keyword">false</span>), <span class="comment">// 摄像头</span></span><br><span class="line">  doorLock(<span class="string">"智能门锁"</span>, <span class="string">"door_lock_icon"</span>, <span class="number">4</span>, <span class="keyword">true</span>), <span class="comment">// 智能门锁</span></span><br><span class="line">  gateway(<span class="string">"网关"</span>, <span class="string">"gateway_icon"</span>, <span class="number">5</span>, <span class="keyword">false</span>), <span class="comment">// 网关</span></span><br><span class="line">  fridge(<span class="string">"冰箱"</span>, <span class="string">"fridge_icon"</span>, <span class="number">6</span>, <span class="keyword">true</span>); <span class="comment">// 冰箱，注意这里使用 ; 结尾</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性用 final 关键字修饰</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> icon;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> value;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isGroup;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法前的加 const 关键字</span></span><br><span class="line">  <span class="keyword">const</span> DeviceType(<span class="keyword">this</span>.title, <span class="keyword">this</span>.icon, <span class="keyword">this</span>.value, <span class="keyword">this</span>.isGroup);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>值得注意的是定义的属性需要使用 <code>final</code> 关键字修饰，构造方法前的加 <code>const</code> 关键字，各个枚举成员之间使用逗号<code>,</code>分隔，最后一个成员使用分号<code>;</code>结尾。</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>除了上面代码中可以给枚举添加属性外，不同设备可能有特定的行为或交互方式，可以通过枚举实现这些行为的动态处理，即为枚举添加实例方法。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performCustomAction(<span class="built_in">String</span> command) {</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>) {</span><br><span class="line">    <span class="keyword">case</span> DeviceType.lamp:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>：<span class="subst">$command</span> 灯光已调整亮度。'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DeviceType.airConditioner:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>：<span class="subst">$command</span> 温度设置成功。'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/// <span class="language-markdown">...</span></span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用枚举的实例方法：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() {</span><br><span class="line">  DeviceType.lamp.performCustomAction(<span class="string">"brightness to 80%"</span>);</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">灯：brightness to 80% 灯光已调整亮度。</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h3><p>在 <code>Model</code> 中解析后端 <code>Api</code> 接口返回的设备类型编号，此时根据设备类型编号转成我们想要的设备枚举类型 <code>DeviceType</code>，该怎么操作呢？<code>Dart</code> 的增强枚举允许使用工厂构造函数，根据逻辑动态返回特定的枚举值，将如下代码添加到 <code>DeviceType</code> 枚举类中。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">参数 value 为后端接口返回的设备类型编号。</span></span></span><br><span class="line"><span class="keyword">factory</span> DeviceType.fromValue(<span class="built_in">int</span> value) {</span><br><span class="line">  <span class="keyword">return</span> DeviceType.values.firstWhere((type) =&gt; type.value == value,</span><br><span class="line">      orElse: () =&gt; DeviceType.lamp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>外部调用 <code>DeviceType</code> 的工厂构造函数：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() {</span><br><span class="line">  <span class="built_in">print</span>(DeviceType.fromValue(<span class="number">2</span>));</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">DeviceType.airConditioner</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="静态字段和方法"><a href="#静态字段和方法" class="headerlink" title="静态字段和方法"></a>静态字段和方法</h3><p>增强枚举还支持在内部定义静态字段和方法，常用于在枚举层级上操作或存储数据，静态方法也可以实现上述工厂构造函数类似的功能，根据设备类型编号返回<code>DeviceType</code>类型，代码如下：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> defaultDeviceType = DeviceType.unknown;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> DeviceType withValue(<span class="built_in">int</span> value) {</span><br><span class="line">  <span class="keyword">return</span> DeviceType.values.firstWhere((type) =&gt; type.value == value,</span><br><span class="line">      orElse: () =&gt; DeviceType.unknown);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>枚举还可以实现接口，用来统一设备的行为或规范设备的能力。例如，有多种智能设备（如灯、摄像头、门锁等），它们都需要实现某些通用功能，如设备开关、状态查询等。这可以通过枚举实现接口来设计，这里定义了一个设备行为接口类<code>SmartDevice</code>。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义设备行为接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartDevice</span> </span>{</span><br><span class="line">  <span class="keyword">void</span> turnOn();   <span class="comment">// 打开设备</span></span><br><span class="line">  <span class="keyword">void</span> turnOff();  <span class="comment">// 关闭设备</span></span><br><span class="line">  <span class="built_in">bool</span> getStatus(); <span class="comment">// 查询设备状态</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在枚举 <code>DeviceType</code> 中实现上述接口。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DeviceType <span class="keyword">implements</span> SmartDevice {</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 设备状态存储在 Map 中</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;DeviceType, <span class="built_in">bool</span>&gt; _deviceStates = {</span><br><span class="line">    DeviceType.lamp: <span class="keyword">false</span>,</span><br><span class="line">    DeviceType.airConditioner: <span class="keyword">false</span>,</span><br><span class="line">    DeviceType.camera: <span class="keyword">false</span>,</span><br><span class="line">    DeviceType.doorLock: <span class="keyword">false</span>,</span><br><span class="line">    DeviceType.gateway: <span class="keyword">false</span>,</span><br><span class="line">    DeviceType.fridge: <span class="keyword">false</span>,</span><br><span class="line">  };</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> getStatus() =&gt; _deviceStates[<span class="keyword">this</span>] ?? <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOff() {</span><br><span class="line">    _deviceStates[<span class="keyword">this</span>] = <span class="keyword">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() {</span><br><span class="line">    _deviceStates[<span class="keyword">this</span>] = <span class="keyword">true</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用示例：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() {</span><br><span class="line">  DeviceType.lamp.turnOn();</span><br><span class="line">  <span class="built_in">print</span>(DeviceType.lamp.getStatus()); <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里可能有人会有疑问了，这个和直接在内部定义函数或者借助外部的 <code>extension</code> 来实现有什么区别呢？这么做不是搞复杂了吗？其实这个就和接口的作用相一致的，通过接口定义一组行为或功能，使得枚举类型可以实现统一行为或约束，特别是有多个不同的枚举类型的复杂场景时，实现了相同的接口方法，有更大的复用性和灵活性。所以个人觉得二者并不冲突，怎么选择可以根据实际场景组合来使用。</p><h3 id="与-mixin-结合使用"><a href="#与-mixin-结合使用" class="headerlink" title="与 mixin 结合使用"></a>与 <code>mixin</code> 结合使用</h3><p>通过 <code>mixin</code> 来为枚举值添加通用功能或扩展特定行为。这种组合方式适用于需要复用功能或为不同枚举提供一致操作的场景，达到动态增加功能的目的，而不破坏枚举原有的结构，如设备状态枚举，每个设备状态都有的日志记录等。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Loggable {</span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> message) {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[Log] <span class="subst">$message</span>'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> DeviceStatus <span class="keyword">with</span> Loggable {</span><br><span class="line">  active(<span class="string">'设备正在运行'</span>),</span><br><span class="line">  inactive(<span class="string">'设备未激活'</span>),</span><br><span class="line">  error(<span class="string">'设备出现故障'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> desc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> DeviceStatus(<span class="keyword">this</span>.desc);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> performAction() {</span><br><span class="line">    log(<span class="string">'当前状态：<span class="subst">$desc</span>'</span>);</span><br><span class="line">    <span class="comment">/// <span class="language-markdown">处理其它逻辑</span></span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在枚举中使用 <code>mixin</code> 和上面提到的实现接口，它们俩除了关键字不一样还有什么其它区别呢？其实从设计意图和应用场景上来讲区别还是挺大的。接口是定义了一组方法和属性来强制规定某些行为，并且这些行为必须由枚举具体实现，适合为不同枚举值提供不同的实现逻辑。而 <code>mixin</code> 是一种代码复用机制，也可以为为枚举添加方法和属性及提供通用的行为或功能，但没有强制性，不需要每个枚举值有独特的实现，适合为所有枚举值提供通用的扩展功能或工具方法。</p><h3 id="与泛型结合使用"><a href="#与泛型结合使用" class="headerlink" title="与泛型结合使用"></a>与泛型结合使用</h3><p><img src="https://s2.loli.net/2025/01/22/KDFI2OSA7Mj8uxp.png"></p><p>在实际的智能设备系统中，不同类型的设备类有不同的属性（<code>attribute</code>），如上图所示，灯有亮度和色温，冰箱有当前温度和目标温度，摄像头有是否正在录制及当前分辨率是多少等等，当然还有更多的设备和其它的属性，这里可以结合泛型来定义不同设备的属性和行为。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DeviceAttribute&lt;T&gt; {</span><br><span class="line">  <span class="comment">// 灯的属性，有亮度、色温</span></span><br><span class="line">  brightness&lt;<span class="built_in">int</span>&gt;(),</span><br><span class="line">  colorTemperature&lt;<span class="built_in">int</span>&gt;(),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 冰箱的属性，有当前温度、目标温度</span></span><br><span class="line">  currentTemperature&lt;<span class="built_in">double</span>&gt;(),</span><br><span class="line">  targetTemperature&lt;<span class="built_in">double</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> DeviceAttribute();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>声明 <code>Device</code> 类，一般用来接收 <code>Api</code> 接口返回的 <code>json</code> 数据，<code>json</code> 中有一个 <code>attribute</code> 对象。如果按照以前的做法，在 <code>Device</code> 类中为每一种设备类型创建一个 <code>Attribute</code> 类，如 <code>LampAttribute</code>、<code>FridgeAttribute</code>，依赖接收设备不同的属性。而在这里尝试用枚举结合泛型来实现，<code>type</code> 表示当前的设备类型，<code>properties</code> 表示存储当前设备的属性，这样做到了动态管理不同设备的属性，再也不用为每种设备编写单独的逻辑，实现代码如下：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> </span>{</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">设备类型</span></span></span><br><span class="line">  DeviceType? type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">存储不同设备类型的属性</span></span></span><br><span class="line">  <span class="built_in">Map</span>&lt;DeviceAttribute, <span class="built_in">dynamic</span>&gt;? properties;</span><br><span class="line"></span><br><span class="line">  Device(<span class="keyword">this</span>.type, <span class="keyword">this</span>.properties);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取设备属性</span></span><br><span class="line">  T? getProperty&lt;T&gt;(DeviceAttribute&lt;T&gt; property) {</span><br><span class="line">    <span class="keyword">return</span> properties?[property] <span class="keyword">as</span> T?;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置设备属性</span></span><br><span class="line">  <span class="keyword">void</span> setProperty&lt;T&gt;(DeviceAttribute&lt;T&gt; property, T value) {</span><br><span class="line">    properties?[property] = value;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Device.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json) {</span><br><span class="line">    type = DeviceType.fromValue(json[<span class="string">"value"</span>]);</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; attribute = json[<span class="string">"attribute"</span>];</span><br><span class="line">    <span class="keyword">switch</span> (type) {</span><br><span class="line">      <span class="keyword">case</span> DeviceType.lamp:</span><br><span class="line">        setProperty&lt;<span class="built_in">int</span>&gt;(DeviceAttribute.brightness, attribute[<span class="string">"brightness"</span>]);</span><br><span class="line">        setProperty&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">            DeviceAttribute.colorTemperature, attribute[<span class="string">"colorTemperature"</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DeviceType.fridge:</span><br><span class="line">        setProperty&lt;<span class="built_in">double</span>&gt;(DeviceAttribute.currentTemperature,</span><br><span class="line">            attribute[<span class="string">"currentTemperature"</span>]);</span><br><span class="line">        setProperty&lt;<span class="built_in">double</span>&gt;(</span><br><span class="line">            DeviceAttribute.targetTemperature, attribute[<span class="string">"targetTemperature"</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在界面上使用的时候，通过<code>Device</code>对象的实例调用<code>getProperty</code>方法出入<code>DeviceAttribute</code>枚举类型，就能获取到当前设备的属性数据，其调用代码如下：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main() {</span><br><span class="line">  <span class="comment">// 模拟从接口返回的数据</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json = {};</span><br><span class="line">  <span class="comment">// 创建一个灯设备</span></span><br><span class="line">  <span class="keyword">var</span> device = Device.fromJson(json);</span><br><span class="line">  <span class="keyword">var</span> brightness = device.getProperty&lt;<span class="built_in">int</span>&gt;(DeviceAttribute.brightness);</span><br><span class="line">  <span class="built_in">print</span>(brightness);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>直接通过 <code>DeviceAttribute.brightness</code> 枚举类型获取数据，不再需要判断这个 <code>device</code> 对象是什么类型，这样来实现有没有更加清晰明了呢。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>枚举类型在实际开发中使用非常广泛，如我们的网络请求中，请求的 <code>Method</code> 类型有 <code>Get</code>、<code>Post</code>等，处理 <code>API</code> 响应时，可以用枚举来定义可能出现的错误类型，有网络错误、网络超时、服务器错误等，还有响应的各种状态码也可以用到枚举等等使用场景，使得代码简单易读，有效减少出错的可能性。而通过结合 <code>mixin</code>、接口、泛型等特性，更是为开发者提供了极大的扩展能力。希望通过这篇文章帮助你获得新的启发，更好的利用这一语言特性，让你的代码更加优雅与高效。关于枚举的运用，如果你有什么疑问，欢迎在评论区交流和讨论。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;今天来讲讲 &lt;code&gt;Dart&lt;/code&gt; 中枚举（&lt;code&gt;Enum&lt;/code&gt;），可能有的同学会说这个很常见也很简单，常把它用于定义一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dart 语法原来这么好玩儿（二）</title>
    <link href="http://www.nnxkcloud.com/2024/12/03/Dart-%E8%AF%AD%E6%B3%95%E5%8E%9F%E6%9D%A5%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9%E5%84%BF%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.nnxkcloud.com/2024/12/03/Dart-%E8%AF%AD%E6%B3%95%E5%8E%9F%E6%9D%A5%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9%E5%84%BF%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-12-03T02:29:31.000Z</published>
    <updated>2024-12-03T02:38:23.558Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/12/03/iqP1X5s6uKUrQJA.png"></p><p><a href="https://www.nnxkcloud.com/2024/04/24/dart-%E8%AF%AD%E6%B3%95%E5%8E%9F%E6%9D%A5%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9%E5%84%BF/">上一篇</a> <code>Dart</code> 语法的文章中介绍了对 <code>Future</code>、<code>Streams</code> 的 <code>unwrap</code> 操作以及 <code>List</code>、<code>Map</code>的展开、合并和过滤等等，总觉得有点意犹未尽，还有很多有意思的并没有提到，本篇文章来介绍一下 <code>Dart</code> 语言中面向对象的内容——构造函数，在我们日常开发中，对象的初始化（构造函数）有哪些方式，它们之间的区别在哪里，不同的构造函数都适用于哪些场景呢，本篇文章来聊聊这些内容。</p><span id="more"></span><h3 id="Named-构造函数"><a href="#Named-构造函数" class="headerlink" title="Named 构造函数"></a><code>Named</code> 构造函数</h3><p>如果没有定义构造函数，<code>Dart</code> 会默认创建一个不带参数的<strong>默认构造函数</strong>。它用于创建类的简单实例，通常不带参数或仅初始化对象的基本属性。<code>Dart</code> 还允许在同一类中定义多个构造函数，每个构造函数通过名称区分。命名构造函数提供了更多灵活性，适用于不同初始化需求。命名构造函数使用类名加点（<code>ClassName.constructorName</code>）的形式定义。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> width, height;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常规构造函数</span></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Rectangle.square(<span class="built_in">double</span> size) : width = size, height = size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还可以使用重定向构造函数，简化代码逻辑，将多个构造函数重定向到同一个主构造函数，从而减少重复代码，修改 <code>Rectangle.square</code> 构造函数的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向构造函数</span></span><br><span class="line">Rectangle.square(<span class="built_in">double</span> size) : <span class="keyword">this</span>(size, size);</span><br></pre></td></tr></table></figure><p><code>Flutter</code>源码中这种类似用法有很多，如 <code>EdgeInsets</code> 类，有<code>EdgeInsets.fromLTRB、EdgeInsets.all、EdgeInsets.only</code> 等等。</p><h3 id="Factory-构造函数"><a href="#Factory-构造函数" class="headerlink" title="Factory 构造函数"></a><code>Factory</code> 构造函数</h3><p>工厂构造函数使用 <code>factory</code> 关键字，可以在每次调用构造函数时返回相同的实例，也可以根据逻辑返回不同的实例。它适用于需要缓存或复杂实例创建逻辑的情况，比如我们常见的单例模式（<code>Singleton Pattern</code>）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Logger _instance = Logger._internal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有命名构造函数</span></span><br><span class="line">  Logger._internal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工厂构造函数返回单例</span></span><br><span class="line">  <span class="keyword">factory</span> Logger() &#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下代码复杂一点的用法，利用 <code>Factory</code> 构造函数 来根据不同参数返回不同类型的形状对象（<code>Circle</code> 或 <code>Square</code>），可实现灵活的创建对象，不同于标准构造函数，<code>Factory</code> 构造函数可以返回子类，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ShapeType &#123; circle, square &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ShapeType type;</span><br><span class="line">  <span class="keyword">const</span> Shape(<span class="keyword">this</span>.type);</span><br><span class="line">  <span class="keyword">factory</span> Shape.fromRadius(<span class="built_in">double</span> radius) =&gt; Circle(radius);</span><br><span class="line">  <span class="keyword">factory</span> Shape.fromRect(Rect rect) =&gt; Square(rect);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&#x27;I am a shape of type <span class="subst">$type</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> radius;</span><br><span class="line">  <span class="keyword">const</span> Circle(<span class="keyword">this</span>.radius) : <span class="keyword">super</span>(ShapeType.circle);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="keyword">super</span>.toString() + <span class="string">&#x27; and I am a circle&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Rect rect;</span><br><span class="line">  <span class="keyword">const</span> Square(<span class="keyword">this</span>.rect) : <span class="keyword">super</span>(ShapeType.square);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="keyword">super</span>.toString() + <span class="string">&quot;and I am a square&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Factory</code> 构造函数在对象创建的过程中提供了统一且灵活的接口，特别适用于需要根据不同条件创建不同子类实例的场景。实际项目中 <code>Factory</code> 构造函数的应用场景也很多，尤其在处理复杂对象创建和资源优化方面。</p><p>以下是 <code>Factory</code> 构造函数和普通构造函数的区别。</p><p><img src="https://s2.loli.net/2024/12/02/4VqcCwidvkpo3ZH.png"></p><h3 id="Static-构造函数"><a href="#Static-构造函数" class="headerlink" title="Static 构造函数"></a><code>Static</code> 构造函数</h3><p>实际上在 <code>Dart</code> 中， <code>Static</code> 构造函数并不是像有的编程语言（如 C#）中那样的有内置特性。也就是说 <code>Dart</code> 中没有直接的静态构造函数概念，但可以通过静态方法来实现类似的功能。静态方法可以用于初始化类级别的共享资源、执行单例模式和延迟加载等场景。将上面的单例类（<code>Logger</code>）改成 <code>Static</code> 构造函数来实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Logger _instance = Logger._internal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有构造函数</span></span><br><span class="line">  Logger._internal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态构造函数：通过静态方法返回单例实例</span></span><br><span class="line">  <span class="keyword">static</span> Logger initialize() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Logger initialized&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Log: <span class="subst">$message</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 调用静态构造函数</span></span><br><span class="line">  <span class="keyword">final</span> logger = Logger.initialize();</span><br><span class="line">  logger.log(<span class="string">&quot;This is a log message.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态构造函数结合 late 变量可以达到也可以延迟加载的机制，例如，设计一个依赖初始化数据库的类，来看看是怎么实现的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseConnection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">late</span> DatabaseConnection _instance;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> _isInitialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  DatabaseConnection._create();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态构造函数用于初始化</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> initialize() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_isInitialized) &#123;</span><br><span class="line">      _instance = DatabaseConnection._create();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Database connection initialized.&quot;</span>);</span><br><span class="line">      _isInitialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DatabaseConnection <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> query(<span class="built_in">String</span> sql) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing query: <span class="subst">$sql</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  DatabaseConnection.initialize();</span><br><span class="line">  DatabaseConnection.instance.query(<span class="string">&quot;SELECT * FROM users&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>late</code> 关键字保证变量在第一次使用时才初始化，从而实现延迟加载， <code>_internal</code> 私有构造函数防止外部直接实例化。 <code>getInstance</code> 静态工厂方法是单例实例的全局访问入口。延迟加载常用于当初始化逻辑较为复杂，需要耗费大量资源时，例如，加载配置文件、初始化数据库连接等，或者不希望类在加载时就立即初始化，而是按需使用时才初始化。</p><h3 id="Factory-和-Static-构造函数区别"><a href="#Factory-和-Static-构造函数区别" class="headerlink" title="Factory 和 Static 构造函数区别"></a><code>Factory</code> 和 <code>Static</code> 构造函数区别</h3><p>上面分别介绍了 <code>Factory</code> 构造函数和 <code>Static</code> 构造函数，那么它们之间有什么区别呢？<code>Factory</code> 构造函数返回已有实例或子类实例，控制具体对象的创建过程，而不是初始化与类绑定的静态资源；而 <code>Static</code> 构造函数用于初始化与类本身相关的资源，如设置静态变量或执行静态初始化逻辑，而不创建具体实例。</p><p><img src="https://s2.loli.net/2024/12/02/Grb7ingD1RFMXdJ.png"></p><p>还有需要补充的一点就是对泛型参数的支持，在工厂构造函数中可以直接使用该类泛型参数，而无需在其函数中重新定义它，而是静态构造函数，必须重新定义泛型参数，因为静态构造函数不能从其类中继承泛型参数，借助代码来理解一下。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">P</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> P property;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">factory</span> Person(<span class="built_in">String</span> name, P property) = Person.fromProperties;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Person.fromProperties(<span class="keyword">this</span>.name, <span class="keyword">this</span>.property);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无需重新定义泛型 P，直接使用</span></span><br><span class="line">  <span class="keyword">factory</span> Person.fromPropertiesFactory(<span class="built_in">String</span> name, P property) =&gt;</span><br><span class="line">      Person.fromProperties(name, property);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必须重新定义泛型参数 &lt;P&gt;</span></span><br><span class="line">  <span class="keyword">static</span> Person&lt;P&gt; fromPropertiesStatic&lt;P&gt;(<span class="built_in">String</span> name, P property) =&gt;</span><br><span class="line">      Person.fromProperties(name, property);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Person.fooBar(P property) =&gt;</span><br><span class="line">      Person.fromProperties(<span class="string">&#x27;Foo Bar&#x27;</span>, property);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Person&lt;P&gt; bazQux&lt;P&gt;(P property) =&gt;</span><br><span class="line">      Person.fromProperties(<span class="string">&#x27;Baz Qux&#x27;</span>, property);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，工厂构造函数支持重定向等功能，而静态方法则无法提供这些功能。使用工厂构造函数创建对象有助于明确代码的目的和意图。</p><h3 id="构造函数与抽象类"><a href="#构造函数与抽象类" class="headerlink" title="构造函数与抽象类"></a>构造函数与抽象类</h3><p>和其它语言中的抽象类一样，<code>Dart</code>的抽象类也是不能被实例化的，但抽象类构造函数可以用于初始化被继承的字段或逻辑，子类可以在构造函数中使用 <code>super</code> 调用父类的构造函数，这样方便为子类提供模板化的构造流程。在设计模式中，抽象类的构造函数常用于定义公共初始化逻辑，确保子类继承时遵循一致性。还有当一个类定义了 <code>final</code> 修饰的字段时，可以通过抽象类的构造函数初始化这些字段。也把二者之间的区别做个对比。</p><p><img src="https://s2.loli.net/2024/12/02/V9tQmuWvwJFhGAa.png"></p><p>结合代码来理解一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="built_in">Type</span> &#123; dog, cat &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Type</span> type;</span><br><span class="line">  <span class="comment">// 初始化被继承的字段或逻辑</span></span><br><span class="line">  <span class="keyword">const</span> Animal(&#123;<span class="keyword">required</span> <span class="keyword">this</span>.type&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 super 调用父类的构造函数</span></span><br><span class="line">  <span class="keyword">const</span> Cat() : <span class="keyword">super</span>(type: <span class="built_in">Type</span>.cat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 使用 super 调用父类的构造函数</span></span><br><span class="line">  <span class="keyword">const</span> Dog() : <span class="keyword">super</span>(type: <span class="built_in">Type</span>.dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>文章中介绍了命名构造函数、<code>Factory</code> 和 <code>Static</code> 构造函数、构造函数与抽象类以及它们之间的区别，也提到它们各自的应用场景，怎么样，这些构造函数的打开方式你 Get 到了吗？如有疑问，欢迎留言。</p><p>关注公众号，第一时间看到更新内容：</p><p><img src="https://s2.loli.net/2022/11/09/fNBn2gWw8tVazkr.jpg" alt="Flutter技术实践"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/12/03/iqP1X5s6uKUrQJA.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nnxkcloud.com/2024/04/24/dart-%E8%AF%AD%E6%B3%95%E5%8E%9F%E6%9D%A5%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9%E5%84%BF/&quot;&gt;上一篇&lt;/a&gt; &lt;code&gt;Dart&lt;/code&gt; 语法的文章中介绍了对 &lt;code&gt;Future&lt;/code&gt;、&lt;code&gt;Streams&lt;/code&gt; 的 &lt;code&gt;unwrap&lt;/code&gt; 操作以及 &lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;的展开、合并和过滤等等，总觉得有点意犹未尽，还有很多有意思的并没有提到，本篇文章来介绍一下 &lt;code&gt;Dart&lt;/code&gt; 语言中面向对象的内容——构造函数，在我们日常开发中，对象的初始化（构造函数）有哪些方式，它们之间的区别在哪里，不同的构造函数都适用于哪些场景呢，本篇文章来聊聊这些内容。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter 设计模式全面解析：抽象工厂</title>
    <link href="http://www.nnxkcloud.com/2024/11/22/Flutter-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>http://www.nnxkcloud.com/2024/11/22/Flutter-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</id>
    <published>2024-11-22T02:08:02.000Z</published>
    <updated>2024-11-22T02:09:22.034Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/11/22/dGv5zCnOVfQrHpl.png" alt="181732186465_.pic.jpg"></p><p>设计模式作为软件开发中的经典解决方案，在 <code>Flutter</code> 的开发中也能为我们提供强大的架构支持。本文来介绍一下如何在 <code>Flutter</code> 中来实现抽象工厂设计模式，以及如何创建一系列相关或依赖对象并优雅地管理它们之间的复杂依赖关系。</p><span id="more"></span><p>日常开发中我们也能经常看到 <code>Flutter</code> 中运用抽象工厂的身影。比如，当需要针对不同操作系统（如 <code>iOS</code> 和<code>Android</code> ）设计不同风格的按钮和文本框时，使用抽象工厂模式可以确保组件风格的一致性，同时大幅降低代码耦合度，抽象工厂模式非常适合构建跨平台的UI框架。还有在数据提供层，利用抽象工厂设计模式可以用于灵活管理多种数据提供的方案，例如有网络请求 <code>REST API</code>、<code>Shared preferences</code>或者 <code>Data base</code>，主工程通过构建不同的工厂来获取数据。接下来，我们将以实际代码的示例，深入解析这种模式的结构和应用场景。</p><h3 id="什么是抽象工厂"><a href="#什么是抽象工厂" class="headerlink" title="什么是抽象工厂"></a>什么是抽象工厂</h3><p>网上搜索后是这么介绍它的，抽象工厂模式（<code>Abstract Factory Pattern</code>）是一种创建型设计模式，它提供一个接口来创建一系列相关或依赖的对象，而无需指定具体的实现类。主要目的是将创建对象系列封装在单独的工厂对象中，从而抽象对象创建过程。对于所有支持的对象系列，定义一个用于创建对象系列的通用接口，然后创建一个具体的工厂类来实现该接口。</p><p><img src="https://s2.loli.net/2024/11/21/heUNEpaQmRv23tJ.png"></p><p>参考上图，举个例子来说明一下，假设你有一家具公司，家具公司需要提供不同风格的家具套装（如现代风格、欧式风格）。每个套装包括沙发、桌子和椅子。为了便于扩展新的风格家具或修改现有产品，用抽象工厂模式实现家具的动态组合，其代码实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 产品接口：沙发</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sofa</span> </span>&#123; <span class="keyword">void</span> describe(); &#125;</span><br><span class="line"><span class="comment">// 2 产品接口：桌子</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123; <span class="keyword">void</span> describe(); &#125;</span><br><span class="line"><span class="comment">// 3 产品接口：椅子</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Chair</span> </span>&#123; <span class="keyword">void</span> describe(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 抽象工厂：家具工厂</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FurnitureFactory</span> </span>&#123;</span><br><span class="line">  Sofa createSofa();</span><br><span class="line">  Table createTable();</span><br><span class="line">  Chair createChair();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面位置1、2、3的代码是为每件产品明确声明接口 （沙发、桌子或椅子）。 然后，确保所有产品变体都继承这些接口。例如，所有风格的椅子都实现椅子接口；所有风格的桌子都实现桌子接口，以此类推。</p><p>接下来，位置4代码声明抽象工厂，包含所有产品构造方法的接口。 例如 <code>createSofa</code> 创建沙发 、<code>createTable</code> 创建桌子和 <code>createChair</code> 创建椅子。 并且这些方法必须返回抽象产品类型， 即上面抽取的那些接口： 沙发、桌子和椅子等等。</p><p>然后再基于抽象工厂接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 例如，现代家具工厂 <code>ModernFurnitureFactory</code> 只能创建现代沙发 <code>ModernSofa</code>、现代桌子 <code>ModernTable</code> 和现代椅子 <code>ModernChair</code> 对象；同理，欧式家具工厂 <code>EuropeanFurnitureFactory</code> 只能创建欧式沙发 <code>EuropeanSofaSofa</code> 、 欧式桌子 <code>EuropeanSofaTable</code> 和欧式椅子 <code>EuropeanSofaChair</code> 对象。</p><p><img src="https://s2.loli.net/2024/11/21/EA8KDjiVRgYpmxL.png"></p><p>下图中的代码是抽象产品接口的具体实现，包含了现代风格及欧式风格的沙发、桌子和椅子，</p><p><img src="https://s2.loli.net/2024/11/21/r2B1wDQXOaoIk46.png"></p><p>客户端代码实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> createFurniture(FurnitureFactory <span class="keyword">factory</span>) &#123;</span><br><span class="line">  <span class="keyword">final</span> sofa = <span class="keyword">factory</span>.createSofa();</span><br><span class="line">  <span class="keyword">final</span> table = <span class="keyword">factory</span>.createTable();</span><br><span class="line">  <span class="keyword">final</span> chair = <span class="keyword">factory</span>.createChair();</span><br><span class="line"></span><br><span class="line">  sofa.describe();</span><br><span class="line">  table.describe();</span><br><span class="line">  chair.describe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，如果我们还想新增一套家具风格（如：美式风格家具）也非常简单，实现抽象的产品接口<code>AmericanSofa</code>、<code>AmericanTable</code> 和 <code>AmericanChair</code>，然后建一个美式风格家具的工厂类 <code>AmericanFurnitureFactory</code> 并返回具体的产品就可以了。</p><p>以下是调用并输出结果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 创建现代风格家具</span></span><br><span class="line">  createFurniture(ModernFurnitureFactory());</span><br><span class="line">  <span class="comment">//  A modern style sofa</span></span><br><span class="line">  <span class="comment">//  A modern style table</span></span><br><span class="line">  <span class="comment">//  A modern style chair</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建欧式风格家具</span></span><br><span class="line">  createFurniture(EuropeanFurnitureFactory());</span><br><span class="line">  <span class="comment">// A European style sofa</span></span><br><span class="line">  <span class="comment">// A European style table</span></span><br><span class="line">  <span class="comment">// A European style chair</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式能确保套装风格的统一，同时又能方便扩展新风格的家具组合。在实际的应用场景中，即可以支持用户根据房间风格选择成套家具，又方便快速配置不同风格的房间布局，还可以提供模块化的家具搭配方案。</p><p>生活中能联想到类似的应用场景还有很多，如一家连锁快餐店提供不同风味的套餐（如亚洲风味、西式风味）。每个套餐包含主食、饮料和甜点。那么为了便于管理和扩展套餐，使用抽象工厂模式实现餐品的动态生成。</p><h3 id="抽象工厂模式结构"><a href="#抽象工厂模式结构" class="headerlink" title="抽象工厂模式结构"></a>抽象工厂模式结构</h3><p><img src="https://s2.loli.net/2024/11/21/uXlaAb1LfkitqYQ.png"></p><p>上图是抽象工厂模式的结构结构示意图，可以看出，抽象工厂模式一般分为5个部分。</p><ul><li>抽象工厂：接口声明了一组创建各种抽象产品的方法。</li><li>具体工厂：实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</li><li>抽象产品：构成系列产品的一组不同但相关的产品声明接口。</li><li>具体产品：是抽象产品的多种不同类型实现。 所有变体 （欧式&#x2F;现代） 都必须实现相应的抽象产品 （椅子&#x2F;沙发）。</li><li>客户端：仅使用抽象工厂和产品类声明的接口。</li></ul><p>抽象工厂隐藏了对象的创建逻辑，提供了一个统一的入口点，能做到创建逻辑与使用逻辑解耦，这样，在调用的地方只需调用抽象工厂的接口，而不关心具体对象如何构建或组成。通过这种抽象，产品的创建方式、数据结构和表示方式可以独立变化，而不会影响高层模块的逻辑。还解决了不同产品族的一致性的问题，同一个工厂负责创建一个产品系列的所有对象，这就保证了系列中的产品能够正确地协同工作，避免了混用不同产品的问题。</p><h3 id="与工厂模式的区别"><a href="#与工厂模式的区别" class="headerlink" title="与工厂模式的区别"></a>与工厂模式的区别</h3><p>抽象工厂模式和工厂方法模式都是创建型设计模式，抽象工厂模式处理的是产品族（多个相关产品），而工厂模式只处理的是单个产品的创建，也就是说可以将工厂方法设计模式视为抽象工厂模式的一个子集，即抽象工厂由几种工厂方法组成，其中每种方法仅创建一个特定对象。</p><h3 id="项目中的应用"><a href="#项目中的应用" class="headerlink" title="项目中的应用"></a>项目中的应用</h3><p>除了上面说到的例子，在项目开发过程中，也会大量的用到抽象工厂模式。尤其是对于 <code>Flutter</code> 做跨平台的开发来说，是非常合适的应用场景，比如当我们需要同时适配 <code>Mac</code> 和 <code>Window</code> 风格的 <code>Widget</code> 时，可以做以下操作：</p><p>定义抽象产品</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品：按钮</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> render();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品：文本框</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TextBox</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体产品</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Windows 风格按钮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsButton</span> <span class="keyword">implements</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> render() &#123; <span class="built_in">print</span>(<span class="string">&quot;Rendering a Windows button&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows 风格文本框</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsTextBox</span> <span class="keyword">implements</span> <span class="title">TextBox</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> render() &#123; <span class="built_in">print</span>(<span class="string">&quot;Rendering a Windows text box&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MacOS 风格按钮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacButton</span> <span class="keyword">implements</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> render() &#123; <span class="built_in">print</span>(<span class="string">&quot;Rendering a MacOS button&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MacOS 风格文本框</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacTextBox</span> <span class="keyword">implements</span> <span class="title">TextBox</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> render() &#123; <span class="built_in">print</span>(<span class="string">&quot;Rendering a MacOS text box&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象工厂</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UIFactory</span> </span>&#123;</span><br><span class="line">  Button createButton();</span><br><span class="line">  TextBox createTextBox();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体工厂</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsFactory</span> <span class="keyword">implements</span> <span class="title">UIFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Button createButton() =&gt; WindowsButton();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  TextBox createTextBox() =&gt; WindowsTextBox();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacFactory</span> <span class="keyword">implements</span> <span class="title">UIFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Button createButton() =&gt; MacButton();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  TextBox createTextBox() =&gt; MacTextBox();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端及调用代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> renderUI(UIFactory <span class="keyword">factory</span>) &#123;</span><br><span class="line">  <span class="keyword">final</span> button = <span class="keyword">factory</span>.createButton();</span><br><span class="line">  <span class="keyword">final</span> textBox = <span class="keyword">factory</span>.createTextBox();</span><br><span class="line"></span><br><span class="line">  button.render();</span><br><span class="line">  textBox.render();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 使用 Windows 工厂</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Rendering Windows UI:&quot;</span>);</span><br><span class="line">  renderUI(WindowsFactory());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 MacOS 工厂</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\nRendering MacOS UI:&quot;</span>);</span><br><span class="line">  renderUI(MacFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>抽象工厂模式的应用非常广泛，包括文章开头提到在数据提供层的设计中也会用到它，其作用就是提供一个接口来创建一系列相关或依赖的对象，是创建和管理多个对象的优雅且高效的解决方案，合理的使用有利于代码拓展，减少因产品族不一致带来的问题。但抽象工厂也并非万能，如果用在对单一产品的灵活扩展或者简单需求场景，那就有点儿显得过于笨重。因此，在使用此模式时，我们还是需要根据项目的实际需求进行权衡。</p><p>同时，任何设计模式的使用并是非硬性的框架约束，而是开发者应对复杂性和变化的一种工具。理解模式背后的设计思想，并将其灵活运用到项目中，才是提升代码质量的关键。也希望本篇能够帮到你，感谢您的阅读。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/11/22/dGv5zCnOVfQrHpl.png&quot; alt=&quot;181732186465_.pic.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;设计模式作为软件开发中的经典解决方案，在 &lt;code&gt;Flutter&lt;/code&gt; 的开发中也能为我们提供强大的架构支持。本文来介绍一下如何在 &lt;code&gt;Flutter&lt;/code&gt; 中来实现抽象工厂设计模式，以及如何创建一系列相关或依赖对象并优雅地管理它们之间的复杂依赖关系。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter 开发者必看！七个超实用的第三方 UI 库推荐</title>
    <link href="http://www.nnxkcloud.com/2024/11/06/Flutter-%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E7%9C%8B%EF%BC%81%E4%B8%83%E4%B8%AA%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9-UI-%E5%BA%93%E6%8E%A8%E8%8D%90/"/>
    <id>http://www.nnxkcloud.com/2024/11/06/Flutter-%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E7%9C%8B%EF%BC%81%E4%B8%83%E4%B8%AA%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9-UI-%E5%BA%93%E6%8E%A8%E8%8D%90/</id>
    <published>2024-11-06T09:12:54.000Z</published>
    <updated>2024-11-06T09:14:47.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/11/06/HhNv9JisSXp17Zb.png"></p><p>事情是这样的，前段时间和前端的同事在讨论关于前端 <code>UI</code> 库的问题，还列举了几个知名度比较高的 <code>UI</code> 库，如：有比较早的 <code>Bootstrap</code>，还有 <code>Element UI</code>、<code>Ant Design</code> 等等，提到了 <code>Flutter</code> 的 <code>UI</code> 库时，突然发现好像没怎么用到第三方的 <code>UI</code> 库，平时开发的时候用的最多的是 <code>Flutter</code> 自带 <code>Material Design</code> 组件库，直接支持谷歌 <code>Material Design</code> 规范，提供丰富的 <code>Android</code> 风格组件和主题配置，还有为 <code>iOS</code> 应用设计 <code>Cupertino</code> 组件库，是的 <code>Flutter</code> 开发的应用也能做到原生的视觉体验，加上 <code>Flutter</code> 官方库中还包含一些基础 <code>Widgets</code>，比如 <code>Container</code>、<code>Row</code>、<code>Column</code>、<code>Stack</code> 等，这些是构建 <code>Flutter</code> 界面的核心组件，支持高灵活性的自定义布局。已经有了这么多官方的 <code>UI</code> 组件，还需要第三方的 <code>UI</code> 库吗？这个问题我们先放一放，这里先来盘点一下个人觉得比较好用的开源的 <code>Flutter</code> 第三方组件库。</p><span id="more"></span><h3 id="1-getwidget"><a href="#1-getwidget" class="headerlink" title="1. getwidget"></a>1. <code>getwidget</code></h3><p><code>getwidget</code> 包含丰富的组件，如进度条、对话框、浮动按钮、分段控制等拥有超过 100 多种可重用的 <code>UI</code> 组件，可以帮助开发者快速搭建用户界面，尤其适合在应用开发中高效使用现成组件。该库轻量级且稳定，既可以用来开发 <code>App</code> 也能开发 <code>Web</code> 应用，而且他们的介绍里面还提到要为 <code>Flutter</code> 社区提供最好的 <code>Flutter UI</code> 库，而且他们还开源使用了该组件库的 <code>App</code>。<br><img src="https://s2.loli.net/2024/11/06/aNfSJYmcHhryQpZ.png"></p><h3 id="2-elevarm-ui"><a href="#2-elevarm-ui" class="headerlink" title="2. elevarm_ui"></a>2. <code>elevarm_ui</code></h3><p>这是一个很低调但组件非常齐全的 <code>Flutter UI</code> 库，涵盖了日常开发中几乎要用到大部分 <code>UI</code> 组件，也有一些如 <code>BarChart</code>、<code>LineChart</code> 等 <code>Chart</code> 组件，还有很多非常好用的各种的<code>Alert</code>，如通知的 <code>ElevarmAlert</code>、用于对话框的 <code>ElevarmConfirmAlertDialog</code>，甚至可自定义的输入字段，如支持提示和帮助文本 <code>ElevarmAutocompleteInputField</code>，还可以使用自定义模糊和阴影效果，甚至连用在<code>Web</code>的一些常见如404页面等也在其中，更多的组件介绍可以去 <code>pub.dev</code> 看看。不过从组件的风格来看，这些的组件更适合用来做 <code>Flutter Web</code>。<br><img src="https://s2.loli.net/2024/11/06/VvazpgDmwT23jAW.png"></p><h3 id="3-VelocityX"><a href="#3-VelocityX" class="headerlink" title="3. VelocityX"></a>3. <code>VelocityX</code></h3><p>一个极简的 <code>Flutter</code> 框架，其主要特点有：<code>VelocityX</code> 支持响应式布局，适配不同设备屏幕尺寸，还内置了许多便捷的响应式工具，使其在多端适配上更具优势；直观的链式语法，使得 <code>UI</code> 布局更加简洁且代码结构清晰。组件包的大小也是轻量化的，除了提供一些常见的 <code>UI</code> 组件外，<code>VelocityX</code> 还集成了简单的状态管理工具，如 <code>VelocityStore</code>，比较适用于小型项目或特定组件的状态管理。<br><img src="https://s2.loli.net/2024/11/06/5iMvBYIoZJfcsub.png"></p><h3 id="4-flukit"><a href="#4-flukit" class="headerlink" title="4. flukit"></a>4. <code>flukit</code></h3><p>与一些大型 <code>UI</code> 库相比，<code>Flukit</code> 更注重在日常开发中常见的辅助功能，比如自定义的滚动加载、图片缓存和裁剪等，这些功能可能在 <code>Flutter</code> 官方库中实现起来较为繁琐。包含的组件有： <code>ScaleView</code>、<code>SliverFlexibleHeader</code>、<code>Swiper</code>、<code>PullRefresh</code>、<code>WaterMark</code>、<code>GradientCircularProgressIndicator</code> 等等组件，拿来即用，不少组件用到实际项目中确实能提高开发的效率，不再需要自己手动实现。下图是部分组件介绍。<br><img src="https://s2.loli.net/2024/11/06/Rx5IhD6Qjw7s8Ub.png"></p><h3 id="5-flutterlibrary"><a href="#5-flutterlibrary" class="headerlink" title="5. flutterlibrary"></a>5. <code>flutterlibrary</code></h3><p>这里的 <code>flutterlibrary</code> 是网站 <a href="http://www.flutterlibrary.com/">www.flutterlibrary.com</a> 的简写，有意思的是该网站上直接开源了各种功能和领域的 <code>App</code> 代码，包括电子商务、食品、社交网络和旅行等，网站中以各种页面的形式分类，如<code>Splash</code>、<code>Log in</code>、<code>Home</code>等等一系列高级组件和现成的模板，可帮助加快 <code>Flutter</code> 应用开发过程，除此之外，还有复杂的动画实现，对于那些自己独立设计开发 <code>App</code> 的来说简直太香了，直接可以参考借鉴这些完成度很高的页面。<br><img src="https://s2.loli.net/2024/11/06/PCN96F5fMtoiQBa.png"></p><h3 id="6-macosui"><a href="#6-macosui" class="headerlink" title="6. macosui"></a>6. <code>macosui</code></h3><p>从名称上可以看出来，<code>macosui</code> 专门为 <code>macOS</code> 打造，提供类似 <code>Apple</code> 原生的 <code>UI</code> 组件，模仿 <code>macOS</code> 的原生外观和交互细节，使得应用在 <code>macOS</code> 上拥有接近原生的视觉体验。它包括了菜单、对话框、列表等符合 <code>macOS</code> 人机界面指南 (<code>HIG</code>) 的组件。这也是我最近在使用的组件库，为什么用它呢？因为 <code>Flutter</code> 虽然可以用来开发 <code>macos</code> 应用，但是对于 <code>macos</code> 上的组件的支持不是很友好，不完全符合 <code>Apple</code> 原生风格，官方的组件库 更注重跨平台支持，而不是特定于任何平台。<br><img src="https://s2.loli.net/2024/11/06/JpAkxdPD5VjHzRv.png"></p><h3 id="7-fluent-ui"><a href="#7-fluent-ui" class="headerlink" title="7. fluent_ui"></a>7. <code>fluent_ui</code></h3><p>从它的第一句话介绍：<code>Design beautiful native Windows apps using Flutter</code> 可以看出主要用途，该组件通过实现 <code>Microsoft Fluent Design System</code> 中的控件样式，与 <code>Flutter</code> 官方提供的 <code>Material</code> 和 <code>Cupertino</code> 组件相比，更贴近 <code>Windows</code> 用户熟悉的界面风格。<br><img src="https://s2.loli.net/2024/11/06/EkgpxvMRQ7ynDdP.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面的 <code>UI</code> 组件库排名不分先后，每个组件库有自己的特点和适用的平台，日常的开发根据需要去选择。现在回到文章开头提出的问题：<code>Flutter</code> 已经有了这么多官方的 <code>UI</code> 组件，还需要使用第三方的 <code>UI</code> 库吗？</p><p>官方组件库在基础控件方面确实非常完备，但许多复杂、特殊的组件（如高级图表、动画化按钮、社交媒体分享组件等）并未包含。第三方 <code>UI</code> 库通常会包含这些高级组件，以便开发者更快速地构建复杂界面。再就是 <code>Flutter</code> 官方的组件通常遵循 <code>Material Design</code> 和 <code>Cupertino</code> 风格，但在需要实现特定平台的自定义外观或独特设计时，官方库的适配会比较有限，而第三方库能够提供更加个性化的设计风格，让开发者打造出独特的视觉效果。还有第三方 <code>UI</code> 库通常会对组件的样式、动画等做出更多优化，简化代码和布局设计，对不同平台也进行了优化，如<code>macosui</code> 和 <code>fluent_ui</code>，能直接提升开发效率。那么你在使用哪个第三方 <code>UI</code> 库呢？或者说有没有想推荐的 <code>UI</code> 库？欢迎留言。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/11/06/HhNv9JisSXp17Zb.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;事情是这样的，前段时间和前端的同事在讨论关于前端 &lt;code&gt;UI&lt;/code&gt; 库的问题，还列举了几个知名度比较高的 &lt;code&gt;UI&lt;/code&gt; 库，如：有比较早的 &lt;code&gt;Bootstrap&lt;/code&gt;，还有 &lt;code&gt;Element UI&lt;/code&gt;、&lt;code&gt;Ant Design&lt;/code&gt; 等等，提到了 &lt;code&gt;Flutter&lt;/code&gt; 的 &lt;code&gt;UI&lt;/code&gt; 库时，突然发现好像没怎么用到第三方的 &lt;code&gt;UI&lt;/code&gt; 库，平时开发的时候用的最多的是 &lt;code&gt;Flutter&lt;/code&gt; 自带 &lt;code&gt;Material Design&lt;/code&gt; 组件库，直接支持谷歌 &lt;code&gt;Material Design&lt;/code&gt; 规范，提供丰富的 &lt;code&gt;Android&lt;/code&gt; 风格组件和主题配置，还有为 &lt;code&gt;iOS&lt;/code&gt; 应用设计 &lt;code&gt;Cupertino&lt;/code&gt; 组件库，是的 &lt;code&gt;Flutter&lt;/code&gt; 开发的应用也能做到原生的视觉体验，加上 &lt;code&gt;Flutter&lt;/code&gt; 官方库中还包含一些基础 &lt;code&gt;Widgets&lt;/code&gt;，比如 &lt;code&gt;Container&lt;/code&gt;、&lt;code&gt;Row&lt;/code&gt;、&lt;code&gt;Column&lt;/code&gt;、&lt;code&gt;Stack&lt;/code&gt; 等，这些是构建 &lt;code&gt;Flutter&lt;/code&gt; 界面的核心组件，支持高灵活性的自定义布局。已经有了这么多官方的 &lt;code&gt;UI&lt;/code&gt; 组件，还需要第三方的 &lt;code&gt;UI&lt;/code&gt; 库吗？这个问题我们先放一放，这里先来盘点一下个人觉得比较好用的开源的 &lt;code&gt;Flutter&lt;/code&gt; 第三方组件库。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>这么好看的 Flutter 搜索框，快来看看是怎么实现的</title>
    <link href="http://www.nnxkcloud.com/2024/11/05/%E8%BF%99%E4%B9%88%E5%A5%BD%E7%9C%8B%E7%9A%84-Flutter-%E6%90%9C%E7%B4%A2%E6%A1%86%EF%BC%8C%E5%BF%AB%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
    <id>http://www.nnxkcloud.com/2024/11/05/%E8%BF%99%E4%B9%88%E5%A5%BD%E7%9C%8B%E7%9A%84-Flutter-%E6%90%9C%E7%B4%A2%E6%A1%86%EF%BC%8C%E5%BF%AB%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</id>
    <published>2024-11-05T03:00:55.000Z</published>
    <updated>2024-11-05T03:04:02.168Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/11/05/vWzwRDjZrxiMfH2.png"></p><p>最近项目中在实现一个搜索的功能，根据 <code>Flutter</code> 的类似组件的调用习惯，输入 <code>showSearch</code> 后发现还真有，跳进源码中一看，<code>Flutter</code> 已经实现了相应的 <code>Widget</code> 和交互，简直不要太方便了，先来看看如何调用的。</p><span id="more"></span><h3 id="showSearch-方法介绍"><a href="#showSearch-方法介绍" class="headerlink" title="showSearch 方法介绍"></a><code>showSearch</code> 方法介绍</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T?&gt; showSearch&lt;T&gt;(&#123;</span><br><span class="line">  <span class="keyword">required</span> BuildContext context,</span><br><span class="line">  <span class="keyword">required</span> SearchDelegate&lt;T&gt; delegate,</span><br><span class="line">  <span class="built_in">String?</span> query = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="built_in">bool</span> useRootNavigator = <span class="keyword">false</span>,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(delegate != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(context != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(useRootNavigator != <span class="keyword">null</span>);</span><br><span class="line">  delegate.query = query ?? delegate.query;</span><br><span class="line">  delegate._currentBody = _SearchBody.suggestions;</span><br><span class="line">  <span class="keyword">return</span> Navigator.of(context, rootNavigator: useRootNavigator).push(_SearchPageRoute&lt;T&gt;(</span><br><span class="line">    delegate: delegate,</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数定义在源码 <code>flutter/lib/src/material/search.dart</code> 文件中，根据该函数要求须传入一个 <code>context</code> 和 <code>delegate</code>，<code>context</code> 是我们的老朋友，这里就无需过多介绍了。但是这个 <code>delegate</code> (<code>SearchDelegate</code> 类)是干啥的？继续跳到 <code>SearchDelegate</code> 发现<code>SearchDelegate</code> 是一个抽象类，<code>SearchDelegate</code> 第一句介绍 <code>Delegate for [showSearch] to define the content of the search page.</code> 定义搜索页面的内容，也就是说需要我们创建一个继承自 <code>SearchDelegate</code> 的子类来实例化参数 <code>delegate</code>，下面是这个子类<code>CustomSearchPageDelegate</code>的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSearchPageDelegate</span> <span class="keyword">extends</span> <span class="title">SearchDelegate</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 搜索框右边的显示，如返回按钮</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt;? buildActions(BuildContext context) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索框左边的显示，如搜索按钮</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget? buildLeading(BuildContext context) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索的结果展示，如列表 ListView</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildResults(BuildContext context) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输入框输入内容时给出的提示</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildSuggestions(BuildContext context) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出我们需要返回4个 <code>Widget</code> 来显示内容，其中 <code>buildLeading</code> 和 <code>buildActions</code> 分别对应搜索框左右两边的内容，通常是 <code>button</code>，如 <code>buildLeading</code> 是返回按钮，<code>buildActions</code> 右边是搜索按钮。<code>buildResults</code> 则表示搜索的结果展示，通常是一个列表，而 <code>buildSuggestions</code> 展示当用户在输入框输入内容时给出的提示，展示多条提示内容时也会用到列表（<code>ListView</code>）。</p><h3 id="实现-CustomSearchPageDelegate"><a href="#实现-CustomSearchPageDelegate" class="headerlink" title="实现 CustomSearchPageDelegate"></a>实现 <code>CustomSearchPageDelegate</code></h3><p>接下来以搜索文章为例子利用自定义的<code>CustomSearchPageDelegate</code> 类实现一下搜索功能。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_svg/flutter_svg.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_todo/pages/search_page/data_item_model.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_todo/pages/search_page/search_item_widget.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSearchPageDelegate</span> <span class="keyword">extends</span> <span class="title">SearchDelegate</span>&lt;<span class="title">DataItemModel</span>&gt; </span>&#123;</span><br><span class="line">  CustomSearchPageDelegate(&#123;</span><br><span class="line">    <span class="built_in">String?</span> hintText,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.models,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(</span><br><span class="line">          searchFieldLabel: hintText,</span><br><span class="line">          keyboardType: TextInputType.text,</span><br><span class="line">          textInputAction: TextInputAction.search,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">搜素提示</span></span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; suggestions = [</span><br><span class="line">    <span class="string">&quot;Flutter&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flutter开发7个建议，让你的工作效率飙升&quot;</span>,</span><br><span class="line">    <span class="string">&quot;浅谈 Flutter 的并发和 isolates&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flutter 技术实践&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flutter 中如何优雅地使用弹框&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flutter设计模式全面解析：单例模式&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flutter Dart&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flutter 状态管理&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flutter大型项目架构：UI设计系统实现（二）&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flutter大型项目架构：分层设计篇&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Dart 语法原来这么好玩儿&quot;</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">模拟数据，一般调用接口返回的数据</span></span></span><br><span class="line">  <span class="built_in">List</span>&lt;DataItemModel&gt; models = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">搜索结果</span></span></span><br><span class="line">  <span class="built_in">List</span>&lt;DataItemModel&gt; results = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">右边的搜索按钮</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt;? buildActions(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      InkWell(</span><br><span class="line">        onTap: () &#123;&#125;,</span><br><span class="line">        child: Container(</span><br><span class="line">          margin: <span class="keyword">const</span> EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">          height: <span class="number">30</span>,</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          decoration: BoxDecoration(</span><br><span class="line">              color: Colors.red, borderRadius: BorderRadius.circular(<span class="number">30</span>)),</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">0</span>, horizontal: <span class="number">16</span>),</span><br><span class="line">          child: <span class="keyword">const</span> Text(</span><br><span class="line">            <span class="string">&quot;搜索&quot;</span>,</span><br><span class="line">            style: TextStyle(color: Colors.white, fontSize: <span class="number">14</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">左边返回按钮</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget? buildLeading(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> InkWell(</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          <span class="comment">/// <span class="language-markdown">返回操作，关闭搜索功能</span></span></span><br><span class="line">          <span class="comment">/// <span class="language-markdown">这里应该返回 null</span></span></span><br><span class="line">          close(context, DataItemModel());</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">15.0</span>),</span><br><span class="line">          child: SvgPicture.asset(</span><br><span class="line">            <span class="string">&quot;assets/images/arrow.svg&quot;</span>,</span><br><span class="line">            height: <span class="number">22</span>,</span><br><span class="line">            color: Colors.black,</span><br><span class="line">          ),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">搜索结果列表</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildResults(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.separated(</span><br><span class="line">      physics: <span class="keyword">const</span> BouncingScrollPhysics(),</span><br><span class="line">      itemCount: results.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        DataItemModel item = results[index];</span><br><span class="line">        <span class="comment">/// <span class="language-markdown">自定义Widget，用来显示每一条搜素到的数据。</span></span></span><br><span class="line">        <span class="keyword">return</span> SearchResultItemWidget(</span><br><span class="line">          itemModel: item,</span><br><span class="line">          click: () &#123;</span><br><span class="line">            <span class="comment">/// <span class="language-markdown">点击一条数据后关闭搜索功能，返回该条数据。</span></span></span><br><span class="line">            close(context, item);</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">      separatorBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> divider;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">提示词列表</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildSuggestions(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; suggestionList = query.isEmpty</span><br><span class="line">        ? []</span><br><span class="line">        : suggestions</span><br><span class="line">            .where((p) =&gt; p.toLowerCase().contains(query.toLowerCase()))</span><br><span class="line">            .toList();</span><br><span class="line">    <span class="keyword">if</span> (suggestionList.isEmpty) <span class="keyword">return</span> Container();</span><br><span class="line">    <span class="keyword">return</span> ListView.separated(</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="built_in">String</span> name = suggestionList[index];</span><br><span class="line">        <span class="keyword">return</span> InkWell(</span><br><span class="line">          onTap: () &#123;</span><br><span class="line">            <span class="comment">/// <span class="language-markdown">点击提示词，会根据提示词开始搜索，这里模拟从models数组中搜索数据。</span></span></span><br><span class="line">            query = name;</span><br><span class="line">            results = models</span><br><span class="line">                .where((e) =&gt;</span><br><span class="line">                    (e.title?.toLowerCase().contains(name.toLowerCase()) ??</span><br><span class="line">                        <span class="keyword">false</span>) ||</span><br><span class="line">                    (e.desc?.toLowerCase().contains(name.toLowerCase()) ??</span><br><span class="line">                        <span class="keyword">false</span>))</span><br><span class="line">                .toList();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// <span class="language-markdown">展示结果，这个时候就调用 buildResults，主页面就会用来显示搜索结果</span></span></span><br><span class="line">            showResults(context);</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Container(</span><br><span class="line">            color: Colors.white,</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">15</span>, horizontal: <span class="number">10</span>),</span><br><span class="line">            child: Row(</span><br><span class="line">              children: [</span><br><span class="line">                SvgPicture.asset(</span><br><span class="line">                  <span class="string">&quot;assets/images/search.svg&quot;</span>,</span><br><span class="line">                  height: <span class="number">16</span>,</span><br><span class="line">                  color: <span class="keyword">const</span> Color(<span class="number">0xFF373737</span>),</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">const</span> SizedBox(</span><br><span class="line">                  width: <span class="number">4</span>,</span><br><span class="line">                ),</span><br><span class="line">                RichText(</span><br><span class="line">                  text: TextSpan(children: getSpans(name)),</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">      itemCount: suggestionList.length,</span><br><span class="line">      separatorBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> divider;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">分割线</span></span></span><br><span class="line">  Widget <span class="keyword">get</span> divider =&gt; Container(</span><br><span class="line">        color: <span class="keyword">const</span> Color(<span class="number">0xFFAFAFAF</span>),</span><br><span class="line">        height: <span class="number">0.3</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">富文本提示词，其中如果和输入的文本匹配到的关键字显示红色。</span></span></span><br><span class="line">  <span class="built_in">List</span>&lt;TextSpan&gt; getSpans(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="built_in">int</span> start = name.toLowerCase().indexOf(query.toLowerCase());</span><br><span class="line">    <span class="built_in">String</span> end = name.substring(start, start + query.length);</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; spanStrings = name</span><br><span class="line">        .toLowerCase()</span><br><span class="line">        .replaceAll(end.toLowerCase(), <span class="string">&quot;*<span class="subst">$&#123;end.toLowerCase()&#125;</span>*&quot;</span>)</span><br><span class="line">        .split(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> spanStrings</span><br><span class="line">        .map((e) =&gt; (e.toLowerCase() == end.toLowerCase()</span><br><span class="line">            ? TextSpan(</span><br><span class="line">                text: e,</span><br><span class="line">                style: <span class="keyword">const</span> TextStyle(color: Colors.red, fontSize: <span class="number">14</span>))</span><br><span class="line">            : TextSpan(</span><br><span class="line">                text: e,</span><br><span class="line">                style:</span><br><span class="line">                    <span class="keyword">const</span> TextStyle(color: Color(<span class="number">0xFF373737</span>), fontSize: <span class="number">14</span>))))</span><br><span class="line">        .toList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要说明一下，<code>query</code> 关键字是输入框的文本内容。调用的时候实例化一下该类，传递给 <code>shwoSearch</code> 的 <code>delegate</code> 参数。下图就是我们看到的效果：<br><img src="https://s2.loli.net/2024/11/04/C5gTyVmRvKYwUpX.jpg" alt="521730704175_.pic.jpg"></p><h3 id="总结问题"><a href="#总结问题" class="headerlink" title="总结问题"></a>总结问题</h3><p>以上图片的搜索框还可以通过重写 <code>appBarTheme</code> 来定制自己想要的 <code>UI</code> 效果，虽然可以这样，但是和我们要实现的效果比起来还相差甚远，尤其是顶部的搜索框，其左右两边的留白区域过多，背景颜色无法调整，内部的输入框 <code>TextField</code> 也无法定制自己想要的效果，如不能调整其圆角、背景颜色以及添加额外控件等等。</p><p>还有一点就是当我们点击返回按钮调用 <code>close</code> 时，这里返回值是泛型 <code>T</code> 却不支持 <code>null</code> 类型，在文章的开头，我们可以看到 <code>shwoSearch</code> 的 <code>delegate</code> 参数类型是 <code>SearchDelegate&lt;T&gt;</code>，所以创建 <code>CustomSearchPageDelegate</code> 时必须这样去声明。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSearchPageDelegate</span> <span class="keyword">extends</span> <span class="title">SearchDelegate</span>&lt;<span class="title">DataItemModel</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而我们想要实现这样去声明</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSearchPageDelegate</span> <span class="keyword">extends</span> <span class="title">SearchDelegate</span>&lt;<span class="title">DataItemModel</span>?&gt;</span></span><br></pre></td></tr></table></figure><p>这样当我们调用 <code>close</code> 时可以做到传 <code>null</code>，在外面调用的位置可以对返回值进行判断，返回值为 <code>null</code> 就不作任何处理。</p><p>交互上，在点击键盘上的 <code>搜索</code> 按键时，直接调用的是 <code>showResults</code> 函数，而通常的操作是需要调用搜索的接口拿到数据后，再去调用 <code>showResults</code> 函数来展示搜索结果的数据。</p><p>对于上述问题，我们可以做什么呢？</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>想要到达我们需要的效果，还是需要看看 <code>Flutter</code> 的源码是怎么实现的，我们再次来到 <code>flutter/lib/src/material/search.dart</code> 文件中，可以看到该文件中定义了除上面提到的抽象类 <code>SearchDelegate</code> 和全局函数 <code>showSearch</code> 之外，还有内部类 <code>_SearchPageRoute</code> 和 <code>_SearchPage</code>。 <code>_SearchPageRoute</code> 继承自 <code>PageRoute</code>，顾名思义就是负责路由跳转及转场动画的。</p><p>以下是 <code>_SearchPageRoute</code> 部分代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_SearchPageRoute</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">PageRoute</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  _SearchPageRoute(&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.delegate,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(delegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    delegate._route = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> SearchDelegate&lt;T&gt; delegate;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// <span class="language-markdown">...</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildPage(</span><br><span class="line">    BuildContext context,</span><br><span class="line">    Animation&lt;<span class="built_in">double</span>&gt; animation,</span><br><span class="line">    Animation&lt;<span class="built_in">double</span>&gt; secondaryAnimation,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> _SearchPage&lt;T&gt;(</span><br><span class="line">      delegate: delegate,</span><br><span class="line">      animation: animation,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// <span class="language-markdown">...</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写父类的 <code>buildPage</code> 方法，将 <code>delegate</code> 传递给 <code>_SearchPage</code> 并将其返回，而所有的 <code>UI</code> 逻辑都在这个 <code>_SearchPage</code> 中，来到 <code>_SearchPage</code> 的 <code>build</code> 函数中就可以看到下面的实现。</p><p><code>_SearchPage</code> 的 <code>build</code> 函数代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(debugCheckHasMaterialLocalizations(context));</span><br><span class="line">  <span class="keyword">final</span> ThemeData theme = widget.delegate.appBarTheme(context);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> searchFieldLabel = widget.delegate.searchFieldLabel</span><br><span class="line">    ?? MaterialLocalizations.of(context).searchFieldLabel;</span><br><span class="line">  Widget? body;</span><br><span class="line">  <span class="comment">// _currentBody 枚举类型_SearchBody，用来区分当前body是展示提示列表还是搜索结果列表，</span></span><br><span class="line">  <span class="comment">// 当调用 SearchDelegate 中 showResults 函数时，_currentBody = _SearchBody.results</span></span><br><span class="line">  <span class="comment">// 当调用 SearchDelegate 中 showSuggestions 函数时，_currentBody = _SearchBody.suggestions</span></span><br><span class="line">  <span class="keyword">switch</span>(widget.delegate._currentBody) &#123;</span><br><span class="line">    <span class="keyword">case</span> _SearchBody.suggestions:</span><br><span class="line">      body = KeyedSubtree(</span><br><span class="line">        key: <span class="keyword">const</span> ValueKey&lt;_SearchBody&gt;(_SearchBody.suggestions),</span><br><span class="line">        child: widget.delegate.buildSuggestions(context),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _SearchBody.results:</span><br><span class="line">      body = KeyedSubtree(</span><br><span class="line">        key: <span class="keyword">const</span> ValueKey&lt;_SearchBody&gt;(_SearchBody.results),</span><br><span class="line">        child: widget.delegate.buildResults(context),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">null</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Semantics(</span><br><span class="line">    explicitChildNodes: <span class="keyword">true</span>,</span><br><span class="line">    scopesRoute: <span class="keyword">true</span>,</span><br><span class="line">    namesRoute: <span class="keyword">true</span>,</span><br><span class="line">    label: routeName,</span><br><span class="line">    child: Theme(</span><br><span class="line">      data: theme,</span><br><span class="line">      child: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          leading: widget.delegate.buildLeading(context),</span><br><span class="line">          title: TextField(</span><br><span class="line">            controller: widget.delegate._queryTextController,</span><br><span class="line">            focusNode: focusNode,</span><br><span class="line">            style: widget.delegate.searchFieldStyle ?? theme.textTheme.titleLarge,</span><br><span class="line">            textInputAction: widget.delegate.textInputAction,</span><br><span class="line">            keyboardType: widget.delegate.keyboardType,</span><br><span class="line">            onSubmitted: (<span class="built_in">String</span> _) &#123;</span><br><span class="line">              widget.delegate.showResults(context);</span><br><span class="line">            &#125;,</span><br><span class="line">            decoration: InputDecoration(hintText: searchFieldLabel),</span><br><span class="line">          ),</span><br><span class="line">          actions: widget.delegate.buildActions(context),</span><br><span class="line">          bottom: widget.delegate.buildBottom(context),</span><br><span class="line">        ),</span><br><span class="line">        body: AnimatedSwitcher(</span><br><span class="line">          duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>),</span><br><span class="line">          child: body,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>_SearchPage</code> 中的实现也非常简单，就是一个嵌入到 <code>AppBar</code> 中的搜索框和呈现 <code>suggestion list</code> 及 <code>result list</code> 的 <code>body</code>。想要定制自己的 <code>UI</code> 效果，改的也是该位置的代码。</p><h3 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h3><p><code>UI</code> 方面主要针对 <code>TextField</code> 和 <code>AppBar</code> 代码修改，怎么改就看想要实现什么效果了。参考 <code>Flutter</code> 官方的源码，重新实现一个的 <code>_SearchPage</code> 类，然后在 <code>_SearchPageRoute</code> 替换成自己写的 <code>_SearchPage</code>，再去 <code>SearchDelegate</code> 替换一下修改过的 <code>_SearchPageRoute</code>。</p><p>还一个问题怎么实现调用 <code>close</code> 时可以返回 <code>null</code> 的结果内呢？除了上面提到的这样去声明</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSearchPageDelegate</span> <span class="keyword">extends</span> <span class="title">SearchDelegate</span>&lt;<span class="title">DataItemModel</span>?&gt;</span></span><br></pre></td></tr></table></figure><p>之外，还需要修改 <code>_SearchPageRoute</code> 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改之后</span></span><br><span class="line"><span class="keyword">final</span> CustomSearchDelegate&lt;T?&gt; delegate;</span><br><span class="line"><span class="comment">// 改之前</span></span><br><span class="line"><span class="comment">// final CustomSearchDelegate&lt;T&gt; delegate;</span></span><br></pre></td></tr></table></figure><p>重新定义一个全局函数 <code>showSearchWithCustomiseSearchDelegate</code>，和官方的区分开来。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T?&gt; showSearchWithCustomiseSearchDelegate&lt;T&gt;(&#123;</span><br><span class="line">  <span class="keyword">required</span> BuildContext context,</span><br><span class="line">  <span class="comment">// 这里的泛型由原来的 T 改成了 T?</span></span><br><span class="line">  <span class="keyword">required</span> CustomSearchDelegate&lt;T?&gt; delegate,</span><br><span class="line">  <span class="built_in">String?</span> query = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="built_in">bool</span> useRootNavigator = <span class="keyword">false</span>,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  delegate.query = query ?? delegate.query;</span><br><span class="line">  delegate._currentBody = _SearchBody.suggestions;</span><br><span class="line">  <span class="comment">// 这里的 _SearchPageRoute 是我们自己实现的类</span></span><br><span class="line">  <span class="keyword">return</span> Navigator.of(context, rootNavigator: useRootNavigator)</span><br><span class="line">      .push(_SearchPageRoute&lt;T&gt;(</span><br><span class="line">    delegate: delegate,</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看最终调用上面的函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DataItemModel? result =</span><br><span class="line">    <span class="keyword">await</span> showSearchWithCustomiseSearchDelegate(</span><br><span class="line">        context: context,</span><br><span class="line">        delegate: SearchPageDelegate(</span><br><span class="line">            hintText: <span class="string">&quot;Flutter 技术实践&quot;</span>, models: models));</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">to detail page</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决交互上的问题，需要在我们自己抽象类 <code>SearchDelegate</code> 单独定义一个函数 <code>onSubmit</code>，点击键盘上的搜索按键和右边的搜索按钮调用 <code>onSubmit</code> 函数，如：<code>widget.delegate.onSubmit(context, text);</code>，在 <code>SearchDelegate</code> 子类的  <code>onSubmit</code>  中来实现具体的逻辑，如发送网络请求，返回数据后在调用 <code>showResults</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> onSubmit(BuildContext context, <span class="built_in">String</span> text) &#123;</span><br><span class="line">  <span class="comment">// 发送网络请求，拿到数据。</span></span><br><span class="line">  <span class="comment">// showResults(context);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体实现的代码量多，就不在文中贴出来了，具体实现大家可以参考这里的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/joedrm/flutter_todo/blob/master/lib/pages/search_page/search_page_delegate.dart</span><br></pre></td></tr></table></figure><p>下图是最终实现效果：</p><p><img src="https://s2.loli.net/2024/11/04/GsJVRpq3T1No7gd.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>自定义搜索框的实现整体来说还是比较简单的，相比于源码改动的地方并不多，就可以显示想要的效果。当然还有其它更多的实现方式，这里只是提供了一种分析思路。我们还可以发散一下，去看看其它的如：<code>showBottomSheet</code>、<code>showDialog</code> 等等和 <code>SearchDelegate</code>，他们直之间也有不少类似的地方，当我想要自定义自己的控件时，会发现其实很多答案就在官方的源码里，动手改吧改吧就出来了。最后聊一下近况，近期有一些想法在忙着实现，时间有点安排不过来，文章的更新就有点儿偷懒了，跟大家说声抱歉，后面有机会单独来分享一下最近忙的事情，最后感谢大家耐心的阅读！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/11/05/vWzwRDjZrxiMfH2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近项目中在实现一个搜索的功能，根据 &lt;code&gt;Flutter&lt;/code&gt; 的类似组件的调用习惯，输入 &lt;code&gt;showSearch&lt;/code&gt; 后发现还真有，跳进源码中一看，&lt;code&gt;Flutter&lt;/code&gt; 已经实现了相应的 &lt;code&gt;Widget&lt;/code&gt; 和交互，简直不要太方便了，先来看看如何调用的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter大型项目架构：私有组件包管理</title>
    <link href="http://www.nnxkcloud.com/2024/07/25/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://www.nnxkcloud.com/2024/07/25/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2024-07-25T09:31:35.000Z</published>
    <updated>2024-12-03T02:38:04.003Z</updated>
    
    <content type="html"><![CDATA[<p>随着项目功能模块越来越多，怎么去管理这些私有组件包是一个不得不面对的问题，特别对于团队开发来讲，一些通用的公共组件往往会在多个项目间使用，多的有几十个，每个组件包都有有自己的版本，组件包之间还有依赖关系，那么如何在团队内部共享私有组件包，控制依赖私有组件包的版本和组件包的更新维护，而且要确保其安全环境，也就是没有公网无法访问的安全环境，这些都是需要考虑的，如何去管理这些组件对提升开发效率和代码质量就显得尤为重要，那有日常开发中哪些的方式来管理私有组件库呢？本篇文章就来介绍一下。</p><span id="more"></span><h3 id="主工程中管理组件"><a href="#主工程中管理组件" class="headerlink" title="主工程中管理组件"></a>主工程中管理组件</h3><p>主工程新建一个 <code>packages</code> 目录，从主工程抽取出来的组件放在改目录下，目录结构如下图：</p><p><img src="https://s2.loli.net/2024/06/15/X6OpUV7PEcLM8hB.png" alt="4881718430073_.pic.png"></p><p>这种将组件分离到 <code>packages</code> 目录下更加简单直接，也可以实现模块化管理。但是由于所有代码都放在主工程的目录下，使用同一个 <code>git</code> 仓库，对于每个组件独立开发和维护不太方便，各组件的依赖关系也不是很明了，如主工程明明不需要直接依赖于 <code>data</code> 组件，但 <code>data</code> 组件的代码却在主工程的目录下面，两者之间本应该没有任何直接关系。</p><h3 id="melos-管理组件"><a href="#melos-管理组件" class="headerlink" title="melos 管理组件"></a><code>melos</code> 管理组件</h3><p>在之前的文章《Flutter大型项目架构：分层设计篇》中介绍了如何使用 <code>melos</code> 创建一个 <code>workspace</code> 来管理各个分层的组件包，有兴趣的话可以去翻一翻这篇文章。在大型项目中，这种方式可以让每个组件独立开发和维护，还可以借助 <code>melos</code> 编写各种编译指令，每个组件单独构建运行，组件间的依赖关系清晰明了。</p><p><img src="https://s2.loli.net/2024/06/15/N2Eyis6JPgHcZYQ.png" alt="4891718432664_.pic.png"></p><p><code>melos</code> 有一套独特的工作流程和命令方便单独建运行，同时也有一定的学习成本，尤其是对于小型项目来讲使用 <code>melos</code> 就显得有点复杂了，而且 <code>melos</code> 管理组件还是有一个同样的问题，那就是各组件和主工程使用同一个 <code>git</code> 仓库。如果想要组件使用独立的 <code>git</code> 仓库，该怎么做呢？</p><h3 id="Github-或者-Gitlab"><a href="#Github-或者-Gitlab" class="headerlink" title="Github 或者 Gitlab"></a><code>Github</code> 或者 <code>Gitlab</code></h3><p>将组件上传到<code>Github</code> 或者 <code>Gitlab</code> 上，使用的时候直接在 <code>podspec.yaml</code> 文件中添加依赖，日常开发中也是比较常见的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">library_name:</span></span><br><span class="line">    <span class="attr">git:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">git@github.com:username/library_name.git</span></span><br><span class="line">      <span class="attr">ref:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p>除了上面指定某个分支（如：<code>dev</code>），还可以特指标签（如 <code>v1.0.0</code>），或者具体的提交哈希值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">library_name:</span></span><br><span class="line">   <span class="attr">git:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://github.com/username/library_name.git</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">e234072340</span>    <span class="comment">#commit reference id</span></span><br></pre></td></tr></table></figure><p>可以看出如果使用 <code>Github</code> 或者 <code>Gitlab</code>  来管理 <code>Flutter</code> 组件包，需要手动管理版本标签或提交哈希，这是因为 <code>Dart</code> 的 <code>pub</code> 工具不支持从 <code>git</code> 仓库自动解析版本号，只能指定具体的分支、标签或提交哈希，不能像从 <code>pub.dev</code> 获取包一样指定版本号（如 <code>^1.0.0</code>）。如果使用私有仓库，还需要付费订阅私有仓库的服务。</p><h3 id="第三方平台托管"><a href="#第三方平台托管" class="headerlink" title="第三方平台托管"></a>第三方平台托管</h3><p>用过比较多的就是 <a href="https://docs.onepub.dev/">OnePub</a> ，一个专门用于管理和发布 <code>Dart</code> 和 <code>Flutter</code> 包的第三方平台，旨在提供更灵活的包管理功能，尤其是对于私有包和团队协作来说，不仅可以将 <code>Dart/Flutter</code> 包发布到私有存储库、在项目中添加依赖，还可以与同事共享私有包<br>有界面来搜索公共和私有包，通过电子邮件向团队发送新包版本的通知，与 <code>pub</code> 工具无缝集，将 <code>OnePub</code> 集成到 <code>CI/CD</code> 管道中，自动化包的发布和管理过程等等功能。而且还有2个成员25个 <code>packages</code> 的范围内免费使用，是不是很香，不想去折腾的话使用 <code>OnePub</code> 还是不错的。</p><p>使用第三方平台托管还有有其它的选择，如<code>Cloudsmith</code>、<code>JFrog</code>、<code>JetBrains Space</code> 等，<code>Cloudsmith</code> 除了支持 <code>Dart</code> 和 <code>Flutter</code> 包管理和分发，平台还支持超过 20 种包格式，包括 <code>Docker</code>、<code>npm</code>、<code>Python</code>、<code>Maven</code>、<code>RubyGems</code> 等，适合使用多种语言的中、大型团队。</p><p><img src="https://s2.loli.net/2024/07/25/LU4k3iMZn591dYR.png" alt="5021721891883_.pic.png"></p><h3 id="搭建自定义包服务器"><a href="#搭建自定义包服务器" class="headerlink" title="搭建自定义包服务器"></a>搭建自定义包服务器</h3><p><code>dart pub</code> 是支持自定义的第三方包存储库的，但是自行搭建的话，要处理如安全性（数据加密认证和授权）、存储方案、<code>API</code> 的设计、插件包的版本解析和版本控制、服务器和包管理系统与最新的 <code>Flutter</code> 和 <code>Dart</code> 版本兼容性等等方面的问题，这么一套操作下来太费时费力，如果没有运维的做技术支持的话，很难推行下去，那有没有其它的现成的方案呢？</p><p>这里推荐使用之前字节开源的 <code>unpub</code>，使用 <code>MongoDB</code> 作为默认数据库，模拟了 <code>pub.dev</code> 的功能，也能托管自己的包存储库。以下代码在本地开启一个 <code>server</code>，元信息数据存储在本地的 <code>mongodb</code>，包文件存在本地的 <code>unpub-packages</code> 文件夹中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:mongo_dart/mongo_dart.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:unpub/unpub.dart&#x27;</span> <span class="keyword">as</span> unpub;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> db = Db(<span class="string">&#x27;mongodb://localhost:27017/dart_pub&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> db.open(); <span class="comment">// make sure the MongoDB connection opened</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> app = unpub.App(</span><br><span class="line">    metaStore: unpub.MongoStore(db),</span><br><span class="line">    packageStore: unpub.FileStore(<span class="string">&#x27;./unpub-packages&#x27;</span>),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> server = <span class="keyword">await</span> app.serve(<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">4000</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Serving at http://<span class="subst">$&#123;server.address.host&#125;</span>:<span class="subst">$&#123;server.port&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，作者还提供将服务部署到 <code>AWS</code> 的插件包，只需修改 <code>packageStore</code> 参数即可。使用自定义的包存储库时，在你的 Flutter 项目中编辑 <code>pubspec.yaml</code> 文件，添加你的自定义包服务器作为一个新的包源。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">my_custom_package:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">^0.0.1</span></span><br><span class="line">    <span class="attr">hosted:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">your_custom_server_name</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://your-custom-server-url.com/packages</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上列出来的几种组件包管理方式各有优劣，直接放在主工程中是最简单直接但是独立开发和维护不太方便；<code>melos</code> 管理组件可以独立开发维护却要学习相关的指令；<code>git</code> 能做到独立仓库管理但不支持自动解析版本；搭建自定义包服务器似乎是终极解决方案但需要额外部署和维护一个包服务器；第三方平台托管貌似没有前面面临的问题但托管包的数量有限，超出限制要收费，当然预算充足的话就不是问题。怎么选择就需要根据项目的复杂度和团队的情况，目前本人项目中大都使用的是 <code>melos</code> 来管理组件，那么你使用的是哪种方式呢？或者有没有其它更好的方式来管理项目中的组件？欢迎来分享和交流一下！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着项目功能模块越来越多，怎么去管理这些私有组件包是一个不得不面对的问题，特别对于团队开发来讲，一些通用的公共组件往往会在多个项目间使用，多的有几十个，每个组件包都有有自己的版本，组件包之间还有依赖关系，那么如何在团队内部共享私有组件包，控制依赖私有组件包的版本和组件包的更新维护，而且要确保其安全环境，也就是没有公网无法访问的安全环境，这些都是需要考虑的，如何去管理这些组件对提升开发效率和代码质量就显得尤为重要，那有日常开发中哪些的方式来管理私有组件库呢？本篇文章就来介绍一下。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter 图表查看国家统计局的房价指数</title>
    <link href="http://www.nnxkcloud.com/2024/05/28/Flutter-%E5%9B%BE%E8%A1%A8%E6%9F%A5%E7%9C%8B%E5%9B%BD%E5%AE%B6%E7%BB%9F%E8%AE%A1%E5%B1%80%E7%9A%84%E6%88%BF%E4%BB%B7%E6%8C%87%E6%95%B0/"/>
    <id>http://www.nnxkcloud.com/2024/05/28/Flutter-%E5%9B%BE%E8%A1%A8%E6%9F%A5%E7%9C%8B%E5%9B%BD%E5%AE%B6%E7%BB%9F%E8%AE%A1%E5%B1%80%E7%9A%84%E6%88%BF%E4%BB%B7%E6%8C%87%E6%95%B0/</id>
    <published>2024-05-28T09:21:00.000Z</published>
    <updated>2024-10-15T03:05:34.687Z</updated>
    
    <content type="html"><![CDATA[<p>最近做可视化数据要用到折线图表来展示数据，<code>Flutter</code> 中的图表库有 <code>charts_flutter</code>、<code>fl_chart</code> 等，从易用性上最终决定了使用 <code>fl_chart</code> ，本文以国家统计局房价指数为数据来源，来实现一个 <code>fl_chart</code> 图表的小项目。</p><span id="more"></span><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fl_chart:</span> <span class="string">^0.62.0</span></span><br></pre></td></tr></table></figure><p><code>fl_chart</code> 目前最新版本是 0.68，这里没有使用最新的版本是因为本地电脑的 <code>dart</code> 版本是 2.19.1，而最新版本 0.68 要求 <code>dart</code> 的最低版本是 3.2，考虑到需要兼容之前的项目，暂未升到最新版本。</p><h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>本文用到的数据是来自国家统计局公布的房价指数，这些数据在国家统计局官网上也能查看到，但可视化查看起来不是很方便，本文使用到的数据也只是其中一部分（如下图中的数据），目的是用来学习和研究，并没有用于其它任何商业用途。</p><p><img src="https://s2.loli.net/2024/05/28/hkDfH462AuNi359.png" alt="4731716878015_.pic.png"></p><h2 id="LineChart"><a href="#LineChart" class="headerlink" title="LineChart"></a><code>LineChart</code></h2><p>创建类 <code>LineChartWidget</code> ，在这里添加 <code>LineChart</code> 类。<code>LineChartWidget</code> 有三个属性，<code>listItems</code> 是要展示的数据，<code>selectedCity</code> 表示当前选中的城市，<code>dates</code> 是需要展示数据的月份数组，<code>selectIndexType</code> 当前展示的数据的类型，数据的类型有：同比指数、环比指数和定基指数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineChartWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;ListItem&gt; listItems;</span><br><span class="line">  <span class="keyword">final</span> CityModel? selectedCity;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; dates;</span><br><span class="line">  <span class="keyword">final</span> IndexType selectIndexType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> LineChartWidget(</span><br><span class="line">      &#123;Key? key,</span><br><span class="line">      <span class="keyword">required</span> <span class="keyword">this</span>.listItems,</span><br><span class="line">      <span class="keyword">required</span> <span class="keyword">this</span>.selectedCity,</span><br><span class="line">      <span class="keyword">required</span> <span class="keyword">this</span>.dates,</span><br><span class="line">      <span class="keyword">required</span> <span class="keyword">this</span>.selectIndexType&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> LineChart(</span><br><span class="line">      mainData(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LineChart</code>  需要一个 <code>LineChartData</code> 参数，重点也就是这个 <code>LineChartData</code>，大部分关于线形图的参数设置在这个类里，第一次使用 <code>fl_chart</code> 看到这些参数也有点看不懂，下面介绍一下常用的几个参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">LineChartData(</span><br><span class="line">    <span class="comment">// X 轴最大值</span></span><br><span class="line">    maxX: dates.length - <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// X 轴最小值</span></span><br><span class="line">    minX: <span class="number">0</span>,</span><br><span class="line"><span class="comment">// Y 轴的基线</span></span><br><span class="line">    baselineY: <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">// X 轴最小值</span></span><br><span class="line">    minY: numMin,</span><br><span class="line">    <span class="comment">// Y 轴最大值</span></span><br><span class="line">    maxY: numMax.ceilToDouble(),</span><br><span class="line">    <span class="comment">// 数据点的数值提示，showIndexes 是需要显示提示的索引数组</span></span><br><span class="line">    showingTooltipIndicators: showIndexes.map((index) &#123;</span><br><span class="line">      <span class="comment">// ShowingTooltipIndicators 配置每个索引的数据点。</span></span><br><span class="line">      <span class="keyword">return</span> ShowingTooltipIndicators([</span><br><span class="line">        LineBarSpot(lineBarsData[<span class="number">0</span>], lineBarsData.indexOf(lineBarsData[<span class="number">0</span>]),</span><br><span class="line">            lineBarsData[<span class="number">0</span>].spots[index]),</span><br><span class="line">      ]);</span><br><span class="line">    &#125;).toList(),</span><br><span class="line">    <span class="comment">// 纵用于设置网格线的样式。gridData 包含网格线的配置，如颜色、宽度、是否显示等</span></span><br><span class="line">    gridData: gridData,</span><br><span class="line">    <span class="comment">// 用于设置图表的标题和标签，包括 X 轴和 Y 轴的标签样式和格式。</span></span><br><span class="line">    titlesData: titlesData,</span><br><span class="line">    <span class="comment">// 用于配置触摸行为，点击数据点时的显示效果。lineTouchData 包含点击时的交互配置</span></span><br><span class="line">    lineTouchData: lineTouchData,</span><br><span class="line">    <span class="comment">// 用于设置图表的边框样式。show 表示是否显示边框，border 设置边框的颜色和宽度。</span></span><br><span class="line">    borderData: FlBorderData(</span><br><span class="line">      <span class="keyword">show</span>: <span class="keyword">true</span>,</span><br><span class="line">      border: <span class="keyword">const</span> Border(</span><br><span class="line">          left: BorderSide(color: Color(<span class="number">0xff313131</span>)),</span><br><span class="line">          bottom: BorderSide(color: Color(<span class="number">0xff313131</span>))),</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">// 用于配置额外的辅助线。这里配置了一条水平辅助线，颜色、宽度和虚线样式都可以自定义。</span></span><br><span class="line">    extraLinesData: ExtraLinesData(horizontalLines: [</span><br><span class="line">      HorizontalLine(</span><br><span class="line">        y: <span class="number">0.0</span>,</span><br><span class="line">        color: <span class="keyword">const</span> Color(<span class="number">0xff010101</span>),</span><br><span class="line">        strokeWidth: <span class="number">1.6</span>,</span><br><span class="line">        dashArray: [<span class="number">10</span>, <span class="number">2</span>],</span><br><span class="line">      ),</span><br><span class="line">    ]),</span><br><span class="line">    <span class="comment">// 图表的主要内容，包括折线数据。lineBarsData 包含一组 LineChartBarData 对象，每个对象代表一条折线及其数据点。</span></span><br><span class="line">    lineBarsData: lineBarsData,</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>对于在图上的各个配置</p><p><img src="https://s2.loli.net/2024/05/28/KlgAq9CyboJxdPX.png" alt="4751716880535_.pic.png"></p><p>其中 <code>lineBarsData</code> 就是曲线图的内容了，要求返回一个数组，意思是可以同时显示多条曲线，我们这里只需要一条，点击勾选☑️来切换显示同比指数、环比指数或者定基指数。下面生成一个<code>LineChartBarData</code> 类并添加到数组中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">LineChartBarData generateLineChartBarData(</span><br><span class="line">        &#123;<span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; yValues = <span class="keyword">const</span> [],</span><br><span class="line">        Color color = <span class="keyword">const</span> Color(<span class="number">0xFF7351F6</span>),</span><br><span class="line">        Color dotColor = <span class="keyword">const</span> Color(<span class="number">0xFF002AFF</span>)&#125;) =&gt;</span><br><span class="line">    LineChartBarData(</span><br><span class="line">      <span class="comment">// true 表示曲线，false 表示折线</span></span><br><span class="line">      isCurved: <span class="keyword">true</span>,</span><br><span class="line">      <span class="comment">// 显示提示指示器的索引列表。这里通过 yValues转成map的keys数组的索引创建一个列表</span></span><br><span class="line">      showingIndicators: yValues.asMap().keys.toList(),</span><br><span class="line">      <span class="comment">// 折线图上的数据点，由 FlSpot 类表示。每个 FlSpot 对象包含一个 x 和 y 值</span></span><br><span class="line">      spots: yValues.asMap().entries.map((e) &#123;</span><br><span class="line">        <span class="keyword">return</span> FlSpot(e.key.toDouble(), e.value);</span><br><span class="line">      &#125;).toList(),</span><br><span class="line">      <span class="comment">// 是否将折线连接处设置为圆角</span></span><br><span class="line">      isStrokeJoinRound: <span class="keyword">true</span>,</span><br><span class="line">      <span class="comment">// 折线的颜色</span></span><br><span class="line">      color: color,</span><br><span class="line">      <span class="comment">// 折线的宽度</span></span><br><span class="line">      barWidth: <span class="number">1.4</span>,</span><br><span class="line">      <span class="comment">// 是否将折线的末端设置为圆角</span></span><br><span class="line">      isStrokeCapRound: <span class="keyword">false</span>,</span><br><span class="line">      <span class="comment">// 配置折线上的数据点</span></span><br><span class="line">      dotData: FlDotData(</span><br><span class="line">          <span class="keyword">show</span>: <span class="keyword">true</span>,</span><br><span class="line">          getDotPainter: (spot, percent, barData, index) &#123;</span><br><span class="line">            <span class="keyword">return</span> FlDotCirclePainter(</span><br><span class="line">              radius: <span class="number">2</span>,</span><br><span class="line">              color: dotColor,</span><br><span class="line">              strokeWidth: <span class="number">1.2</span>,</span><br><span class="line">              strokeColor: dotColor,</span><br><span class="line">            );</span><br><span class="line">          &#125;),</span><br><span class="line">      <span class="comment">// 配置曲线下方区域的显示。</span></span><br><span class="line">      belowBarData: BarAreaData(</span><br><span class="line">        <span class="keyword">show</span>: <span class="keyword">true</span>,</span><br><span class="line">        gradient: LinearGradient(</span><br><span class="line">          begin: Alignment.topCenter,</span><br><span class="line">          end: Alignment.bottomCenter,</span><br><span class="line">          colors: [color.withAlpha(<span class="number">160</span>), color.withAlpha(<span class="number">20</span>)],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>配置 <code>titlesData</code>，只显示左边和底部的 <code>title</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">FlTitlesData <span class="keyword">get</span> titlesData =&gt; FlTitlesData(</span><br><span class="line">      <span class="keyword">show</span>: <span class="keyword">true</span>,</span><br><span class="line">      rightTitles: AxisTitles(</span><br><span class="line">        sideTitles: SideTitles(showTitles: <span class="keyword">false</span>),</span><br><span class="line">      ),</span><br><span class="line">      topTitles: AxisTitles(</span><br><span class="line">        sideTitles: SideTitles(showTitles: <span class="keyword">false</span>),</span><br><span class="line">      ),</span><br><span class="line">      bottomTitles: AxisTitles(</span><br><span class="line">        sideTitles: SideTitles(</span><br><span class="line">          reservedSize: <span class="number">50</span>,</span><br><span class="line">          showTitles: <span class="keyword">true</span>,</span><br><span class="line">          interval: <span class="number">1</span>,</span><br><span class="line">          getTitlesWidget: bottomTitleWidgets,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      leftTitles: AxisTitles(</span><br><span class="line">        sideTitles: SideTitles(</span><br><span class="line">          showTitles: <span class="keyword">true</span>,</span><br><span class="line">          getTitlesWidget: leftTitleWidgets,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">Widget bottomTitleWidgets(<span class="built_in">double</span> value, TitleMeta meta) &#123;</span><br><span class="line">  <span class="keyword">const</span> style = TextStyle(</span><br><span class="line">      fontWeight: FontWeight.w300, fontSize: <span class="number">11</span>, color: Color(<span class="number">0xFF666666</span>));</span><br><span class="line">  <span class="built_in">String</span> date = dates[value.toInt()];</span><br><span class="line">  <span class="keyword">return</span> SideTitleWidget(</span><br><span class="line">    axisSide: meta.axisSide,</span><br><span class="line">    angle: <span class="number">30</span>, <span class="comment">// 旋转角度</span></span><br><span class="line">    space: <span class="number">14</span>,</span><br><span class="line">    child: Text(date, style: style),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget leftTitleWidgets(<span class="built_in">double</span> value, TitleMeta meta) &#123;</span><br><span class="line">  <span class="keyword">const</span> style = TextStyle(</span><br><span class="line">      fontWeight: FontWeight.w300, fontSize: <span class="number">11</span>, color: Color(<span class="number">0xFF666666</span>));</span><br><span class="line">  <span class="built_in">String</span> text = NumberUtil.getNumByValueDouble(value, <span class="number">1</span>).toString();</span><br><span class="line">  <span class="keyword">return</span> Text(text, style: style, textAlign: TextAlign.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置网格线样式 <code>gridData</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FlGridData <span class="keyword">get</span> gridData =&gt; FlGridData(</span><br><span class="line">      <span class="keyword">show</span>: <span class="keyword">true</span>,</span><br><span class="line">      drawVerticalLine: <span class="keyword">true</span>,</span><br><span class="line">      drawHorizontalLine: <span class="keyword">true</span>,</span><br><span class="line">      horizontalInterval: <span class="number">1</span>,</span><br><span class="line">      verticalInterval: <span class="number">1</span>,</span><br><span class="line">      getDrawingHorizontalLine: (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> FlLine(</span><br><span class="line">          color: <span class="keyword">const</span> Color(<span class="number">0xffaeaeae</span>),</span><br><span class="line">          strokeWidth: <span class="number">0.5</span>,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">      getDrawingVerticalLine: (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> FlLine(</span><br><span class="line">          color: <span class="keyword">const</span> Color(<span class="number">0xffaeaeae</span>),</span><br><span class="line">          strokeWidth: <span class="number">0.5</span>,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>设置 <code>lineTouchData</code> 触摸行为，也就是点击数据点时的显示效果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">LineTouchData <span class="keyword">get</span> lineTouchData =&gt; LineTouchData(</span><br><span class="line">      <span class="comment">// 参数用于启用或禁用触摸事件</span></span><br><span class="line">      enabled: <span class="keyword">false</span>,</span><br><span class="line">      <span class="comment">// 这是一个回调函数，用于定义当数据点被触摸时的指示器样式。它返回 TouchedSpotIndicatorData 的列表，包含每个触摸点的指示器样式。</span></span><br><span class="line">      getTouchedSpotIndicator:</span><br><span class="line">          (LineChartBarData barData, <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; spotIndexes) &#123;</span><br><span class="line">        <span class="keyword">return</span> spotIndexes.map((index) &#123;</span><br><span class="line">          <span class="comment">// 每个触摸点的指示器样式</span></span><br><span class="line">          <span class="keyword">return</span> TouchedSpotIndicatorData(</span><br><span class="line">            FlLine(</span><br><span class="line">              <span class="comment">// 为透明色，因此不会显示指示线</span></span><br><span class="line">              color: Colors.transparent,</span><br><span class="line">            ),</span><br><span class="line">            FlDotData(</span><br><span class="line">              <span class="comment">// 为 false，表示不显示默认的点</span></span><br><span class="line">              <span class="keyword">show</span>: <span class="keyword">false</span>,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;).toList();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 参数用于配置触摸工具提示的显示样式。</span></span><br><span class="line">      touchTooltipData: LineTouchTooltipData(</span><br><span class="line">        <span class="comment">// 设置为透明色，使工具提示背景透明。</span></span><br><span class="line">        tooltipBgColor: Colors.transparent,</span><br><span class="line">        tooltipRoundedRadius: <span class="number">9</span>,</span><br><span class="line">        tooltipPadding: <span class="keyword">const</span> EdgeInsets.only(bottom: <span class="number">-10</span>),</span><br><span class="line">        <span class="comment">// 回调函数返回一个 LineTooltipItem 的列表，用于自定义工具提示的内容和样式。此处显示了触摸点的 Y 轴值，并设置了文本样式。</span></span><br><span class="line">        getTooltipItems: (<span class="built_in">List</span>&lt;LineBarSpot&gt; lineBarsSpot) &#123;</span><br><span class="line">          <span class="keyword">return</span> lineBarsSpot.map((lineBarSpot) &#123;</span><br><span class="line">            <span class="keyword">return</span> LineTooltipItem(</span><br><span class="line">              lineBarSpot.y.toString(),</span><br><span class="line">              <span class="keyword">const</span> TextStyle(</span><br><span class="line">                  color: Color(<span class="number">0xFF212121</span>),</span><br><span class="line">                  fontSize: <span class="number">14</span>,</span><br><span class="line">                  fontWeight: FontWeight.normal),</span><br><span class="line">            );</span><br><span class="line">          &#125;).toList();</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>来看看最终的实现效果</p><p><img src="https://s2.loli.net/2024/05/28/iKOvWgtofHajT9U.jpg" alt="4741716880071_.pic _1_.jpg"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面 <code>LineChart</code> 为例介绍了它使用方法和参数，<code>fl_chart</code> 还有 <code>BarChart</code>、<code>PieChart</code> 等其它可视化图表，使用方法和参数上大同小异吧，用的时候如果还有不知道的可以去看看官方文档。<code>fl_chart</code> 在众多 <code>Flutter</code> 图表框架中使用人数还是比较多的，功能丰富，也能满足不少自定义的需求，但相对于原生 <code>iOS</code>、<code>Android</code> 平台的图表框架，<code>fl_chart</code> 还是有一些不足和局限，如它不支持 <code>x</code>、<code>y</code> 轴的滚动、<code>Tooltip</code> 仅支持基本的文本样式定制，不支持更复杂的布局和内容、对于非常复杂的图表，如多个折线、多层次的图表组合，<code>fl_chart</code> 的性能可能不足以满足需求，渲染时间会明显增加等等，当然这些功能的完善都需要一个过程。</p><p>以上的开源代码在这里：<a href="https://github.com/joedrm/flutter_todo">源码</a> 供大家参考，本文虽然没有特别复杂的原理和逻辑，但是从调试数据、翻看整理文档、代码实现和细节调整，这样的一个小项目也是花了不少时间和精力，希望能够帮到你，感谢阅读，记得加关注和点赞哦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近做可视化数据要用到折线图表来展示数据，&lt;code&gt;Flutter&lt;/code&gt; 中的图表库有 &lt;code&gt;charts_flutter&lt;/code&gt;、&lt;code&gt;fl_chart&lt;/code&gt; 等，从易用性上最终决定了使用 &lt;code&gt;fl_chart&lt;/code&gt; ，本文以国家统计局房价指数为数据来源，来实现一个 &lt;code&gt;fl_chart&lt;/code&gt; 图表的小项目。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>解锁 Flutter 的神秘关键字，快来一探究竟！</title>
    <link href="http://www.nnxkcloud.com/2024/05/26/%E8%A7%A3%E9%94%81-Flutter-%E7%9A%84%E7%A5%9E%E7%A7%98%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%BF%AB%E6%9D%A5%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F%EF%BC%81/"/>
    <id>http://www.nnxkcloud.com/2024/05/26/%E8%A7%A3%E9%94%81-Flutter-%E7%9A%84%E7%A5%9E%E7%A7%98%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%BF%AB%E6%9D%A5%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F%EF%BC%81/</id>
    <published>2024-05-26T08:45:32.000Z</published>
    <updated>2024-10-15T03:05:34.692Z</updated>
    
    <content type="html"><![CDATA[<p>将 <code>Flutter</code> 中常用到或者见到的关键字做一个收集和介绍。</p><h2 id="1-show-、hide-和-as"><a href="#1-show-、hide-和-as" class="headerlink" title="1.show 、hide 和 as"></a>1.<code>show</code> 、<code>hide</code> 和 <code>as</code></h2><p>当 <code>import</code> 文件的时候，使用 <code>show</code> 关键字可以仅导入库中的某个特定部分，而不是整个库。在你只需要库中的一部分内容的时候非常有用，避免不必要的命名冲突，也能明确哪些部分被使用。而 <code>hide</code> 关键字可以导入库的大部分内容，但排除特定的部分。这在你需要库的几乎所有内容，但想要避免特定部分的命名冲突时非常有用。<code>as</code> 则为导入的库起个别名，避免类名冲突。</p><span id="more"></span><p>如：<code>provider</code> 和 <code>flutter_riverpod</code> 都提供类似的功能用于状态管理，并且有一些类名是相同的，其中 <code>Provider</code> 类本身，在两个插件库中都有。还有 <code>flutter_intl</code> 和 <code>intl</code> 也有相似类名 <code>DateFormat</code>。</p><p><img src="https://s2.loli.net/2024/05/26/iAZQ1fyWCoDndJU.png" alt="4701716695159_.pic.png"></p><p>以 <code>Provider</code> 类为例，使用 <code>show</code>  和 <code>hide</code> 关键字来解决命名冲突。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:provider/provider.dart&#x27;</span> <span class="keyword">show</span> ChangeNotifierProvider, Consumer;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span> <span class="keyword">hide</span> ChangeNotifierProvider, Consumer;</span><br></pre></td></tr></table></figure><p>也可以给冲突的类名起个别名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:provider/provider.dart&#x27;</span> <span class="keyword">as</span> provider;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span> <span class="keyword">as</span> riverpod;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ProviderWidgetState</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ProviderWidget</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> provider.ChangeNotifierProvider&lt;T&gt;(</span><br><span class="line">      create: (_) =&gt; widget.model,</span><br><span class="line">      child: provider.Consumer&lt;T&gt;(</span><br><span class="line">        builder: widget.builder,</span><br><span class="line">        child: widget.child,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-part-和-part-of"><a href="#2-part-和-part-of" class="headerlink" title="2.part 和 part of"></a>2.<code>part</code> 和 <code>part of</code></h2><p><code>part</code> 和 <code>part of</code> 是 <code>Dart</code> 语言中用于管理分割文件的关键字。如我们常使用 <code>@freezed</code> 注解生成 <code>xxx.freezed.dart</code> 文件，下面以 <code>HomeEvent</code> 类来举例：</p><p><code>home_event.dart</code> ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示 home_event.freezed.dart 是 home_event.dart 文件的一部分， </span></span><br><span class="line"><span class="comment">// 通常用于将大的类或功能拆分成多个文件</span></span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;home_event.freezed.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeEvent</span> <span class="keyword">extends</span> <span class="title">BaseBlocEvent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HomeEvent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@freezed</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePageInitiated</span> <span class="keyword">extends</span> <span class="title">HomeEvent</span> <span class="title">with</span> <span class="title">_</span>$<span class="title">HomePageInitiated</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">factory</span> HomePageInitiated() = _HomePageInitiated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>freezed</code> 生成<code> home_event.freezed.dart</code>：<br><img src="https://s2.loli.net/2024/05/26/k4vlsLnuxyNfptD.png" alt="4711716706149_.pic.png"></p><p>上图中的 <code>part of &#39;home_event.dart&#39;;</code> 也是表示 <code>home_event.freezed.dart</code> 是 <code>home_event.dart</code> 文件的一部分。<code>part of</code> 关键字后面跟着所属文件，其作用就是将多个文件组合在一起，使它们共同构成一个完整的 <code>Dart</code> 文件。</p><h2 id="3-deferred"><a href="#3-deferred" class="headerlink" title="3.deferred"></a>3.<code>deferred</code></h2><p>做延迟加载的，将库的加载推迟到第一次访问该库时才进行，而不是在应用程序启动时就加载。对于减少应用启动时间和减小应用包大小非常有用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/foundation.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> mylib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&#x27;Deferred Loading Example&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: ElevatedButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              loadLibrary(context);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&#x27;Load Library&#x27;</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; loadLibrary(BuildContext context) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> mylib.loadLibrary(); <span class="comment">// 加载延迟加载库</span></span><br><span class="line">    Navigator.push(</span><br><span class="line">      context,</span><br><span class="line">      MaterialPageRoute(builder: (context) =&gt; DeferredPage()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeferredPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;Deferred Page&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: FutureBuilder(</span><br><span class="line">          future: mylib.myFunction(), <span class="comment">// 使用延迟加载库中的函数</span></span><br><span class="line">          builder: (context, snapshot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.waiting) &#123;</span><br><span class="line">              <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> Text(snapshot.data.toString());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>mylib</code> 是一个延迟加载的库。 <code>deferred as mylib</code> 关键字将延迟加载库导入为 <code>mylib</code>。在 <code>main</code> 函数中，我们通过 <code>mylib.loadLibrary() </code> 方法加载延迟加载库。加载完成后，我们可以像使用普通库一样使用 <code>mylib</code> 中的类、函数。</p><p>当然延迟加载库的实现需要去配置 <code>Android</code> 原生的 <code>build.gradle</code> 文件和 <code>Flutter</code> 的<code>pubspec.yaml</code> 文件等操作，还对 <code>Dart</code> 版本有要求，具体细节大家感兴趣的话可以尝试实现一下。</p><p>这几个是和类、文件导入相关相关的，下面介绍几个和 <code>dart</code> 语法相关的关键字。</p><h2 id="4-typedef"><a href="#4-typedef" class="headerlink" title="4.typedef"></a>4.<code>typedef</code></h2><p>使用 <code>typedef</code> 关键字为现有类型创建别名（类型别名 <code>Type Alias</code>），其常用于函数类型，可以简化其定义和使用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare&lt;T&gt; = <span class="built_in">int</span> <span class="built_in">Function</span>(T a, T b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> compareInt(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  Compare&lt;<span class="built_in">int</span>&gt; comp = compareInt;</span><br><span class="line">  <span class="built_in">print</span>(comp(<span class="number">3</span>, <span class="number">2</span>));  <span class="comment">// 输出 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还常用于给类型起一个一眼就能看得懂的名字，提高代码可读性。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> UserInfo = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> printUserInfo(UserInfo user) &#123;</span><br><span class="line">  <span class="comment">//这里使用 UserInfo 比直接是 Map 更好理解吧</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Name: <span class="subst">$&#123;user[<span class="string">&#x27;name&#x27;</span>]&#125;</span>, Email: <span class="subst">$&#123;user[<span class="string">&#x27;email&#x27;</span>]&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  UserInfo user = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;john.doe@example.com&#x27;</span>&#125;;</span><br><span class="line">  printUserInfo(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-yield"><a href="#5-yield" class="headerlink" title="5.yield"></a>5.<code>yield</code></h2><p><code>yield</code> 关键字用于在 <code>Dart</code> 中创建生成器函数。生成器函数是一种特殊的函数，它可以在需要时逐步生成一系列值，而不是一次性生成并返回所有值，通常在迭代器中（<code>for...in</code>）使用。下面以生成斐波那契数列算法为例来看看 <code>yield</code> 关键字的用法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; fibonacciSequence(<span class="built_in">int</span> count) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a; <span class="comment">// 生成斐波那契数列中的当前值</span></span><br><span class="line">    <span class="built_in">int</span> temp = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 生成前 10 个值</span></span><br><span class="line">  <span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; fibonacciNumbers = fibonacciSequence(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> number <span class="keyword">in</span> fibonacciNumbers) &#123;</span><br><span class="line">    <span class="built_in">print</span>(number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///<span class="language-markdown">输出结果：0 1 1 2 3 5 8 13 21 34</span></span></span><br></pre></td></tr></table></figure><p>函数 <code>fibonacciSequence</code> 就是一个生成指定数量的斐波那契数列的生成器函数。在每次迭代中使用<code>yield a</code> 生成斐波那契数列中的当前值，并把这个当前值 <code>a</code>  返回给调用者，然后这个生成过程先暂停下来，等待下次调用（下一次 <code>for</code> 循环），再去执行生成斐波那契数列中的当前值，就是这么个意思。</p><h2 id="6-mixin"><a href="#6-mixin" class="headerlink" title="6.mixin"></a>6.<code>mixin</code></h2><p><code>mixin</code> 我们平时见得很多，就是 <code>Dart</code> 用于解决多继承的问题，使用 <code>mixin</code> 可以将一组通用的方法和属性封装在一个独立的类中，然后在需要的类中混入这个 <code>mixin</code> ，从而使得这些类都具有相同的行为。本质上就是通过组合类的方式来重用代码的机制。</p><p><code>mixin</code>  的特点：一个类可以混入多个 <code>mixin</code> ，不能被实例化，只包含方法和属性的定义，没有状态或构造函数。</p><p>如我们比较常用的 <code>LogMixin</code> 类，通常将 <code>LogMixin</code> 混入到项目 <code>bloc</code> 的基类 <code>BaseBloc</code>，方便在业务逻辑中打印和调试。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> LogMixin <span class="keyword">on</span> <span class="built_in">Object</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> logD(<span class="built_in">String</span> message, &#123;<span class="built_in">DateTime?</span> time&#125;) &#123;</span><br><span class="line">    Log.d(message, name: runtimeType.toString(), time: time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBloc</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">BaseBlocEvent</span>, <span class="title">S</span> <span class="keyword">extends</span> <span class="title">BaseBlocState</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">E</span>, <span class="title">S</span>&gt; <span class="title">with</span> <span class="title">LogMixin</span> </span>&#123;</span><br><span class="line">  BaseBloc(S initialState) : <span class="keyword">super</span>(initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span>&lt;<span class="title">HomeEvent</span>, <span class="title">HomeState</span>&gt; </span>&#123;</span><br><span class="line">  HomeBloc(<span class="keyword">this</span>._repository) : <span class="keyword">super</span>(HomeState()) &#123;</span><br><span class="line">    <span class="keyword">on</span>&lt;HomePageInitiated&gt;(</span><br><span class="line">      _onHomePageInitiated</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Repository _repository;</span><br><span class="line"></span><br><span class="line">  FutureOr&lt;<span class="keyword">void</span>&gt; _onHomePageInitiated(</span><br><span class="line">      HomePageInitiated event, Emitter&lt;HomeState&gt; emit) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 直接使用 LogMixin 的 logD 函数</span></span><br><span class="line">    logD(<span class="string">&quot;HomePageInitiated: <span class="subst">$event</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上关键字介绍都是基于个人理解，总结的或许不够全面和准确，那么在日常开发中有遇到哪些你理解起来比较费劲的关键字呢？欢迎留言交流，感谢您的阅读！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将 &lt;code&gt;Flutter&lt;/code&gt; 中常用到或者见到的关键字做一个收集和介绍。&lt;/p&gt;
&lt;h2 id=&quot;1-show-、hide-和-as&quot;&gt;&lt;a href=&quot;#1-show-、hide-和-as&quot; class=&quot;headerlink&quot; title=&quot;1.show 、hide 和 as&quot;&gt;&lt;/a&gt;1.&lt;code&gt;show&lt;/code&gt; 、&lt;code&gt;hide&lt;/code&gt; 和 &lt;code&gt;as&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;当 &lt;code&gt;import&lt;/code&gt; 文件的时候，使用 &lt;code&gt;show&lt;/code&gt; 关键字可以仅导入库中的某个特定部分，而不是整个库。在你只需要库中的一部分内容的时候非常有用，避免不必要的命名冲突，也能明确哪些部分被使用。而 &lt;code&gt;hide&lt;/code&gt; 关键字可以导入库的大部分内容，但排除特定的部分。这在你需要库的几乎所有内容，但想要避免特定部分的命名冲突时非常有用。&lt;code&gt;as&lt;/code&gt; 则为导入的库起个别名，避免类名冲突。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter中如何优雅地使用弹框</title>
    <link href="http://www.nnxkcloud.com/2024/05/24/Flutter%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%BC%B9%E6%A1%86/"/>
    <id>http://www.nnxkcloud.com/2024/05/24/Flutter%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%BC%B9%E6%A1%86/</id>
    <published>2024-05-24T10:31:22.000Z</published>
    <updated>2024-10-15T03:05:34.688Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/05/24/SL5gnJfYyhr4NvM.png" alt=" _2_.png"></p><p>日常开发中，<code>Flutter</code> 弹框（<code>Dialog</code>）是我们使用频率非常高的控件。无论是提示用户信息、确认用户操作，还是表单填写，弹框都能派上用场。然而，看似简单的弹框，实际使用起来却有不少坑和使用的技巧。今天，我们就来聊聊这些弹框的使用技巧，文末还有关于在 <code>bloc</code> 如何使用弹框的内容，保证你看完之后干货满满，下面直接开始吧。</p><span id="more"></span><h2 id="返回值的处理"><a href="#返回值的处理" class="headerlink" title="返回值的处理"></a>返回值的处理</h2><p>用户在点击退出登录时，通常的做法就是弹框用来确认是否退出登录，返回值是 <code>bool</code> 类型，为 <code>true</code> 表示退出登录，反之不需要退出，这个时候应该怎处理这个 <code>bool</code> 类型的返回值呢？我们先来看看最常见的写法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">_showDialogWithCallBack(<span class="built_in">Function</span>(<span class="built_in">bool</span>) callBack)&#123;</span><br><span class="line">  showDialog(</span><br><span class="line">    context: context,</span><br><span class="line">    builder: (context) &#123;</span><br><span class="line">      <span class="keyword">return</span> AlertDialog(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">&quot;Logout&quot;</span>),</span><br><span class="line">        content: <span class="keyword">const</span> Text(<span class="string">&quot;Are you sure you want to logout?&quot;</span>),</span><br><span class="line">        actions: [</span><br><span class="line">          TextButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              callBack(<span class="keyword">false</span>);</span><br><span class="line">              Navigator.of(context).pop();</span><br><span class="line">            &#125;,</span><br><span class="line">            child: <span class="keyword">const</span> Text(<span class="string">&quot;Cancel&quot;</span>),</span><br><span class="line">          ),</span><br><span class="line">          TextButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              callBack(<span class="keyword">true</span>);</span><br><span class="line">              Navigator.of(context).pop();</span><br><span class="line">            &#125;,</span><br><span class="line">            child: <span class="keyword">const</span> Text(<span class="string">&quot;Sure&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击按钮后调用 <code>_showDialogWithCallBack</code> 函数来显示弹框。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TextButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    _showDialogWithCallBack((result) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">$result</span>&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">&#x27;Dialog with callBack&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除了上面这种使用回调函数传递结果，还有没有其它更加优雅的写法呢？我们知道 <code>showDialog</code> 本身返回的就是 <code>Future</code> 对象，如果需要在 <code>Dialog</code> 关闭后继续执行一些其它逻辑，我们可以使用 <code>await</code> 和 <code>async</code> 关键字来接收返回数据处理异步操作，下面来看看该怎么实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">bool?</span>&gt; _showAsyncDialog() &#123;</span><br><span class="line">  <span class="keyword">return</span> showDialog&lt;<span class="built_in">bool</span>&gt;(</span><br><span class="line">    context: context,</span><br><span class="line">    builder: (context) &#123;</span><br><span class="line">      <span class="keyword">return</span> AlertDialog(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">&quot;Logout&quot;</span>),</span><br><span class="line">        content: <span class="keyword">const</span> Text(<span class="string">&quot;Are you sure you want to logout?&quot;</span>),</span><br><span class="line">        actions: [</span><br><span class="line">          TextButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              Navigator.of(context).pop(<span class="keyword">false</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: <span class="keyword">const</span> Text(<span class="string">&quot;Cancel&quot;</span>),</span><br><span class="line">          ),</span><br><span class="line">          TextButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              Navigator.of(context).pop(<span class="keyword">true</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: <span class="keyword">const</span> Text(<span class="string">&quot;Sure&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code> Navigator.of(context).pop(true)</code> 方法来关闭对话框，并传递 <code>true</code> 或者 <code>false</code> 值作为对话框的返回结果，当点击按钮调用 <code>_showAsyncDialog</code> 弹出 <code>Dialog</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextButton(</span><br><span class="line">  onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">bool?</span> result = <span class="keyword">await</span> _showAsyncDialog();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">$result</span>&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">&#x27;Async Dialog&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在返回 <code>result</code> 之后再去处理其它的逻辑，相对于使用回调函数来处理结果，这种写法是不是更加的简洁，避免了回调函数那种代码嵌套，代码看起来也更清晰易懂吧。</p><p>如果 <code>Dialog</code> 中带有表单（如：<code>TextField</code>）该如何处理返回数据呢？其实和上面的处理方式是一样的，也可使用 <code>async</code> 和 <code>await</code> 来处理 <code>showDialog</code> 返回的 <code>Future</code> 对象，以返回用户输入的年龄（<code>int</code> 类型）为例，其实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int?</span>&gt; _getAge(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">final</span> controller = TextEditingController();</span><br><span class="line">  <span class="keyword">return</span> showDialog(</span><br><span class="line">      context: context,</span><br><span class="line">      builder: (context) &#123;</span><br><span class="line">        <span class="keyword">return</span> AlertDialog(</span><br><span class="line">          title: <span class="keyword">const</span> Text(<span class="string">&quot;How old are you?&quot;</span>),</span><br><span class="line">          content: TextField(</span><br><span class="line">              decoration: <span class="keyword">const</span> InputDecoration(hintText: <span class="string">&quot;e.g：22&quot;</span>),</span><br><span class="line">              keyboardType: TextInputType.number,</span><br><span class="line">              autofocus: <span class="keyword">true</span>,</span><br><span class="line">              maxLength: <span class="number">3</span>,</span><br><span class="line">              controller: controller,</span><br><span class="line">              inputFormatters: [</span><br><span class="line">                TextInputFormatter.withFunction((oldValue, newValue) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (newValue.text.isEmpty) <span class="keyword">return</span> newValue;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> age = <span class="built_in">int</span>.parse(newValue.text);</span><br><span class="line">                    <span class="keyword">if</span> (age &gt; <span class="number">120</span>) <span class="keyword">return</span> oldValue;</span><br><span class="line">                    <span class="keyword">return</span> newValue;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    <span class="keyword">return</span> oldValue;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">              ]),</span><br><span class="line">          actions: [</span><br><span class="line">            TextButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  Navigator.pop(context);</span><br><span class="line">                &#125;,</span><br><span class="line">                child: <span class="keyword">const</span> Text(<span class="string">&quot;Cancel&quot;</span>)),</span><br><span class="line">            TextButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="keyword">final</span> age = <span class="built_in">int</span>.parse(controller.text);</span><br><span class="line">                  Navigator.of(context).pop(age);</span><br><span class="line">                &#125;,</span><br><span class="line">                child: <span class="keyword">const</span> Text(<span class="string">&quot;Save&quot;</span>))</span><br><span class="line">          ],</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似上面这种写法也同样适用于各种类型的 <code>ActionSheet</code>  返回值的处理。</p><h2 id="自定义-Dialog-内容"><a href="#自定义-Dialog-内容" class="headerlink" title="自定义 Dialog 内容"></a>自定义 <code>Dialog</code> 内容</h2><p>上面的例子中 <code>showDialog</code> 的 <code>builder</code> 函数返回内容都使用的是 <code>AlertDialog</code> 类，它属于 <code>Material</code> 设计风格的，而在我们平时开发的时候往往需要根据设计稿定制自己的 <code>Dialog</code> ，这个时候就需要自定义 <code>Dialog</code> 的内容了，如直接在 <code>builder</code> 函数中返回自定义的 <code>widget</code> 类，但是这个时候需要自己处理圆角、边框和阴影，还有处理点击对话框外部自动关闭对话框等功能。如果想要快速的实现一个自定义内容的弹框可以使用 <code>Dialog</code> 组件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Dialog(&#123;</span><br><span class="line">    <span class="keyword">super</span>.key,</span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="keyword">this</span>.elevation,</span><br><span class="line">    <span class="keyword">this</span>.shadowColor,</span><br><span class="line">    <span class="keyword">this</span>.surfaceTintColor,</span><br><span class="line">    <span class="keyword">this</span>.insetAnimationDuration = <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">100</span>),</span><br><span class="line">    <span class="keyword">this</span>.insetAnimationCurve = Curves.decelerate,</span><br><span class="line">    <span class="keyword">this</span>.insetPadding = _defaultInsetPadding,</span><br><span class="line">    <span class="keyword">this</span>.clipBehavior = Clip.none,</span><br><span class="line">    <span class="keyword">this</span>.shape,</span><br><span class="line">    <span class="keyword">this</span>.alignment,</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(clipBehavior != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(elevation == <span class="keyword">null</span> || elevation &gt;= <span class="number">0.0</span>),</span><br><span class="line">       _fullscreen = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>Dialog</code> 小组价的构造函数可以看出来，其本身内置了背景色、阴影、边框、对其、边距和动画等属性，为对话框提供了默认样式和行为，定制自己的对话框时改起来也很方便。实现代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_showCustomDialog() &#123;</span><br><span class="line">  showDialog(</span><br><span class="line">    context: context,</span><br><span class="line">    <span class="comment">// 设置背景透明度</span></span><br><span class="line">    barrierColor: Colors.black.withOpacity(<span class="number">0.5</span>),</span><br><span class="line">    builder: (BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> Dialog(</span><br><span class="line">        shape: RoundedRectangleBorder(</span><br><span class="line">          borderRadius: BorderRadius.circular(<span class="number">12.0</span>),</span><br><span class="line">        ),</span><br><span class="line">        child: Container(</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisSize: MainAxisSize.min,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              SizedBox(height: <span class="number">10</span>),</span><br><span class="line">              Text(<span class="string">&#x27;Custom Dialog Title&#x27;</span>, style: TextStyle(fontSize: <span class="number">20</span>)),</span><br><span class="line">              SizedBox(height: <span class="number">16</span>),</span><br><span class="line">              Text(<span class="string">&#x27;This is a custom dialog content.&#x27;</span>),</span><br><span class="line">              SizedBox(height: <span class="number">16</span>),</span><br><span class="line">              TextButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  Navigator.of(context).pop();</span><br><span class="line">                &#125;,</span><br><span class="line">                child: Text(<span class="string">&#x27;OK&#x27;</span>),</span><br><span class="line">              ),</span><br><span class="line">              SizedBox(height: <span class="number">10</span>),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bloc-中使用弹框"><a href="#bloc-中使用弹框" class="headerlink" title="bloc 中使用弹框"></a><code>bloc</code> 中使用弹框</h2><p>在使用 <code>bloc</code>（业务逻辑组件）进行状态管理时，很多的时候特定的业务逻辑执行过程中弹出对话框，如保存表单数据时，如果出现网络错误或验证错误，可以弹出对话框通知用户；执行删除操作时需要弹出对话框让用户确认操作是否继续；执行耗时操作弹出一个加载对话框，向用户展示操作正在进行，特别是在和硬件网关 <code>zigbee</code> 通信时，如查找设备，会有等待和重试的过程；以及完成某个操作时提示用户操作结果等等场景。但是我们在调用 <code>showDialog</code> 又需要传 <code>context</code> 参数，<code>context</code> 是用来标记 <code>widget</code> 在 <code>widget tree</code> 的位置，<code>bloc</code> 中获取不到 <code>context</code>，那么在<code>bloc</code> 中使用弹框改如何实现呢？</p><p>还记得在《Flutter大型项目架构：路由管理篇》文章中实现的 <code>AppNavigatorImpl</code> 类吗？还有实现的 <code>push</code>、<code>pop</code>等操作，我们今天要实现在 <code>bloc</code>  弹框也是在 <code>AppNavigatorImpl</code> 类中实现。首先在其抽象类 <code>AppNavigator</code> 中添加如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppNavigator</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  Future&lt;T?&gt; showDialog&lt;T <span class="keyword">extends</span> <span class="built_in">Object?</span>&gt;(</span><br><span class="line">    AppPopupInfo appPopupInfo, &#123;</span><br><span class="line">    <span class="built_in">bool</span> barrierDismissible = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> useSafeArea = <span class="keyword">false</span>,</span><br><span class="line">    <span class="built_in">bool</span> useRootNavigator = <span class="keyword">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>AppNavigatorImpl</code> 实现 <code>showDialog</code> 函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LazySingleton</span>(<span class="keyword">as</span>: AppNavigator)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppNavigatorImpl</span> <span class="keyword">extends</span> <span class="title">AppNavigator</span> <span class="title">with</span> <span class="title">LogMixin</span> </span>&#123;</span><br><span class="line">  AppNavigatorImpl(</span><br><span class="line">    <span class="keyword">this</span>._appRouter,</span><br><span class="line">    <span class="comment">// 注入 PopupInfoMapper</span></span><br><span class="line">    <span class="keyword">this</span>._appPopupInfoMapper,</span><br><span class="line">    <span class="keyword">this</span>._appRouteInfoMapper,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  TabsRouter? tabsRouter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> AppRouter _appRouter;</span><br><span class="line">  <span class="comment">// BasePopupInfoMapper 是抽象类， PopupInfoMapper 的父类</span></span><br><span class="line">  <span class="keyword">final</span> BasePopupInfoMapper _appPopupInfoMapper;</span><br><span class="line">  <span class="keyword">final</span> BaseRouteInfoMapper _appRouteInfoMapper;</span><br><span class="line">  <span class="keyword">final</span> _popups = &lt;AppPopupInfo&gt;&#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  StackRouter? <span class="keyword">get</span> _currentTabRouter =&gt;</span><br><span class="line">      tabsRouter?.stackRouterOfIndex(currentBottomTab);</span><br><span class="line"></span><br><span class="line">  StackRouter <span class="keyword">get</span> _currentTabRouterOrRootRouter =&gt;</span><br><span class="line">      _currentTabRouter ?? _appRouter;</span><br><span class="line"></span><br><span class="line">  BuildContext <span class="keyword">get</span> _rootRouterContext =&gt;</span><br><span class="line">      _appRouter.navigatorKey.currentContext!;</span><br><span class="line"></span><br><span class="line">  BuildContext? <span class="keyword">get</span> _currentTabRouterContext =&gt;</span><br><span class="line">      _currentTabRouter?.navigatorKey.currentContext;</span><br><span class="line"></span><br><span class="line">  BuildContext <span class="keyword">get</span> _currentTabContextOrRootContext =&gt;</span><br><span class="line">      _currentTabRouterContext ?? _rootRouterContext;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> currentBottomTab &#123;</span><br><span class="line">    <span class="keyword">if</span> (tabsRouter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;Not found any TabRouter&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tabsRouter?.activeIndex ?? <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;T?&gt; showDialog&lt;T <span class="keyword">extends</span> <span class="built_in">Object?</span>&gt;(</span><br><span class="line">    AppPopupInfo appPopupInfo, &#123;</span><br><span class="line">    <span class="built_in">bool</span> barrierDismissible = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> useSafeArea = <span class="keyword">false</span>,</span><br><span class="line">    <span class="built_in">bool</span> useRootNavigator = <span class="keyword">true</span>,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_popups.contains(appPopupInfo)) &#123;</span><br><span class="line">      <span class="keyword">return</span> Future.value(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _popups.add(appPopupInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> showDialog&lt;T&gt;(</span><br><span class="line">      context: useRootNavigator</span><br><span class="line">          ? _rootRouterContext</span><br><span class="line">          : _currentTabContextOrRootContext,</span><br><span class="line">      builder: (_) =&gt; m.WillPopScope(</span><br><span class="line">        onWillPop: () <span class="keyword">async</span> &#123;</span><br><span class="line">          _popups.remove(appPopupInfo);</span><br><span class="line">          <span class="keyword">return</span> Future.value(<span class="keyword">true</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: _appPopupInfoMapper.map(appPopupInfo, <span class="keyword">this</span>),</span><br><span class="line">      ),</span><br><span class="line">      useRootNavigator: useRootNavigator,</span><br><span class="line">      barrierDismissible: barrierDismissible,</span><br><span class="line">      useSafeArea: useSafeArea,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>_rootRouterContext</code> 是 <code>auto_route</code> 的根 <code>navigatorKey</code> 提供的，用于管理和控制导航操作，这样可以实现在整个应用程序的任何地方访问和操作导航堆栈。<code>auto_route</code> 库通过 <code>Navigator</code> 和 <code>GlobalKey</code> 的结合实现了对 <code>navigatorKey</code> 的支持。<code>_currentTabRouterContext</code> 是当前所显示的 <code>tab</code> 的<code>navigatorKey</code> 提供的，负责当前 <code>tab</code> 及子页面的导航操作。当调用 <code>showDialog</code> 时就可以使用 <code>_rootRouterContext</code> 或者 <code>_currentTabContextOrRootContext</code> 参数，这就解决了 <code>context</code> 参数的问题了。</p><p><code>AppPopupInfo</code> 和 <code>AppRouteInfo</code> 的作用是一样的，实现了抽象类 <code>BasePopupInfoMapper</code>，使用 <code>@freezed</code> 注解，在 <code>AppPopupInfoMapper</code> 的 <code>map</code> 函数中使用 <code>when</code> 可根据不同工厂方法返回不同类型的 <code>AppPopupInfo</code> 实例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@freezed</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppPopupInfo</span> <span class="title">with</span> <span class="title">_</span>$<span class="title">AppPopupInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">factory</span> AppPopupInfo.confirmDialog(&#123;</span><br><span class="line">    <span class="meta">@Default</span>(<span class="string">&#x27;&#x27;</span>) <span class="built_in">String</span> message,</span><br><span class="line">    <span class="built_in">Function</span>&lt;<span class="keyword">void</span>&gt;? onPressed,</span><br><span class="line">  &#125;) = _ConfirmDialog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePopupInfoMapper</span> </span>&#123;</span><br><span class="line">  Widget map(AppPopupInfo appRouteInfo, AppNavigator navigator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LazySingleton</span>(<span class="keyword">as</span>: BasePopupInfoMapper)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppPopupInfoMapper</span> <span class="keyword">extends</span> <span class="title">BasePopupInfoMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget map(AppPopupInfo appPopupInfo, AppNavigator navigator) &#123;</span><br><span class="line">    <span class="keyword">return</span> appPopupInfo.<span class="keyword">when</span>(</span><br><span class="line">      confirmDialog: (message, onPressed) &#123;</span><br><span class="line">        <span class="comment">// 这里返回的是 Dialog 的内容</span></span><br><span class="line">        <span class="keyword">return</span> Dialog(</span><br><span class="line">          shape: RoundedRectangleBorder(</span><br><span class="line">            borderRadius: BorderRadius.circular(<span class="number">12.0</span>),</span><br><span class="line">          ),</span><br><span class="line">          child: Container(</span><br><span class="line">            padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">            child: Column(</span><br><span class="line">              mainAxisSize: MainAxisSize.min,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Text(message),</span><br><span class="line">                SizedBox(height: <span class="number">16</span>),</span><br><span class="line">                TextButton(</span><br><span class="line">                  onPressed: onPressed,</span><br><span class="line">                  child: Text(<span class="string">&#x27;OK&#x27;</span>),</span><br><span class="line">                ),</span><br><span class="line">                SizedBox(height: <span class="number">10</span>),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>bloc</code> 中或者页面中调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">navigator.showDialog(AppPopupInfo.confirmDialog(</span><br><span class="line">  message: <span class="string">&quot;显示弹框&quot;</span>,</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><p>这里的 <code>navigator</code> 是从哪里来的呢？在《Flutter大型项目架构：路由管理篇》文章中最后一部分<code>bloc</code> 中使用 <code>navigator</code> 跳转页面介绍了将 <code>navigator</code> 注入到 <code>BaseBloc</code> 和 <code>BasePageState</code>，感兴趣的可以去看看，这样无论是在 <code>bloc</code> 层还是 <code>page</code> 页面都能使用 <code>navigator</code> 跳转页面和弹出 <code>Dialog</code> 等操作，在 <code>bloc</code> 层使用 <code>ActionSheet</code>、<code>Toast</code> 等和 <code>Dialog</code> 一样的逻辑。</p><p>在 <code>bloc</code> 层使用弹框的实现过程其实也是路由管理的一部分，本篇文章是单独把弹框的使用做一个集锦，也希望能够帮到你。那么，在项目中你是如何使用弹框的呢，关于弹框的使用有什么好的建议和想法欢迎留言，感谢您的阅读，记得关注加点赞哦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/24/SL5gnJfYyhr4NvM.png&quot; alt=&quot; _2_.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;日常开发中，&lt;code&gt;Flutter&lt;/code&gt; 弹框（&lt;code&gt;Dialog&lt;/code&gt;）是我们使用频率非常高的控件。无论是提示用户信息、确认用户操作，还是表单填写，弹框都能派上用场。然而，看似简单的弹框，实际使用起来却有不少坑和使用的技巧。今天，我们就来聊聊这些弹框的使用技巧，文末还有关于在 &lt;code&gt;bloc&lt;/code&gt; 如何使用弹框的内容，保证你看完之后干货满满，下面直接开始吧。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter设计模式全面解析：单例模式</title>
    <link href="http://www.nnxkcloud.com/2024/05/22/Flutter%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.nnxkcloud.com/2024/05/22/Flutter%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-05-22T02:20:52.000Z</published>
    <updated>2024-10-15T03:05:34.690Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/05/22/tswSPnaY25B4Eie.png" alt="Flutter _1_.png"></p><p>谈到设计模式这个“古老”的话题，大家先别急着划走哈，虽然对它再熟悉不过，几乎是最初开始学习编程到现在伴随着我们整个编程生涯，最早 <code>Java</code>、<code>C++</code> 语言实现的各种设计模式到现在还会经常有所接触，面试中也是必问的环节，在开发 <code>Flutter</code> 项目的时候，也会多少借鉴了其它语言设计模式的实现，但始终觉得<code>dart</code> 语言实现的设计模式理解不够系统，有的实现还缺点儿 <code>dart</code> 语言本身的语法特性。加上最近在看一些 <code>Flutter</code> 框架及常用第三方插件的源码时候，发现这些源码背后或多或少都有设计模式的影子。铺垫了这么多，还真不是我在这里故意卷<code>Flutter</code> 设计模式这些个话题，它对于我们日常编写高质量代码及理解 <code>dart</code> 语言特性、<code>Flutter</code> 的框架和热门第三方插件、<code>OOP</code> 设计模式、理解<code>SOLID</code> 原则及其应用、代码架构或软件工程等还是有很大的帮助的。既然这么多的好处，那还等什么呢？</p><span id="more"></span><h2 id="Singleton-Pattern"><a href="#Singleton-Pattern" class="headerlink" title="Singleton Pattern"></a><code>Singleton Pattern</code></h2><p><code>Singleton</code>  模式在项目中再常见不过了，实现起来也很简单，它一般包括私有构的造函数、一个静态实例和提供全局访问点。该模式是用来确保一个类只有一个实例，并提供一个全局访问点。简单来说，就是限制一个类在应用程序中只能有一个实例存在。这种模式通常用于需要全局共享资源的场景，比如配置管理、日志记录器、全局状态保存等，下面来实现一个单例类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 私有构造函数</span></span><br><span class="line">  Singleton._privateConstructor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 静态实例</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Singleton _instance = Singleton._privateConstructor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 提供全局访问点</span></span><br><span class="line">  <span class="keyword">static</span> Singleton <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的单例类 <code>Singleton</code> 可以看出：</p><ol><li><code>Singleton</code> 类构造函数被标记为私有，用来确保该类不能从类外部去实例化。</li><li>包含一个静态实例，该实例是对类实例本身的引用。</li><li>该实例只能通过静态的 <code>get</code> 访问，为全局提供访问点。</li></ol><p>除了上面的写法还有没有其它的实现呢？我们可以使用 <code>factory</code> 构造函数特性来实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Singleton _instance = Singleton._internal();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Singleton() &#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Singleton._internal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// Singleton();</span></span><br></pre></td></tr></table></figure><p>在 <code>Dart</code> 中，<code>factory</code> 构造函数是一种特殊的构造函数，用于控制类实例的创建过程。与常规构造函数不同，<code>factory</code> 构造函数并不总是创建一个新的实例，它可以返回现有的实例或一个子类的实例，<code>factory</code> 构造函数也常被用来实现单例模式。当然除了前面两种还有如下面这种更加简单的实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  Singleton._();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = Singleton._();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// Singleton.instance;</span></span><br></pre></td></tr></table></figure><p>在 <code>Flutter</code> 开发中，基于 <code>factory</code> 构造函数和上面第三种实现方式会更常见，因为它们够简单直接且线程安全。那么在 <code>Dart</code> 中还有没有更加便捷的方式创建单例呢？当然有的。</p><h2 id="其它的实现方式"><a href="#其它的实现方式" class="headerlink" title="其它的实现方式"></a>其它的实现方式</h2><p>通过依赖注入插件 <code>injectable</code> 添加为类 <code>@Singleton</code> 和 <code>@LazySingleton</code> 注解也能实现单例，代码也更加的简洁，也是我个人比较推荐的实现方式。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppNavigator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AppNavigator();</span><br><span class="line">  <span class="keyword">void</span> push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LazySingleton</span>(<span class="keyword">as</span>: AppNavigator)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppNavigatorImpl</span> </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> push()&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>我们知道 <code>Dart</code> 可以说是一种单线程编程语言，代码的执行通常发生在一个单线程上。这个单线程模型是通过事件循环来管理的。事件循环负责处理事件队列中的任务，这些任务包括 I&#x2F;O 操作、定时器回调、用户输入等。</p><p>所有的 Dart 代码（除非明确使用多线程技术）都是在这个单线程上执行的，也就是一个隔离区（ <code>isolate</code> ）中执行，因此，在 <code>Dart</code> 中实现单例时，只要您不自己创建一个新的独立于代码的隔离区（ <code>isolate</code> ），根本就不必担心线程安全性。所以上面懒加载式单例的第一种实现方式基本上能满足我们的需求。</p><h2 id="单例模式与-SOLID-原则"><a href="#单例模式与-SOLID-原则" class="headerlink" title="单例模式与 SOLID 原则"></a>单例模式与 <code>SOLID</code> 原则</h2><p>单例模式由于其本身的实现（确保一个类只有一个实例，并提供全局访问点）在某些方面与 <code>SOLID</code> 原则（面向对象设计的五个原则）是相冲突的，下面实现一个简单的日志打印的单例类来详细说明一下。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Logger _instance = Logger._internal();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">  Logger._internal();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> Logger <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Log: <span class="subst">$message</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SOLID</code> 原则中的单一职责原则要求每个类应该只有一个职责，即仅负责一件事。而 <code>Logger</code> 单例类不仅负责日志记录，还负责管理其唯一实例的生命周期，它承担了额外的职责，违背了单一职责原则。</p><p><code>SOLID</code> 原则中开闭原则要求类应该对扩展开放，对修改关闭，在而单例 <code>Logger</code> 中如果想要拓展以支持不同的日志目标，如将日志写入文件等，不得不修改现有代码，而不是通过继承或组合进行扩展功能。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Logger _instance = Logger._internal();</span><br><span class="line"></span><br><span class="line">  Logger._internal();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Logger <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Log: <span class="subst">$message</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加新功能</span></span><br><span class="line">  <span class="keyword">void</span> saveLogToFile(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="comment">// 将日志写入文件的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不符合开闭原则，因为需要直接修改 <code>Logger</code> 类来添加新功能。</p><p>里氏替换原则要求子类应该可以替换父类，并且不影响其它代码的正确执行。单例模式通过私有构造函数限制实例化，所以继承和替换就很难做到了。例如，如果创建一个子类 <code>FileLogger</code> 继承自 <code>Logger</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="comment">// 自定义文件日志记录逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面写法会直接报错，<code>FileLogger</code> 也没法替换 <code>Logger</code> 来实现文件日志记录的逻辑。</p><p>接口隔离原则要求不依赖于不需要的接口。单例模式本身与接口隔离原则没有直接冲突。然而，如果单例类实现了过多的职责，就可能导致其接口庞大，调用方很多时候不得不依赖于它们不需要的方法，这就违反接口隔离原则。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Logger _instance = Logger._internal();</span><br><span class="line"></span><br><span class="line">  Logger._internal();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Logger <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Log: <span class="subst">$message</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> logToFile(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="comment">// 将日志写入文件的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> logToNetwork(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="comment">// 将日志发送到网络服务器的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖倒置原则要求高层模块不应该依赖低层模块，二者都应该依赖于抽象。单例模式通常通过静态方法或属性提供实例，这使得高层模块依赖于具体实现，而不是抽象接口。这个原则我在之前的文章《Flutter大型项目架构：依赖管理篇》中有讲到，文章的 <code>AppNavigator</code>  和 <code>AppNavigatorImpl</code> 类，<code>AppNavigator</code> 是抽象类，所有用到路由的调用都是通过 <code>AppNavigator</code>，而 <code>AppNavigatorImpl</code> 才是实现类，也可以参考上面其它实现方式的代码。</p><h2 id="需要注意什么"><a href="#需要注意什么" class="headerlink" title="需要注意什么"></a>需要注意什么</h2><p>虽说 <code>Singleton</code> 很多和 <code>SOLID</code> 原则相违背，但其简单直接实现方式，尤其是在需要全局共享资源的场景中去使用太方便了。但是我们在追求方便的同时也要留意过度使用 <code>Singleton</code> 模式可能带来的问题，尤其是大型的 <code>Flutter</code> 项目中。</p><ol><li>确保单例适当的生命周期，避免资源的泄露，某些时候单例对象可能会持有大量资源，或者与其他部分有复杂的交互，需要在合适的时机释放这些资源。</li><li>单例模式应仅用于那些需要在全局范围内唯一且易于访问的对象，如 <code>Logger</code> 类、<code>AppNavigator</code> 类等。如果滥用单例会导致代码难以维护和测试。</li><li>确保单例对象在使用前已经正确配置和初始化。特别是在大型项目中，单例可能需要依赖多个模块的初始化顺序，确保这些依赖关系不会引发初始化错误，如在一个统一的模块（<code>initializer</code>）来处理 <code>Singleton</code> 初始化。</li><li>在类中直接单例不咋容易被测试，这个时候可以使用依赖注入（<code>DI</code>）来创建和管理单例实例，在测试时可以替换单例对象。</li><li>确保单例对象的职责单一，不要让其承担过多的责任。通过接口分离和依赖注入，保持系统设计的灵活性和可扩展性。参考 <code>AppNavigator</code>  和 <code>AppNavigatorImpl</code> 类的实现。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了单例模式实现的几种方式、单例的线程安全问题、单例模式与 <code>SOLID</code> 原则和在大型项目中使用单例需要注意什么，希望对你在以后的 <code>Flutter</code> 开发过程中有所帮助，感谢您的阅读！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/22/tswSPnaY25B4Eie.png&quot; alt=&quot;Flutter _1_.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;谈到设计模式这个“古老”的话题，大家先别急着划走哈，虽然对它再熟悉不过，几乎是最初开始学习编程到现在伴随着我们整个编程生涯，最早 &lt;code&gt;Java&lt;/code&gt;、&lt;code&gt;C++&lt;/code&gt; 语言实现的各种设计模式到现在还会经常有所接触，面试中也是必问的环节，在开发 &lt;code&gt;Flutter&lt;/code&gt; 项目的时候，也会多少借鉴了其它语言设计模式的实现，但始终觉得&lt;code&gt;dart&lt;/code&gt; 语言实现的设计模式理解不够系统，有的实现还缺点儿 &lt;code&gt;dart&lt;/code&gt; 语言本身的语法特性。加上最近在看一些 &lt;code&gt;Flutter&lt;/code&gt; 框架及常用第三方插件的源码时候，发现这些源码背后或多或少都有设计模式的影子。铺垫了这么多，还真不是我在这里故意卷&lt;code&gt;Flutter&lt;/code&gt; 设计模式这些个话题，它对于我们日常编写高质量代码及理解 &lt;code&gt;dart&lt;/code&gt; 语言特性、&lt;code&gt;Flutter&lt;/code&gt; 的框架和热门第三方插件、&lt;code&gt;OOP&lt;/code&gt; 设计模式、理解&lt;code&gt;SOLID&lt;/code&gt; 原则及其应用、代码架构或软件工程等还是有很大的帮助的。既然这么多的好处，那还等什么呢？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter大型项目架构：路由管理篇</title>
    <link href="http://www.nnxkcloud.com/2024/05/18/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E7%AF%87/"/>
    <id>http://www.nnxkcloud.com/2024/05/18/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E7%AF%87/</id>
    <published>2024-05-18T02:33:42.000Z</published>
    <updated>2024-10-15T03:05:34.689Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/05/18/LpIQhSkEji1DgR3.png"></p><p>在本系列的依赖管理篇讲到了以路由依赖为例子来介绍如何做依赖设计的，具体操作就是将抽象类 <code>AppNavigator</code> 和实现类 <code>AppNavigatorImpl</code> 通过依赖注入的方式联系起来，而在使用的时候调用 <code>AppNavigator</code>  ，不再关心具体的实现逻辑，这种设计在做组件分层和处理多个组件间的依赖关系的时候显得尤为重要，也很好的诠释了软件架构设计中的 <strong>依赖于抽象而不是具体的实现</strong>。但是关于 <code>Flutter</code> 中路由管理知识以及在大型项目中如何做路由设计很少有介绍，本篇就来说一说路由管理在大型的项目的实践。</p><span id="more"></span><h2 id="Flutter原生路由"><a href="#Flutter原生路由" class="headerlink" title="Flutter原生路由"></a><code>Flutter</code>原生路由</h2><p>记得刚开始开发 <code>Flutter</code> 应用的时候，跳转页面直接使用 <code>Navigator.of(context).push</code> ，返回 <code>Navigator.pop</code>，简单快捷，传参也方便，还能定制页面跳转的动画，从 <code>iOS</code> 原生开发转过来开发 <code>Flutter</code> 也能很快适应。随着应用的功能越来越多，逻辑也变得复杂，各种页面跳转及传参，发现了一些原生的路由（<code>Navigator</code> 和 <code>Route</code>）的弊端。</p><p>对于更复杂的导航需求，比如深层嵌套的导航、条件导航、全局导航钩子等，原生路由的能力不足，比如一个常见多层次的开发场景，有三个页面：<code>HomeScreen</code>、<code>CategoryScreen</code> 和 <code>ItemScreen</code>。用户需要通过 <code>CategoryScreen</code> 导航到 <code>ItemScreen</code>，并从 <code>ItemScreen</code> 返回到 <code>CategoryScreen</code> 或 <code>HomeScreen</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置路由表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      initialRoute: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: (context) =&gt; HomeScreen(),</span><br><span class="line">        <span class="string">&#x27;/category&#x27;</span>: (context) =&gt; CategoryScreen(),</span><br><span class="line">        <span class="string">&#x27;/item&#x27;</span>: (context) =&gt; ItemScreen(),</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  HomeScreen -&gt; CategoryScreen</span></span><br><span class="line">Navigator.pushNamed(context, <span class="string">&#x27;/category&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CategoryScreen -&gt; ItemScreen</span></span><br><span class="line">Navigator.pushNamed(context, <span class="string">&#x27;/item&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ItemScreen -&gt; HomeScreen</span></span><br><span class="line">Navigator.popUntil(context, ModalRoute.withName(<span class="string">&#x27;/&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上面例子可以看出来，深层嵌套导航时候需要手动去管理返回路径和路由堆栈，这还没有加上各种复杂的参数传递，在复杂的而应用中这样使用太麻烦了，还容易出错。当然如果你觉得上面这种写法还能接受，那么原生路由应用在处理 <code>tab</code> 页面中的嵌套路由的时候又会是什么情况呢？</p><p>那好办啊，给每个 <code>Tab</code> 页面中使用一个独立的 <code>Navigator</code> 组件来管理该 <code>Tab</code> 内部的路由，这样可以使每个 <code>Tab</code> 页面具有独立的路由堆栈而互不影响，不就解决了嘛。嗯，好像是可以哈，这时候产品的需求来了：某个 <code>tab</code> 的子页面回到其它的 <code>tab</code> 首页（如下图所示），该怎么实现跳转呢？答案是没有很好的办法，因为每个 <code>tab</code> 中的 <code>Navigator</code> 是相互独立的，各自管理自己的路由堆栈。除非是通过全局状态管理来记录 <code>tab</code> 页面的状态，但是这样做复杂度又上升了。</p><p><img src="https://s2.loli.net/2024/05/17/1fmULcvRJndYST5.png" alt="tab_stucture.png"></p><p>条件导航、全局导航钩子也很理解，比如说对某些页面的访问进行权限控制，用户在未登录时访问主页需要重定向到登录页面，可以使用 <code>NavigatorObserver</code> 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthGuard</span> <span class="keyword">extends</span> <span class="title">NavigatorObserver</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didPush(Route&lt;<span class="built_in">dynamic</span>&gt; route, Route&lt;<span class="built_in">dynamic</span>&gt;? previousRoute) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didPush(route, previousRoute);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (route.settings.name == <span class="string">&#x27;/protected&#x27;</span> &amp;&amp; !isLoggedIn) &#123;</span><br><span class="line">      <span class="comment">// 如果用户未登录，则重定向到登录页面</span></span><br><span class="line">      WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">        route.navigator?.pushReplacementNamed(<span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isLoggedIn =&gt; <span class="keyword">false</span>; <span class="comment">// 假设这是用户登录状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>AuthGuard</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      initialRoute: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: (context) =&gt; HomeScreen(),</span><br><span class="line">        <span class="string">&#x27;/protected&#x27;</span>: (context) =&gt; ProtectedScreen(),</span><br><span class="line">        <span class="string">&#x27;/login&#x27;</span>: (context) =&gt; LoginScreen(),</span><br><span class="line">      &#125;,</span><br><span class="line">      navigatorObservers: [AuthGuard()],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以使用 <code>NavigatorObserver</code> 实现类似需求，但使用起来还是不够方便简洁，而且当我们需要对某个页面添加 <code>Observer</code> 的时候，特别是需要对某些页面的访问进行特殊权限控制的时候，使用原生的  <code>NavigatorObserver</code>  更加麻烦了，下面的例子在 <code>HomeScreen</code> 跳转到 <code>DetailsScreen</code> 之间添加 <code>Observer</code> 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">  context,</span><br><span class="line">  MaterialPageRoute(</span><br><span class="line">    builder: (context) =&gt; ObserverPage(</span><br><span class="line">      observer: MyPageObserver(),</span><br><span class="line">      child: DetailsScreen(),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>包装器 <code>ObserverPage</code> 类 和 <code>MyPageObserver</code> 的实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  <span class="keyword">final</span> NavigatorObserver observer;</span><br><span class="line"></span><br><span class="line">  ObserverPage(&#123;<span class="keyword">required</span> <span class="keyword">this</span>.child, <span class="keyword">required</span> <span class="keyword">this</span>.observer&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator(</span><br><span class="line">      observers: [observer],</span><br><span class="line">      onGenerateRoute: (settings) &#123;</span><br><span class="line">        <span class="keyword">return</span> MaterialPageRoute(</span><br><span class="line">          builder: (context) =&gt; child,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPageObserver</span> <span class="keyword">extends</span> <span class="title">NavigatorObserver</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didPush(Route route, Route? previousRoute) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didPush(route, previousRoute);</span><br><span class="line">    <span class="comment">// 处理特殊的业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;判断条件&quot;</span>) &#123;</span><br><span class="line">      WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">        route.navigator?.pushReplacementNamed(<span class="string">&#x27;/xx&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下使用自定义的 <code>NavigatorObserver</code> 太过麻烦了，有没有？一个小小的需求竟然要加这么代码，同样的问题在参数传递的过程中也有。</p><p>原生路由在完成规模不大的项目时是能应对的，但是对于页面较多，跳转逻辑也比较复杂的应用它的弊端就会凸显出来了，那么大型项目是如何处理上面的问题呢？又是如何做路由管理的？</p><h2 id="AppNavigator-的实现"><a href="#AppNavigator-的实现" class="headerlink" title="AppNavigator 的实现"></a><code>AppNavigator</code> 的实现</h2><p>为什么是 <code>auto_router</code> 而不是 <code>go_router</code> 呢？个人觉得因人而异吧，<code>auto_router</code> 刚好能我的使用需求，通过注解的方式配置路由，需要编写的代码量较少，而且支持嵌套路由、参数传递、路由守卫等高级功能，也可以很方便地与 <code>Provider</code>、<code>Bloc</code> 等状态管理库集成，上面介绍使用原生路由带来的问题在 <code>auto_router</code> 都有相应的解决方案，具体的使用大家可以看看它的文档。本篇主要讲一讲在大型的 <code>Flutter</code> 中如何使用和管理路由的。</p><p>在做分层设计的时候，往往将抽象和具体实现分开，路由管理中就是抽象类 <code>AppNavigator</code> 放在 <code>domian</code> 组件包中，实现类 <code>AppNavigatorImpl</code> 直接放在了主工程中，通过依赖注入来关联彼此，下面来详细介绍一下简化版的实现类 <code>AppNavigatorImpl</code> 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:app/navigation/routes/app_router.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:auto_route/auto_route.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:domain/domain.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span> <span class="keyword">as</span> m;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:injectable/injectable.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:app/navigation/base/base_popup_info_mapper.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:app/navigation/base/base_route_info_mapper.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:shared/shared.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LazySingleton</span>(<span class="keyword">as</span>: AppNavigator)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppNavigatorImpl</span> <span class="keyword">extends</span> <span class="title">AppNavigator</span> <span class="title">with</span> <span class="title">LogMixin</span> </span>&#123;</span><br><span class="line">  AppNavigatorImpl(</span><br><span class="line">    <span class="keyword">this</span>._appRouter,</span><br><span class="line">    <span class="keyword">this</span>._appRouteInfoMapper,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> tabRoutes = <span class="keyword">const</span> [</span><br><span class="line">    OrderTab(),</span><br><span class="line">    HomeTab(),</span><br><span class="line">    MyPageTab(),</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  TabsRouter? tabsRouter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> AppRouter _appRouter;</span><br><span class="line">  <span class="keyword">final</span> BaseRouteInfoMapper _appRouteInfoMapper;</span><br><span class="line">  </span><br><span class="line">  StackRouter? <span class="keyword">get</span> _currentTabRouter =&gt; tabsRouter?.stackRouterOfIndex(currentBottomTab);</span><br><span class="line">  StackRouter <span class="keyword">get</span> _currentTabRouterOrRootRouter =&gt; _currentTabRouter ?? _appRouter;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;T?&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object?</span>&gt;(AppRouteInfo appRouteInfo) &#123;</span><br><span class="line">    <span class="keyword">return</span> _appRouter.push&lt;T&gt;(_appRouteInfoMapper.map(appRouteInfo));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; pop&lt;T <span class="keyword">extends</span> <span class="built_in">Object?</span>&gt;(&#123;T? result, <span class="built_in">bool</span> useRootNavigator = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> useRootNavigator</span><br><span class="line">        ? _appRouter.pop&lt;T&gt;(result)</span><br><span class="line">        : _currentTabRouterOrRootRouter.pop&lt;T&gt;(result);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> currentBottomTab &#123;</span><br><span class="line">    <span class="keyword">if</span> (tabsRouter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;Not found any TabRouter&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tabsRouter?.activeIndex ?? <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> popUntilRootOfCurrentBottomTab() &#123;</span><br><span class="line">    <span class="keyword">if</span> (tabsRouter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;Not found any TabRouter&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_currentTabRouter?.canPop() == <span class="keyword">true</span>) &#123;</span><br><span class="line">      _currentTabRouter?.popUntilRoot();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> navigateToBottomTab(<span class="built_in">int</span> index, &#123;<span class="built_in">bool</span> notify = <span class="keyword">true</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tabsRouter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;Not found any TabRouter&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tabsRouter?.setActiveIndex(index, notify: notify);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 还有其它实现，这里先省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppNavigatorImpl</code> 构造方法中需注入三个实例，分别是 <code>AppRouter</code> 用于管理应用导航的核心类，是全局路由管理单例类，项目中用到所有的路由配置都集中在 <code>AppRouter</code>，通过使用 <code>auto_route</code> 包为 <code>AppRouter</code> 提供了一种结构化和类型安全的方式来定义和处理应用中的路由，下面是 <code>AppRouter</code> 配置代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:auto_route/auto_route.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:injectable/injectable.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;app_router.gr.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AutoRouterConfig</span>(</span><br><span class="line">  replaceInRouteName: <span class="string">&#x27;Page,Route&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="meta">@LazySingleton</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppRouter</span> <span class="keyword">extends</span> <span class="title">_</span>$<span class="title">AppRouter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RouteType <span class="keyword">get</span> defaultRouteType =&gt; <span class="keyword">const</span> RouteType.adaptive();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;AutoRoute&gt; <span class="keyword">get</span> routes =&gt; [</span><br><span class="line">    AutoRoute(page: LoginRoute.page),</span><br><span class="line">        AutoRoute(page: MainRoute.page, initial: <span class="keyword">true</span>, children: [</span><br><span class="line">            AutoRoute(</span><br><span class="line">              page: HomeTab.page,</span><br><span class="line">              maintainState: <span class="keyword">true</span>,</span><br><span class="line">              children: [</span><br><span class="line">                AutoRoute(page: HomeRoute.page, initial: <span class="keyword">true</span>),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            AutoRoute(</span><br><span class="line">              page: OrderTab.page,</span><br><span class="line">              maintainState: <span class="keyword">true</span>,</span><br><span class="line">              children: [</span><br><span class="line">                AutoRoute(page: OrderRoute.page, initial: <span class="keyword">true</span>),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            AutoRoute(</span><br><span class="line">              page: MyPageTab.page,</span><br><span class="line">              maintainState: <span class="keyword">true</span>,</span><br><span class="line">              children: [</span><br><span class="line">                AutoRoute(page: MyPageRoute.page, initial: <span class="keyword">true</span>),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">        ]),</span><br><span class="line">      ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RoutePage</span>(name: <span class="string">&#x27;HomeTab&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeTabPage</span> <span class="keyword">extends</span> <span class="title">AutoRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HomeTabPage(&#123;<span class="keyword">super</span>.key&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RoutePage</span>(name: <span class="string">&#x27;OrderTab&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderTabPage</span> <span class="keyword">extends</span> <span class="title">AutoRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> OrderTabPage(&#123;<span class="keyword">super</span>.key&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RoutePage</span>(name: <span class="string">&#x27;MyPageTab&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPageTabPage</span> <span class="keyword">extends</span> <span class="title">AutoRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyPageTabPage(&#123;<span class="keyword">super</span>.key&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>AppRouter</code> 配置了 <code>LoginPage</code>、<code>MainTabPage</code> 主页及下面的3个 <code>tab</code> 页面，在类 <code>AppNavigatorImpl</code>  使用 <code>_appRouter</code> 实例来实现各种页面的跳转，如 <code>push</code>、<code>pop</code>  等操作， </p><p>而 <code>tabsRouter</code>  可以切换当前显示的 <code>tab</code> 页，如 <code>navigateToBottomTab</code> 函数，但是好像没有看到在哪里给 <code>tabsRouter</code> 赋值啊，其实 <code>tabsRouter</code> 是在 <code>MainPage</code> 中实现的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget buildPage(BuildContext context) &#123;</span><br><span class="line"><span class="comment">// 这里的 AutoTabsScaffold 也是 auto_router 提供用来创建 AutoTabsRouter 的</span></span><br><span class="line">  <span class="keyword">return</span> AutoTabsScaffold(</span><br><span class="line">    routes: (navigator <span class="keyword">as</span> AppNavigatorImpl).tabRoutes,</span><br><span class="line">    bottomNavigationBuilder: (_, tabsRouter) &#123;</span><br><span class="line">    <span class="comment">// 此处给 `tabsRouter` 赋值</span></span><br><span class="line">      (navigator <span class="keyword">as</span> AppNavigatorImpl).tabsRouter = tabsRouter;</span><br><span class="line">      <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>tabsRouter</code>  获取当前的正在显示的 <code>_currentTabRouter</code> 可将子页面回退到栈底的 <code>tab</code> 页，如 <code>popUntilRootOfCurrentBottomTab</code>  操作。</p><p>那 <code>AppNavigatorImpl</code>  注入的这个 <code>BaseRouteInfoMapper</code> 又是干什么用的呢？<code>BaseRouteInfoMapper</code> 是一个抽象类，其实现类是 <code>AppRouteInfoMapper</code> ，也是通过依赖注入的方式将两者绑定。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRouteInfoMapper</span> </span>&#123;</span><br><span class="line">  PageRouteInfo map(AppRouteInfo appRouteInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LazySingleton</span>(<span class="keyword">as</span>: BaseRouteInfoMapper)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppRouteInfoMapper</span> <span class="keyword">extends</span> <span class="title">BaseRouteInfoMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  PageRouteInfo map(AppRouteInfo appRouteInfo) &#123;</span><br><span class="line"> <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> appRouteInfo.<span class="keyword">when</span>(</span><br><span class="line">      login: () =&gt; <span class="keyword">const</span> LoginRoute(),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写父类的 <code>map</code> 方法中会根据 <code>AppRouteInfo</code> 不同的工厂方法返回具体的 <code>PageRouteInfo</code> 对象，这里的是 <code>LoginRoute</code>，而 <code>LoginRoute</code> 是使用 <code>auto_router</code> 生成器来自动生成的，指向具体的路由。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:freezed_annotation/freezed_annotation.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;app_route_info.freezed.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@freezed</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppRouteInfo</span> <span class="title">with</span> <span class="title">_</span>$<span class="title">AppRouteInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">factory</span> AppRouteInfo.login() = _Login;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的作用是定义了一个不可变类 <code>AppRouteInfo</code>，并使用 <code>@freezed</code> 注解。这个类有一个工厂构造函数 <code>login</code>，当我们调用 <code>AppRouteInfo.login()</code> 时，它会创建一个 <code>_Login</code> 类型的实例，当然还可以定义更多的工厂构造函数并隐藏具体的实现类。所以在 <code>AppRouteInfoMapper</code> 的 <code>map</code> 函数中使用 <code>when</code> 可工具不同工厂方法返回不同类型的 <code>PageRouteInfo</code> 实例。</p><p>那么再回到 <code>AppNavigatorImpl</code> 看看 <code>push</code> 方法的实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Future&lt;T?&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object?</span>&gt;(AppRouteInfo appRouteInfo) &#123;</span><br><span class="line">  <span class="keyword">return</span> _appRouter.push&lt;T&gt;(_appRouteInfoMapper.map(appRouteInfo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>appRouteInfo</code> 就是传 <code>AppRouteInfo.login()</code> 来实现路由跳转，具体的页面调用就一句代码 <code>navigator.push(const AppRouteInfo.login());</code> </p><p>上面的 <code>navigator</code> 是在哪里实例化的呢？在这里是将 <code>AppNavigator</code> 的实例挂在自定义的 <code>State</code> 基类中，这样方便在所有的子页面使用 <code>navigator</code> 做页面跳转。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的 State 基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePageState</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>,</span></span><br><span class="line"><span class="class">    <span class="title">B</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 导航器对象</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> AppNavigator navigator = GetIt.instance.<span class="keyword">get</span>&lt;AppNavigator&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bloc-中使用-navigator-跳转页面"><a href="#bloc-中使用-navigator-跳转页面" class="headerlink" title="bloc 中使用 navigator 跳转页面"></a><code>bloc</code> 中使用 <code>navigator</code> 跳转页面</h2><p>使用 <code>bloc</code> 进行状态管理时，当某些业务逻辑处理完成时，需要根据结果进行页面跳转。例如，用户登录成功后跳转到主页，或者表单提交成功后跳转到成功页面。这种情况下，跳转逻辑通常位于 <code>Bloc</code> 内，以保业务逻辑和跳转逻辑的统一。那么这种情况改如何实现呢？</p><p>首先我们可以在 <code>bloc</code> 的基类中声明一个 <code>navigator</code> ，<code>BaseBloc</code> 的实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBloc</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">BaseBlocEvent</span>, <span class="title">S</span> <span class="keyword">extends</span> <span class="title">BaseBlocState</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">BaseBlocDelegate</span>&lt;<span class="title">E</span>, <span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">  BaseBloc(S initialState) : <span class="keyword">super</span>(initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBlocDelegate</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">BaseBlocEvent</span>,</span></span><br><span class="line"><span class="class">    <span class="title">S</span> <span class="keyword">extends</span> <span class="title">BaseBlocState</span>&gt; <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">E</span>, <span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">  BaseBlocDelegate(S initialState) : <span class="keyword">super</span>(initialState);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 导航器对象</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> AppNavigator navigator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>BasePageState</code> 中给当前页面绑定的 <code>bloc</code> 的 <code>navigator</code> 赋值。那么 <code>BasePageState</code>  修改后的代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的 State 基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePageState</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>,</span></span><br><span class="line"><span class="class">    <span class="title">B</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 导航器对象</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> AppNavigator navigator = GetIt.instance.<span class="keyword">get</span>&lt;AppNavigator&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 给当前页面绑定的 `bloc` 的 `navigator` 赋值</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> B bloc = GetIt.instance.<span class="keyword">get</span>&lt;B&gt;()</span><br><span class="line">  ..navigator = navigator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样任何继承自 <code>BaseBloc</code> 的子类都可以使用 <code>navigator</code> 来实现页面跳转逻辑。在 <code>bloc</code> 处理完事件和状态变化后直接决定何时以及如何进行页面跳转，从而保持应用的逻辑一致性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章有的地方描述的比较抽象，加上大量的代码，还有前面该系列文章的内容做基础，阅读起来是有一定的难度，感兴趣的同学强烈建议直接去看项目的 <a href="https://github.com/joedrm/jianyue_music_player">demo</a>，里面有更加详细的实现，结合本文的介绍更好理解。好了，今天就分享到这里，感谢您的阅读，记得关注加点赞。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/18/LpIQhSkEji1DgR3.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在本系列的依赖管理篇讲到了以路由依赖为例子来介绍如何做依赖设计的，具体操作就是将抽象类 &lt;code&gt;AppNavigator&lt;/code&gt; 和实现类 &lt;code&gt;AppNavigatorImpl&lt;/code&gt; 通过依赖注入的方式联系起来，而在使用的时候调用 &lt;code&gt;AppNavigator&lt;/code&gt;  ，不再关心具体的实现逻辑，这种设计在做组件分层和处理多个组件间的依赖关系的时候显得尤为重要，也很好的诠释了软件架构设计中的 &lt;strong&gt;依赖于抽象而不是具体的实现&lt;/strong&gt;。但是关于 &lt;code&gt;Flutter&lt;/code&gt; 中路由管理知识以及在大型项目中如何做路由设计很少有介绍，本篇就来说一说路由管理在大型的项目的实践。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>开始整活儿了，实战音乐播放器项目</title>
    <link href="http://www.nnxkcloud.com/2024/04/28/%E5%BC%80%E5%A7%8B%E6%95%B4%E6%B4%BB%E5%84%BF%E4%BA%86%EF%BC%8C%E5%AE%9E%E6%88%98%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.nnxkcloud.com/2024/04/28/%E5%BC%80%E5%A7%8B%E6%95%B4%E6%B4%BB%E5%84%BF%E4%BA%86%EF%BC%8C%E5%AE%9E%E6%88%98%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-04-27T16:57:56.000Z</published>
    <updated>2024-10-15T03:05:34.692Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/04/28/INhvlyAbFKJo6st.png"></p><p>前面谈到了怎么用 <code>flutter_bloc</code> 来做状态管理的、<code>Flutter</code> 项目架构是怎样分层的、各个分层之间又是如何依赖的，以及写界面用到的 <code>widget</code> 是如何设计封装实现的。这些是从一个成熟 <code>Flutter</code> 大型项目的不同角度来讨论的，很多人会觉得偏向于理论片面，或者说是很多实现的细节没有讲到，本篇将从零开始实现一个音乐播放器，也是将前面讲到的落地到真实的项目实践中去检验，看看会不会遇到什么问题，以及怎样去解决这些问题。</p><span id="more"></span><p>为什么要选择一个音乐播放器项目？音乐播放器项目大概是我在2年前开源放在 <code>github</code> 的一个项目，当时的代码实现也比较简单，没有用到前面讲到的大型项目架构用到的技术，本次开发完全使用最新的架构去实现，复杂度也有所上升，开发过程中为了照顾初学者，尽量把实现的细节说清楚。</p><h2 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h2><p>市面上的音乐播放器项目功能非常复杂，这里的音乐播放器项目参照了它们的一些常用的功能来开发，<strong>目的是仅供学习</strong>，所以在功能上会有所舍弃。下面图中是本次项目大概需要完成的功能，当然在实现的过程中下面列出来的这些功能也会有所变动。</p><p><img src="https://s2.loli.net/2024/04/27/HqZ78hway1QXPMx.png" alt="音乐播放器功能列表"></p><h2 id="UI-设计稿"><a href="#UI-设计稿" class="headerlink" title="UI 设计稿"></a>UI 设计稿</h2><p>下图是旧版本在 <code>Mac</code> 上运行的首页界面，页面风格是借鉴了 <code>dribbble</code> 上一位设计师大神的图片，具体的图片来源现在也忘记了。剩下其它页面和首页差不多也比较简单，这里就不放那么多图片了。本次实现的界面效果和旧版本会有些细微差别。</p><p><img src="https://s2.loli.net/2024/04/27/9rkZnKScyV67Eue.png"></p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>命令行运行 <code>dart --version</code> 查看 <code>dart SDK</code> 版本。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yunxi@joe workspace % dart --version</span><br><span class="line">Dart SDK version: <span class="number">2</span>.<span class="number">19</span>.<span class="number">1</span> (stable) (Tue Jan <span class="number">31</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">35</span> <span class="number">2023</span> +<span class="number">0000</span>) on &quot;macos_arm64&quot;</span><br></pre></td></tr></table></figure><p>命令行运行 <code>flutter doctor</code> 查看 <code>Flutter</code> 版本。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yunxi<span class="meta">@joe</span> flutter % flutter doctor  </span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[!] Flutter (Channel unknown, <span class="number">3.7</span><span class="number">.1</span>, <span class="keyword">on</span> macOS <span class="number">13.6</span> <span class="number">22</span>G120 darwin-arm64 (Rosetta), locale zh-Hans-CN)</span><br><span class="line">    ! Flutter version <span class="number">3.7</span><span class="number">.1</span> <span class="keyword">on</span> channel unknown at /Users/yunxi/flutter</span><br><span class="line">      Currently <span class="keyword">on</span> an unknown channel. Run `flutter channel` to <span class="keyword">switch</span> to an official channel.</span><br><span class="line">      If that doesn<span class="string">&#x27;t fix the issue, reinstall Flutter by following instructions at</span></span><br><span class="line"><span class="string">      https://flutter.dev/docs/get-started/install.</span></span><br><span class="line"><span class="string">    ! Unknown upstream repository.</span></span><br><span class="line"><span class="string">      Reinstall Flutter by following instructions at https://flutter.dev/docs/get-started/install.</span></span><br><span class="line"><span class="string">[✓] Android toolchain - develop for Android devices (Android SDK version 32.0.0-rc1)</span></span><br><span class="line"><span class="string">[✓] Xcode - develop for iOS and macOS (Xcode 15.2)</span></span><br><span class="line"><span class="string">[✓] Chrome - develop for the web</span></span><br><span class="line"><span class="string">[✓] Android Studio (version 2021.1)</span></span><br><span class="line"><span class="string">[✓] VS Code (version 1.88.1)</span></span><br><span class="line"><span class="string">[✓] Connected device (2 available)</span></span><br><span class="line"><span class="string">[✓] HTTP Host Availability</span></span><br></pre></td></tr></table></figure><p>这里 <code>Flutter</code> 版本用的是 <code>3.7.1</code>，而不是 <code>stable</code> 分支，因为需要兼容电脑里其它的老项目，所以没做升级更新。后面大家把代码下载下来后可以自己本地更新一下，有的依赖库也需要一起更新。开发工具用的是 <code>Android Studio</code>， 版本是 <code>version: 11.0.11</code>，也有段时间没更新了，不过不影响。</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>第一步：先建一个名为 <code>jianyue_music_player</code> 的 <code>workspace</code>，添加 <code>melos</code> 配置文件 <code>melos.yaml</code>，这里需要提前安装好 <code>melos</code>，安装命令也很简单，在命令行中运行命令： <code>dart pub global activate melos</code>。</p><p>第二步：在 <code>jianyue_music_player</code> 目录下新建主工程名为 <code>app</code>，并在配置文件 <code>melos.yaml</code> 添加如下依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">jianyue_music_player</span></span><br><span class="line"></span><br><span class="line"><span class="attr">packages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">app/**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">command:</span></span><br><span class="line">  <span class="attr">bootstrap:</span></span><br><span class="line">    <span class="attr">usePubspecOverrides:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scripts:</span></span><br><span class="line">  <span class="attr">analyze:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">dart</span> <span class="string">pub</span> <span class="string">global</span> <span class="string">run</span> <span class="string">melos</span> <span class="string">exec</span> <span class="string">--flutter</span> <span class="string">&quot;flutter analyze --no-pub --suppress-analytics&quot;</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">Run</span> <span class="string">analyze.</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pub_get:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">dart</span> <span class="string">pub</span> <span class="string">global</span> <span class="string">run</span> <span class="string">melos</span> <span class="string">exec</span> <span class="string">--flutter</span> <span class="string">&quot;flutter pub get&quot;</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">pub</span> <span class="string">get</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">build_all:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">dart</span> <span class="string">pub</span> <span class="string">global</span> <span class="string">run</span> <span class="string">melos</span> <span class="string">exec</span> <span class="string">--depends-on=&quot;build_runner&quot;</span> <span class="string">&quot;flutter packages pub run build_runner build --delete-conflicting-outputs&quot;</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">build_runner</span> <span class="string">build</span> <span class="string">all</span> <span class="string">modules.</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">build_app:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">dart</span> <span class="string">pub</span> <span class="string">global</span> <span class="string">run</span> <span class="string">melos</span> <span class="string">exec</span> <span class="string">--fail-fast</span> <span class="string">--scope=&quot;*app*&quot;</span> <span class="string">--depends-on=&quot;build_runner&quot;</span> <span class="string">&quot;flutter packages pub run build_runner build --delete-conflicting-outputs&quot;</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">build_runner</span> <span class="string">build</span> <span class="string">app</span> <span class="string">module.</span></span><br></pre></td></tr></table></figure><p>第三步：在当前目录下运行指令：<code>melos bootstrap</code>。<br>第四步：来到主工程 <code>app</code> 的配置文件 <code>pubspec.yaml</code> 添加一下依赖。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">jianyue_music_player</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">music</span> <span class="string">player</span> <span class="string">project</span> <span class="string">for</span> <span class="string">learning</span> <span class="string">flutter</span></span><br><span class="line"><span class="attr">publish_to:</span> <span class="string">&#x27;none&#x27;</span> <span class="comment"># Remove this line if you wish to publish to pub.dev</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span><span class="string">+1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">&#x27;&gt;=2.19.1 &lt;3.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">cupertino_icons:</span> <span class="string">^1.0.2</span></span><br><span class="line">  <span class="attr">injectable:</span></span><br><span class="line">  <span class="attr">get_it:</span></span><br><span class="line">  <span class="attr">flutter_bloc:</span> <span class="number">8.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">freezed_annotation:</span> <span class="number">2.2</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">flutter_screenutil:</span> <span class="number">5.5</span><span class="number">.3</span><span class="string">+2</span></span><br><span class="line">  <span class="attr">auto_route:</span> <span class="number">7.8</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="attr">flutter_test:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">flutter_lints:</span> <span class="string">^2.0.0</span></span><br><span class="line">  <span class="attr">injectable_generator:</span> <span class="string">^2.1.4</span></span><br><span class="line">  <span class="attr">build_runner:</span> <span class="number">2.3</span><span class="number">.3</span></span><br><span class="line">  <span class="attr">freezed:</span> <span class="number">2.3</span><span class="number">.2</span></span><br><span class="line">  <span class="attr">auto_route_generator:</span> <span class="number">7.3</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flutter:</span></span><br><span class="line">  <span class="attr">uses-material-design:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">assets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/</span></span><br></pre></td></tr></table></figure><p>介绍一下上面配置文件中用到的第三方依赖库：</p><ul><li><code>injectable</code> 和 <code>injectable_generator</code>  ：依赖注入。</li><li><code>freezed_annotation</code> 和 <code>freezed</code> ：代码生成库，用来生成不可变（<code>immutable</code>）数据类和可复制（<code>copyable</code>）数据类，通常和 <code>flutter_bloc</code> 配合做状态更新时使用。</li><li><code>flutter_screenutil</code>：屏幕适配工具</li><li><code>auto_route</code> 和 <code>auto_route_generator</code>：路由管理工具。</li><li><code>get_it</code>：依赖管理。</li><li><code>flutter_bloc</code>：状态管理。</li><li><code>build_runner</code>：用于执行代码生成器，通过读取注解并生成相应的代码文件。如 <code>auto_route</code>：可以根据路由配置文件自动生成路由代码。</li></ul><p>关于 <code>melos</code> 的使用可以看看我之前的文章《Flutter大型项目架构：分层设计篇》，那里有更加详细的介绍。</p><h2 id="通用父类设计"><a href="#通用父类设计" class="headerlink" title="通用父类设计"></a>通用父类设计</h2><p>一个大型的项目在设计类似 <code>state</code> 这种全局父类的时候，往往考虑的情况是非常多的，但在实际编写代码的时候却要很谨慎克制，特别是在设计通用功能的时候，设计之初是为了给它的其子类提供一些通用的功能或属性，但如果没处理好会造成继承关系的混乱，代码之间的依赖关系更加复杂，代码的结构变得不清晰。</p><h3 id="自定义-State-父类"><a href="#自定义-State-父类" class="headerlink" title="自定义 State 父类"></a>自定义 <code>State</code> 父类</h3><p>在 <code>Flutter</code> 项目中，<code>State</code>  是表示用户界面的可变状态的对象，它可以随着用户交互、数据更新或其他事件的发生而变化。<code>State</code> 对象是与特定的 <code>Widget</code> 实例相关联的，且每个 <code>StatefulWidget</code> 都有一个对应的 <code>State</code> 对象。所以在自定义 <code>State</code> 父类需要考虑一下几个方面：</p><ul><li>状态管理对象，比如说这个项目里用的是 <code>bloc</code> 作为状态管理，如果在每个页面的 <code>state</code> 中都去手动创建这个 <code>bloc</code> 状态管理对象是不是很麻烦。而且还有所有的页面对应的 <code>bloc</code> 都需要一个导航器，因为很多时候我们需要在 <code>bloc</code> 中处理完业务逻辑之后做页面跳转。还有全局的状态管理对象，页面对应的 <code>bloc</code> 中也会读取或者更新全局的状态。</li><li>统一的导航器，这个就很好理解了，因为大多数情况下都需在页面的 <code>state</code> 做跳转。</li><li>常见对象的销毁，如：<code>StreamSubscription</code>、<code>StreamController</code>、<code>ChangeNotifier</code> 等等对象，在自定义的 <code>State</code> 父类中重写的父类的 <code>dispose</code> 函数中统一销毁，避免忘记在子页面 <code>dispose</code> 这些对象而造成内存泄露。</li></ul><p>下面是自定义 <code>State</code> 父类的实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的 State 基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePageState</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>,</span></span><br><span class="line"><span class="class">    <span class="title">B</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">T</span>&gt; <span class="title">with</span> <span class="title">LogMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 导航器对象</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> AppNavigator navigator = GetIt.instance.<span class="keyword">get</span>&lt;AppNavigator&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入口的 widget 的 bloc，也是全局的 bloc，负责全局的状态刷新，如切换主题、语言等。</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> AppBloc appBloc = GetIt.instance.<span class="keyword">get</span>&lt;AppBloc&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通用的 bloc，主要负责如处理异常、全局的loading的显示和隐藏等等</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> CommonBloc commonBloc = GetIt.instance.<span class="keyword">get</span>&lt;CommonBloc&gt;()</span><br><span class="line">    ..navigator = navigator</span><br><span class="line">    ..disposeBag = disposeBag</span><br><span class="line">    ..appBloc = appBloc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回当前的页面的 bloc 对象。同时将导航器、全局状态、</span></span><br><span class="line">  <span class="comment">// 通用的 bloc 等传给当前的页面的 bloc 对象</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> B bloc = GetIt.instance.<span class="keyword">get</span>&lt;B&gt;()</span><br><span class="line">    ..navigator = navigator</span><br><span class="line">    ..disposeBag = disposeBag</span><br><span class="line">    ..appBloc = appBloc</span><br><span class="line">    ..commonBloc = commonBloc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常见对象的销毁管理</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> DisposeBag disposeBag = DisposeBag();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isAppWidget =&gt; <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiBlocProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        <span class="comment">// 将 bloc，commonBloc 注册到当前页面</span></span><br><span class="line">        BlocProvider(create: (_) =&gt; bloc),</span><br><span class="line">        BlocProvider(create: (_) =&gt; commonBloc),</span><br><span class="line">      ],</span><br><span class="line">      child: BlocListener&lt;CommonBloc, CommonState&gt;(</span><br><span class="line">        <span class="comment">// 监听全局是否有异常。</span></span><br><span class="line">        listenWhen: (previous, current) =&gt;</span><br><span class="line">            (previous.appExceptionWrapper != current.appExceptionWrapper &amp;&amp;</span><br><span class="line">                current.appExceptionWrapper != <span class="keyword">null</span>),</span><br><span class="line">        listener: (context, state) &#123;&#125;,</span><br><span class="line">        child: buildPageListeners(</span><br><span class="line">          <span class="comment">// 这里的 isAppWidget 的意思是当入口的widget，也就是 MyApp 加载完进入程序主页，</span></span><br><span class="line">          <span class="comment">// 在全局加上 Loading，根据需要来显示或隐藏</span></span><br><span class="line">          child: isAppWidget</span><br><span class="line">              ? buildPage(context)</span><br><span class="line">              : Stack(</span><br><span class="line">                  children: [</span><br><span class="line">                    buildPage(context),</span><br><span class="line">                    BlocBuilder&lt;CommonBloc, CommonState&gt;(</span><br><span class="line">                      buildWhen: (previous, current) =&gt;</span><br><span class="line">                          previous.isLoading != current.isLoading,</span><br><span class="line">                      builder: (context, state) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Visibility(</span><br><span class="line">                          visible: state.isLoading,</span><br><span class="line">                          child: buildPageLoading(),</span><br><span class="line">                        );</span><br><span class="line">                      &#125;,</span><br><span class="line">                    ),</span><br><span class="line">                  ],</span><br><span class="line">                ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 页面监听器，后面会讲到。</span></span><br><span class="line">  Widget buildPageListeners(&#123;<span class="keyword">required</span> Widget child&#125;) =&gt; child;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局的 loading</span></span><br><span class="line">  Widget buildPageLoading() =&gt; <span class="keyword">const</span> Center(</span><br><span class="line">        child: CircularProgressIndicator(</span><br><span class="line">          color: Color(<span class="number">0xFF333333</span>),</span><br><span class="line">          strokeWidth: <span class="number">2</span>,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类重写改方法返回当前页面</span></span><br><span class="line">  Widget buildPage(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="comment">// 销毁常见对象，如StreamSubscription、StreamController、ChangeNotifier等</span></span><br><span class="line">    disposeBag.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义-Bloc-父类"><a href="#自定义-Bloc-父类" class="headerlink" title="自定义 Bloc 父类"></a>自定义 <code>Bloc</code> 父类</h3><p>上面代码中的泛型类型 <code>B</code> 继承自 <code>BaseBloc</code>，而 <code>BaseBloc</code> 的父类是 <code>Bloc</code>，<code>BaseBloc</code> 是项目中所有用到的 <code>bloc</code> 的父类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBloc</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">BaseBlocEvent</span>, <span class="title">S</span> <span class="keyword">extends</span> <span class="title">BaseBlocState</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">BaseBlocDelegate</span>&lt;<span class="title">E</span>, <span class="title">S</span>&gt; <span class="title">with</span> <span class="title">EventTransformerMixin</span>, <span class="title">LogMixin</span> </span>&#123;</span><br><span class="line">  BaseBloc(S initialState) : <span class="keyword">super</span>(initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBlocDelegate</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">BaseBlocEvent</span>,</span></span><br><span class="line"><span class="class">    <span class="title">S</span> <span class="keyword">extends</span> <span class="title">BaseBlocState</span>&gt; <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">E</span>, <span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法中传一个泛型为S类型的对象</span></span><br><span class="line">  BaseBlocDelegate(S initialState) : <span class="keyword">super</span>(initialState);</span><br><span class="line">  <span class="comment">// 导航器，在 base_page_state 赋值其子类</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> AppNavigator navigator;</span><br><span class="line">  <span class="comment">// 全局状态管理对象</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> AppBloc appBloc;</span><br><span class="line">  <span class="comment">// 常见对象销毁管理器，在 base_page_state 赋值其子类</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> DisposeBag disposeBag;</span><br><span class="line">  <span class="comment">// 通用的状态管理对象，在 base_page_state 赋值其子类</span></span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> CommonBloc _commonBloc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> commonBloc(CommonBloc commonBloc) &#123;</span><br><span class="line">    _commonBloc = commonBloc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CommonBloc <span class="keyword">get</span> commonBloc =&gt;</span><br><span class="line">      <span class="keyword">this</span> <span class="keyword">is</span> CommonBloc ? <span class="keyword">this</span> <span class="keyword">as</span> CommonBloc : _commonBloc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写 Bloc 的 add 函数，只有没有 closed 的情况下才添加 event。</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> add(E event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isClosed) &#123;</span><br><span class="line">      <span class="keyword">super</span>.add(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Log.e(<span class="string">&#x27;Cannot add new event <span class="subst">$event</span> because <span class="subst">$runtimeType</span> was closed&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加异常对象，会触发 base_page_state 中异常监听器来处理异常。</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; addException(AppExceptionWrapper appExceptionWrapper) <span class="keyword">async</span> &#123;</span><br><span class="line">    commonBloc.add(ExceptionEmitted(</span><br><span class="line">      appExceptionWrapper: appExceptionWrapper,</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> appExceptionWrapper.exceptionCompleter?.future;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// loading 显示</span></span><br><span class="line">  <span class="keyword">void</span> showLoading() &#123;</span><br><span class="line">    commonBloc.add(<span class="keyword">const</span> LoadingVisibilityEmitted(isLoading: <span class="keyword">true</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// loading 隐藏</span></span><br><span class="line">  <span class="keyword">void</span> hideLoading() &#123;</span><br><span class="line">    commonBloc.add(<span class="keyword">const</span> LoadingVisibilityEmitted(isLoading: <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的自定义的父类 <code>BaseBloc</code> 的构造函数需要传入泛型类型 <code>S</code>，<code>S</code> 继承自抽象类 <code>BaseBlocState</code>，<code>BaseBlocState</code> 是作为整个项目的 <code>BlocState</code> 的状态基类。</p><p>这里的 <code>EventTransformerMixin</code> 是事件处理转换器，通常用于在业务逻辑组件中对事件进行一些预处理或后处理操作，其常用操作有 <code>distinct</code>： 如果当前 <code>event</code>  等于前一个 <code>event</code> ，就会直接跳过当前 <code>event</code>；<code>exhaustMap</code>：如果前一个 <code>event</code> 没有完成，新的 <code>event</code> 就会被忽略；<code>throttleTime</code> 在一段时间内忽略后续事件，然后重复此过程 等等。</p><h2 id="项目入口的-Widget"><a href="#项目入口的-Widget" class="headerlink" title="项目入口的 Widget"></a>项目入口的 <code>Widget</code></h2><p>这里可以看到 <code>_MyAppState</code> 继承自上面代码中的 <code>BasePageState</code> 类，并将泛型 <code>T</code> 指定为 <code>MyApp</code>，将泛型 <code>B</code> 指定为 <code>AppBloc</code>，而 <code>AppBloc</code> 的对象赋值过程是在父类 <code>BasePageState</code>  完成的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;MyApp&gt; createState() =&gt; _MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppState</span> <span class="keyword">extends</span> <span class="title">BasePageState</span>&lt;<span class="title">MyApp</span>, <span class="title">AppBloc</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 获取路由对象</span></span><br><span class="line">  <span class="keyword">final</span> _appRouter = GetIt.instance.<span class="keyword">get</span>&lt;AppRouter&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isAppWidget =&gt; <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 添加初始化 event 对象</span></span><br><span class="line">    bloc.add(<span class="keyword">const</span> AppInitEvent());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildPage(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ScreenUtilInit(</span><br><span class="line">      <span class="comment">// 设置当前 App 的设计尺寸。</span></span><br><span class="line">      designSize: <span class="keyword">const</span> Size(DeviceWindowConstants.designWebWidth,</span><br><span class="line">          DeviceWindowConstants.designWebHeight),</span><br><span class="line">      builder: (context, _) =&gt; BlocBuilder&lt;AppBloc, AppState&gt;(</span><br><span class="line">        <span class="comment">// 当语言或者主题发生变化时重绘整个 App</span></span><br><span class="line">        buildWhen: (previous, current) =&gt;</span><br><span class="line">            previous.isDarkTheme != current.isDarkTheme ||</span><br><span class="line">            previous.languageCode != current.languageCode,</span><br><span class="line">        builder: (context, state) &#123;</span><br><span class="line">          <span class="keyword">return</span> MaterialApp.router(</span><br><span class="line">            useInheritedMediaQuery: <span class="keyword">true</span>,</span><br><span class="line">            builder: (context, child) &#123;</span><br><span class="line">              <span class="keyword">final</span> MediaQueryData data = MediaQuery.of(context);</span><br><span class="line">              <span class="keyword">return</span> MediaQuery(</span><br><span class="line">                <span class="comment">// 固定文本的缩放，使文本大小保持一致</span></span><br><span class="line">                data: data.copyWith(textScaleFactor: <span class="number">1.0</span>),</span><br><span class="line">                child: child ?? <span class="keyword">const</span> SizedBox.shrink(),</span><br><span class="line">              );</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 设置路由委托对象，负责管理 App 的路由状态</span></span><br><span class="line">            routerDelegate: _appRouter.delegate(</span><br><span class="line">              deepLinkBuilder: (deepLink) &#123;</span><br><span class="line">                <span class="keyword">return</span> DeepLink.defaultPath;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="comment">// 设置路由监听器。</span></span><br><span class="line">              navigatorObservers: () =&gt; [AppNavigatorObserver()],</span><br><span class="line">            ),</span><br><span class="line">            <span class="comment">// 路由解析器。</span></span><br><span class="line">            routeInformationParser: _appRouter.defaultRouteParser(),</span><br><span class="line">            title: <span class="string">&quot;简悦&quot;</span>,</span><br><span class="line">            themeMode: state.isDarkTheme ? ThemeMode.dark : ThemeMode.light,</span><br><span class="line">            debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里也许会有同学觉得很奇怪，在父类 <code>BasePageState</code> 已经有了 <code>appBloc</code>，这里通过继承 <code>BasePageState</code> 又创建一个 <code>bloc</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">late</span> <span class="keyword">final</span> AppBloc appBloc = GetIt.instance.<span class="keyword">get</span>&lt;AppBloc&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">late</span> <span class="keyword">final</span> B bloc = GetIt.instance.<span class="keyword">get</span>&lt;B&gt;()</span><br><span class="line">  ..navigator = navigator</span><br><span class="line">  ..disposeBag = disposeBag</span><br><span class="line">  ..appBloc = appBloc</span><br><span class="line">  ..commonBloc = commonBloc;</span><br></pre></td></tr></table></figure><p>此时 <code>appBloc</code> 和 <code>bloc</code> 难道不是同一个东西吗？会不会有什么问题？它们的确是同一个东西，因为类 <code>AppBloc</code> 在注入的时候是 <code>@LazySingleton()</code> 延迟加载的单例对象。<code>appBloc</code> 是作为全局的状态管理对象，负责全局的状态更新，其实现代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LazySingleton</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span>&lt;<span class="title">AppEvent</span>, <span class="title">AppState</span>&gt; </span>&#123;</span><br><span class="line">  AppBloc() : <span class="keyword">super</span>(<span class="keyword">const</span> AppState()) &#123;</span><br><span class="line">    <span class="keyword">on</span>&lt;AppThemeChanged&gt;(</span><br><span class="line">      _onAppThemeChanged,</span><br><span class="line">      transformer: throttleTime(),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">on</span>&lt;AppLanguageChanged&gt;(</span><br><span class="line">      _onAppLanguageChanged,</span><br><span class="line">      transformer: log(),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">on</span>&lt;AppInitEvent&gt;(_onAppInitEvent, transformer: log());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// app 初始化 event</span></span><br><span class="line">  FutureOr&lt;<span class="keyword">void</span>&gt; _onAppInitEvent(</span><br><span class="line">      AppInitEvent event, Emitter&lt;AppState&gt; emit) <span class="keyword">async</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主题改变的 event</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _onAppThemeChanged(</span><br><span class="line">      AppThemeChanged event, Emitter&lt;AppState&gt; emit) <span class="keyword">async</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 语言切换的 event</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _onAppLanguageChanged(</span><br><span class="line">      AppLanguageChanged event, Emitter&lt;AppState&gt; emit) <span class="keyword">async</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看到 <code>AppBloc</code> 继承自 <code>BaseBloc</code>，同时指定了 <code>event</code> 和 <code>state</code> 类，调用父类的构造函数时将 <code>AppState</code> 的对象作为参数传入，而 <code>AppState</code> 是继承自 <code>BaseBlocState</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>是不是感觉讲了半天到现在还没开始写页面，别着急哈，这次音乐播放器项目重点讲的是以大型项目架构的角度来实现的，前期的各种准备工作如父类、全局的状态管理还有后面的路由管理都是需要在项目开始的时候做好基本的规划设计，而不只是调接口画页面。这里是挑重要的几个类讲的，有的不够全面，建议大家看源码，关注公众号回复 <strong>简悦</strong> 将源码链接发给您，今天就分享到这里，后续还会有更多更新，您的关注是我更新下去最大的动力。</p><p><img src="https://s2.loli.net/2022/11/09/fNBn2gWw8tVazkr.jpg" alt="Flutter技术实践"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/04/28/INhvlyAbFKJo6st.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;前面谈到了怎么用 &lt;code&gt;flutter_bloc&lt;/code&gt; 来做状态管理的、&lt;code&gt;Flutter&lt;/code&gt; 项目架构是怎样分层的、各个分层之间又是如何依赖的，以及写界面用到的 &lt;code&gt;widget&lt;/code&gt; 是如何设计封装实现的。这些是从一个成熟 &lt;code&gt;Flutter&lt;/code&gt; 大型项目的不同角度来讨论的，很多人会觉得偏向于理论片面，或者说是很多实现的细节没有讲到，本篇将从零开始实现一个音乐播放器，也是将前面讲到的落地到真实的项目实践中去检验，看看会不会遇到什么问题，以及怎样去解决这些问题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter大型项目架构：UI设计系统实现（二）</title>
    <link href="http://www.nnxkcloud.com/2024/04/26/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9AUI%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.nnxkcloud.com/2024/04/26/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9AUI%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-04-26T03:00:35.000Z</published>
    <updated>2024-10-15T03:05:34.689Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/04/26/lFsxrMQ8ojuPk4G.png"></p><p><a href="https://www.nnxkcloud.com/2024/04/21/flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9Aui%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/">上一篇</a> 介绍了 <code>UI</code> 设计系统实现中的原子级别如 <code>color</code>、<code>font</code>、<code>padding</code>、<code>radius</code> 等的管理方式，本篇主要来介绍设计系统中分子级别和细胞级别，也就是一些最基本和常见的 <code>widget</code>  和自定义的 <code>widget</code> 。它们在整个项目大量重复的去使用，来看看它们在 <code>UI</code> 设计系统是如何封装的呢。</p><span id="more"></span><p>我们在写 <code>UI</code> 界面的时候，经常会遇到很多 <code>widget</code> 它们长得很像，却又有一些细微的差别，比如说在很多页面都会出现的操作 <code>button</code>，有提交表单数据 <code>primary button</code>，也有其它交互的操作的 <code>secondary button</code> 等等，但是这些按钮之间只有背景颜色、显示文案及用户点击的回调的区别。</p><p>这个时候应该怎么做呢？先来说一说前三种做法，第一种在页面上每一个用到按钮的位置直接使用，第二种就是为每种按钮类型创建一个小的 <code>Widget</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种做法</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">      backgroundColor: <span class="keyword">const</span> Color(<span class="number">0xffffffff</span>),</span><br><span class="line">      body: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">        children: [</span><br><span class="line">          TextButton(</span><br><span class="line">            child: <span class="keyword">const</span> Text(<span class="string">&#x27;Primary Button&#x27;</span>),</span><br><span class="line">            onPressed: () &#123;&#125;,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      )));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种做法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenteredTextButton1</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span>() onPressed;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isEnabled;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> CenteredTextButton1(</span><br><span class="line">      &#123;Key? key, <span class="keyword">required</span> <span class="keyword">this</span>.onPressed, <span class="keyword">required</span> <span class="keyword">this</span>.isEnabled&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextButton(</span><br><span class="line">      onPressed: onPressed,</span><br><span class="line">      child: Container(</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          height: <span class="number">45</span>,</span><br><span class="line">          width: <span class="number">160</span>,</span><br><span class="line">          decoration: BoxDecoration(</span><br><span class="line">              borderRadius: <span class="keyword">const</span> BorderRadius.all(Radius.circular(<span class="number">4</span>)),</span><br><span class="line">              border: Border.all(color: Colors.white38),</span><br><span class="line">              color: isEnabled</span><br><span class="line">                  ? <span class="keyword">const</span> Color(<span class="number">0xF80231E5</span>)</span><br><span class="line">                  : <span class="keyword">const</span> Color(<span class="number">0xFF7F7F7F</span>)),</span><br><span class="line">          child: <span class="keyword">const</span> Text(<span class="string">&quot;Primary Button&quot;</span>)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种就是在第二种的基础上将抽取一个父类，将相同属性和操作放在父类，不同的放在子类，但是不太推荐这么做，至少是在这种情况下不推荐，本来就是一个简单的 <code>widget</code> 的封装，搞个父类会让 <code>widget</code> 的维护变复杂了。而第一种和第二种做法也可以，但在整个项目中会有大量重复代码，代码重用性不好，有没有更好的做法呢？这里使用的是 <code>widget</code> 工厂。</p><h2 id="widget-工厂"><a href="#widget-工厂" class="headerlink" title="widget 工厂"></a><code>widget</code> 工厂</h2><p>这里同样以文案居中的 <code>button</code> 为例，下面来创建一个类名为 <code>CenteredTextButton</code> 的自定义<code>button</code> 组件，它包含了两个工厂方法：<code>primary</code> 和 <code>secondary</code>，分别用于创建两个不同样式的按钮。每个工厂方法内部通过调用 <code>CenteredTextButton._internal </code> 构造函数来创建按钮实例，并根据传入的参数设置按钮的样式和行为。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenteredTextButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> label;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isPrimary;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isEnabled;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span>() onPressed;</span><br><span class="line">  <span class="keyword">final</span> Color color;</span><br><span class="line">  <span class="keyword">final</span> Color disabledColor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> CenteredTextButton._internal(&#123;</span><br><span class="line">    <span class="keyword">super</span>.key,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.label,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.isPrimary,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.isEnabled,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.onPressed,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.disabledColor,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> CenteredTextButton.primary(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> label,</span><br><span class="line">    <span class="built_in">bool</span> isEnabled = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">Function</span>() onTap,</span><br><span class="line">    <span class="keyword">required</span> BuildContext context,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> CenteredTextButton._internal(</span><br><span class="line">      key: key,</span><br><span class="line">      label: label,</span><br><span class="line">      isPrimary: <span class="keyword">true</span>,</span><br><span class="line">      isEnabled: isEnabled,</span><br><span class="line">      onPressed: onTap,</span><br><span class="line">      color: Theme.of(context).appColors.buttonPrimaryBgColor,</span><br><span class="line">      disabledColor: Theme.of(context).appColors.buttonDisabledBgColor,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> CenteredTextButton.secondary(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> label,</span><br><span class="line">    <span class="built_in">bool</span> isEnabled = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">Function</span>() onTap,</span><br><span class="line">    <span class="keyword">required</span> BuildContext context,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> CenteredTextButton._internal(</span><br><span class="line">      key: key,</span><br><span class="line">      label: label,</span><br><span class="line">      isPrimary: <span class="keyword">false</span>,</span><br><span class="line">      isEnabled: isEnabled,</span><br><span class="line">      onPressed: onTap,</span><br><span class="line">      color: Theme.of(context).appColors.buttonSecondaryBgColor,</span><br><span class="line">      disabledColor: Theme.of(context).appColors.buttonDisabledBgColor,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> InkWell(</span><br><span class="line">      splashFactory: NoSplash.splashFactory,</span><br><span class="line">      highlightColor: Colors.white.withOpacity(<span class="number">0</span>),</span><br><span class="line">      onTap: isEnabled ? onPressed : <span class="keyword">null</span>,</span><br><span class="line">      child: Container(</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          height: <span class="number">45</span>,</span><br><span class="line">          width: <span class="number">160</span>,</span><br><span class="line">          decoration: BoxDecoration(</span><br><span class="line">              borderRadius: <span class="keyword">const</span> BorderRadius.all(Radius.circular(<span class="number">4</span>)),</span><br><span class="line">              color: color),</span><br><span class="line">          child: Text(</span><br><span class="line">            label,</span><br><span class="line">            style: Theme.of(context).appTexts.labelTextDefault.copyWith(</span><br><span class="line">                color: Theme.of(context).appColors.centeredButtonTextColor),</span><br><span class="line">          )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是的颜色和文本样式的定义放在了是上一篇介绍的 <code>AppColorsTheme</code> 和 <code>AppTextsTheme</code>。使用的定制性更高的 <code>InkWell</code> 来作为响应用户点击的容器组件，<code>NoSplash.splashFactory</code> 去掉点击时的水波纹效果。在页面中使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Column(</span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">  children: [</span><br><span class="line">    CenteredTextButton.primary(</span><br><span class="line">        label: <span class="string">&quot;Primary Button&quot;</span>, onTap: () &#123;&#125;, context: context),</span><br><span class="line">    <span class="keyword">const</span> SizedBox(</span><br><span class="line">      height: <span class="number">20</span>,</span><br><span class="line">    ),</span><br><span class="line">    CenteredTextButton.secondary(</span><br><span class="line">        label: <span class="string">&quot;Secondary Button&quot;</span>, onTap: () &#123;&#125;, context: context)</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>每个工厂中仅添加必要的参数，使得代码更简单并避免代码重复，那这样实现有什么好处呢？将每个工厂中的通用属性分组，不必每次在应用程序中需要相同的小 <code>widget</code> 时重复这些通用属性，管理起来也方便统一。而且这样写也很方便拓展更多的小 <code>widget</code> ，只需要添加一个新工厂就可以轻松添加新的小部件，如：<code>CenteredTextButton.tertiary</code> 也可以有自己的特定参数值。</p><p>除了上面的 <code>button</code>，还有没有其它的 <code>widget</code> 也可以这么设计呢？当然有，而且很多，比如文本、文本输入和图片等等，甚至 <code>widget</code> 之间的间隙（<code>gap</code>），都可以使用上述做法来设计。</p><p>文本显示：</p><ul><li><code>AppText.labelLargeEmphasis(...)</code></li><li><code>AppText.labelDefaultEmphasis(...)</code></li></ul><p>文本输入：</p><ul><li><code>AppTextField.text()</code></li><li><code>AppTextField.search()</code></li><li><code>AppTextField.number()</code></li><li><code>AppTextField.email()</code></li><li><code>AppTextField.password()</code></li></ul><p>你可能会问 <code>widget</code> 之间的间隙不是可以通过 <code>padding</code>、<code>margin</code> 来实现吗，还需要单独重新设计一系列的 <code>gap</code> ？我自己的经验是，所有的 <code>widget</code> 之间的间隙尽量是可见的，意思就是单独把间隙用 <code>SizedBox</code> 来表示，尽量避免子小部件内隐藏的间隙和间距，除非是特殊情况必须得这么做。下面代码实现封装的各种 <code>gap</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerticalGap</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> height;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> VerticalGap._internal(&#123;</span><br><span class="line">    <span class="keyword">super</span>.key,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.height,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> VerticalGap.formHuge(&#123;Key? key&#125;) =&gt;</span><br><span class="line">      VerticalGap._internal(key: key, height: <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> VerticalGap.formBig(&#123;Key? key&#125;) =&gt;</span><br><span class="line">      VerticalGap._internal(key: key, height: <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> VerticalGap.formMedium(&#123;Key? key&#125;) =&gt;</span><br><span class="line">      VerticalGap._internal(key: key, height: <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> VerticalGap.formSmall(&#123;Key? key&#125;) =&gt;</span><br><span class="line">      VerticalGap._internal(key: key, height: <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> VerticalGap.formTiny(&#123;Key? key&#125;) =&gt;</span><br><span class="line">      VerticalGap._internal(key: key, height: <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有时候需要将 height 传入</span></span><br><span class="line">  <span class="keyword">factory</span> VerticalGap.custom(<span class="built_in">double</span> height, &#123;Key? key&#125;) =&gt;</span><br><span class="line">      VerticalGap._internal(key: key, height: height);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; SizedBox(height: height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="widget-组合"><a href="#widget-组合" class="headerlink" title="widget 组合"></a><code>widget</code> 组合</h2><p>这个就很好理解了，就是将多个基础 <code>widget</code> 组合成一个复合 <code>widget</code>，从而实现更复杂的功能或UI布，这里的参与组合的 <code>widget</code> 既有系统的也有上面内容里自定义的 <code>widget</code>，所以组合的 <code>widget</code> 在设计系统中可以属于分子级别也可以是细胞级别。下面来实现一个自定义 <code>AppBar</code> 的例子 ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:widgets/button/app_bar_button.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomAppBar</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> <span class="keyword">implements</span> <span class="title">PreferredSizeWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> IconData leadingIcon;</span><br><span class="line">  <span class="keyword">final</span> VoidCallback onLeadingPressed;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt;? actions;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> CustomAppBar(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.leadingIcon,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.onLeadingPressed,</span><br><span class="line">    <span class="keyword">this</span>.actions,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> AppBar(</span><br><span class="line">      title: Text(title),</span><br><span class="line">      leading: AppBarButton.leading(</span><br><span class="line">        text: <span class="string">&quot;Back&quot;</span>,</span><br><span class="line">        onTap: onLeadingPressed,</span><br><span class="line">      ),</span><br><span class="line">      actions: actions,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Size <span class="keyword">get</span> preferredSize =&gt; <span class="keyword">const</span> Size.fromHeight(kToolbarHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的 <code>AppBarButton</code> 就是我们自己的封装的 <code>widget</code> ，<code>CustomAppBar</code> 组件内部使用了 <code>AppBar</code> 和一些内置的 <code>Widget</code>（如 <code>Text</code> ）还有我们自定义的，来实现的布局和样式。这种 <code>widget</code> 的组合封装小到一个 <code>AppBar</code>，有些情况下也可以大到一个页面。好处就是在应用中重复使用这个自定义的组合 <code>widget</code>，而不需要重复编写相似的代码，提高了代码的复用性和可维护性。</p><h2 id="widget-自定义绘制"><a href="#widget-自定义绘制" class="headerlink" title="widget 自定义绘制"></a><code>widget</code> 自定义绘制</h2><p>自定义绘制是属于设计系统中细胞级别的，项目中我们常使用 <code>CustomPainter</code> 来做自定义绘制，因为有的时候 <code>Flutter</code> 内置组件无法满足特定设计需求，亦或者在需要绘制复杂图形、图表及各种特殊的效果、动画等场景下，同时自定义绘制可以实现更高效的渲染，尤其是绘制大量图形或动画时，可以减少 <code>Flutter</code> 框架的开销，提高性能。下面用 <code>CustomPainter</code> 绘制一个不规则形状的按钮。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IrregularButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> width;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> height;</span><br><span class="line">  <span class="keyword">final</span> Color color;</span><br><span class="line">  <span class="keyword">final</span> VoidCallback onPressed;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> IrregularButton(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.width,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.height,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.onPressed,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      onTap: onPressed,</span><br><span class="line">      child: CustomPaint(</span><br><span class="line">        size: Size(width, height),</span><br><span class="line">        painter: _IrregularButtonPainter(color),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IrregularButtonPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  _IrregularButtonPainter(<span class="keyword">this</span>.color);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    <span class="keyword">final</span> Paint paint = Paint()..color = color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Path path = Path()</span><br><span class="line">      ..moveTo(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">      ..lineTo(size.width, <span class="number">0</span>)</span><br><span class="line">      ..lineTo(size.width * <span class="number">0.8</span>, size.height)</span><br><span class="line">      ..lineTo(<span class="number">0</span>, size.height * <span class="number">0.6</span>)</span><br><span class="line">      ..close();</span><br><span class="line"></span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRepaint(<span class="keyword">covariant</span> CustomPainter oldDelegate) =&gt; <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在项目架构中的位置"><a href="#在项目架构中的位置" class="headerlink" title="在项目架构中的位置"></a>在项目架构中的位置</h2><p><img src="https://s2.loli.net/2024/04/25/J3C1ZhmoRF5Y8Qy.png"></p><p>从上面的架构图可以看出，上面介绍的通过工厂、组合和自定义绘制的<code>widget</code> （分子级别和细胞级别）是放在了 <code>widgets</code> 组件包内的，<code>widgets</code> 组件内部会依赖于 <code>resources</code> 组件和 <code>shared</code> 组件。在主工程中添加对 <code>widgets</code> 的依赖就可以直接使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">../resources</span></span><br></pre></td></tr></table></figure><p>下图是 <code>widgets</code>  组件内部的文件结构：</p><p><img src="https://s2.loli.net/2024/04/25/KRqpAtXsa8cNwmH.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>UI</code> 设计系统除了在代码层的实现，还需要 <code>UI</code> 设计师定义一套 <code>UI</code> 组件的设计规范和风格来做配合，以确保界面的一致性和美观性。本文上面和上一篇介绍的 <code>widget</code> 封装方法只是提供一种参考。好了，今天的分享就到这里，《Flutter大型项目架构》系列已经更新到第五篇，本系列的下一篇来介绍大型项目中网络层是如何设计和实现的，感谢您的阅读，记得关注加点赞哦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/04/26/lFsxrMQ8ojuPk4G.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nnxkcloud.com/2024/04/21/flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9Aui%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/&quot;&gt;上一篇&lt;/a&gt; 介绍了 &lt;code&gt;UI&lt;/code&gt; 设计系统实现中的原子级别如 &lt;code&gt;color&lt;/code&gt;、&lt;code&gt;font&lt;/code&gt;、&lt;code&gt;padding&lt;/code&gt;、&lt;code&gt;radius&lt;/code&gt; 等的管理方式，本篇主要来介绍设计系统中分子级别和细胞级别，也就是一些最基本和常见的 &lt;code&gt;widget&lt;/code&gt;  和自定义的 &lt;code&gt;widget&lt;/code&gt; 。它们在整个项目大量重复的去使用，来看看它们在 &lt;code&gt;UI&lt;/code&gt; 设计系统是如何封装的呢。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Dart 语法原来这么好玩儿</title>
    <link href="http://www.nnxkcloud.com/2024/04/24/Dart-%E8%AF%AD%E6%B3%95%E5%8E%9F%E6%9D%A5%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9%E5%84%BF/"/>
    <id>http://www.nnxkcloud.com/2024/04/24/Dart-%E8%AF%AD%E6%B3%95%E5%8E%9F%E6%9D%A5%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9%E5%84%BF/</id>
    <published>2024-04-24T05:46:02.000Z</published>
    <updated>2024-10-15T03:05:34.687Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/04/24/owI1VJfX4ZtOcKY.png"></p><p>说到到某个语言的语法可能大家会觉得很枯燥、乏味，而日常开发中我们往往更加注重的是业务逻辑和页面开发，语法的使用大多也停留在满足基本的需求。其实 <code>Dart</code> 语法有很多有意思的地方的，仔细探究一下你会发现，它的简洁清晰、灵活多样的语法会让人爱不释手。在本文中，我们将探索 Dart 语法的各种奇妙之处吧。</p><span id="more"></span><h2 id="unwrap-操作"><a href="#unwrap-操作" class="headerlink" title="unwrap 操作"></a><code>unwrap</code> 操作</h2><p>在 <code>Flutter</code> 中，<code>unwrap</code> 操作常常用于处理可能为空的数据，以便过滤掉空值并只保留非空值。其使用场景也相当广泛，例如 为 <code>Future</code> 和 <code>Streams</code> 添加 <code>unwrap</code> 来处理掉非空数据，或者从网络请求或其他异步操作中获取数据，并在数据流中处理结果等等，如下面这段代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> Unwrap&lt;T&gt; <span class="keyword">on</span> Future&lt;T?&gt; &#123;</span><br><span class="line">  Future&lt;T&gt; unwrap() =&gt; then(</span><br><span class="line">        (value) =&gt; value != <span class="keyword">null</span></span><br><span class="line">        ? Future&lt;T&gt;.value(value)</span><br><span class="line">        : Future.any([]),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unwrap</code> 函数将可能为空的 <code>Future</code> 解包，如果 <code>Future</code> 返回的值不为 <code>null</code>，则将值包装在一个新的 <code>Future</code> 中返回，否则返回一个空的 <code>Future</code>。调用示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImagePickerHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImagePicker _imagePicker = ImagePicker();</span><br><span class="line">  <span class="keyword">static</span> Future&lt;File&gt; pickImageFromGallery() =&gt; _imagePicker</span><br><span class="line">      .pickImage(source: ImageSource.gallery)</span><br><span class="line">      .unwrap()</span><br><span class="line">      .then((xFile) =&gt; xFile.path)</span><br><span class="line">      .then((filePath) =&gt; File(filePath));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到图片选择器插件 <code>image_picker</code>，只有当返回的 <code>xFile</code> 不为空时才进行后续操作。如果不调用 <code>unwrap</code> 函数，此时这里返回的 <code>xFile</code> 为 <code>optional</code> 类型，要使用之前需要判断是否为 <code>null</code>。日常开发中这种情况还不少，给 <code>Future</code> 添加 <code>Unwrap</code> 函数之后这样非空判断集中在这一个函数里面处理。</p><p><code>unwrap</code> 不仅在 <code>Future</code> 中使用，还可以为 <code>Streams</code> 添加 <code>unwrap</code> 操作，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> Unwrap&lt;T&gt; <span class="keyword">on</span> Stream&lt;T?&gt; &#123;</span><br><span class="line">  Stream&lt;T&gt; unwrap() =&gt; where((event) =&gt; event != <span class="keyword">null</span>).cast();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>unwrap</code> 方法，通过 <code>where</code> 过滤掉了 <code>null</code> 的事件，并使用 <code>cast() </code> 方法将结果转换为 <code>Stream&lt;T&gt; </code> 类型，将可空的事件转换为非空的事件流，下面是调用代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  Stream&lt;<span class="built_in">int?</span>&gt;.periodic(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>),</span><br><span class="line">    (value) =&gt; value % <span class="number">2</span> == <span class="number">0</span> ? value : <span class="keyword">null</span>,</span><br><span class="line">  ).unwrap().listen((evenValue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(evenValue);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">    6</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>extension</code> 给 <code>Future</code> 和 <code>Streams</code> 添加 <code>unwrap</code> 函数后让我们的代码看起来清晰简洁多了，有没有？</p><h2 id="数组的展开、合并和过滤"><a href="#数组的展开、合并和过滤" class="headerlink" title="数组的展开、合并和过滤"></a>数组的展开、合并和过滤</h2><p>下面代码为任意类型的可迭代对象（<code>Iterable</code>）添加名为 <code>Flatten</code> 的扩展。在这个扩展中，函数 <code>flatten</code> 使用了递归算法将多层嵌套的 <code>Iterable</code> 里面的所有元素扁平化为单层 <code>Iterable</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> Flatten&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt; <span class="keyword">on</span> <span class="built_in">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="built_in">Iterable</span>&lt;T&gt; flatten() &#123;</span><br><span class="line">    <span class="built_in">Iterable</span>&lt;T&gt; _flatten(<span class="built_in">Iterable</span>&lt;T&gt; list) <span class="keyword">sync</span>* &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> value <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">is</span> <span class="built_in">List</span>&lt;T&gt;) &#123;</span><br><span class="line">          <span class="keyword">yield</span>* _flatten(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">yield</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _flatten(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意了上面代码中使用了 <code>yield</code> 关键字，在 <code>Flutter</code> 中，<code>yield</code> 关键字用于生成迭代器，通常与<code>sync*</code> 或 <code>async*</code> 一起使用。它允许您在处理某些数据时逐步生成数据，而不是在内存中一次性处理所有数据。对于处理大量数据或执行长时间运行的操作非常有用，因为它可以节省内存并提高性能。</p><p>这个和 <code>ES6</code> 中使用 <code>function*</code> 语法和 <code>yield</code> 关键字来生成值一个东西，也是逐个生成值，而不需要一次性生成所有值。以下是 <code>JS</code> 写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generateNumbers</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = <span class="title function_">generateNumbers</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> number <span class="keyword">of</span> numbers) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看 <code>Dart</code> 中的 <code>flatten()</code> 函数的调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> flat = [</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">6</span>, [<span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]], <span class="number">10</span>],</span><br><span class="line">    <span class="number">11</span>,<span class="number">12</span></span><br><span class="line">  ].flatten();</span><br><span class="line">  <span class="built_in">print</span>(flat); <span class="comment">// (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套的集合可能在数据处理、转换或展示中经常遇到，而将这些嵌套的集合扁平化可以简化数据处理过程，使代码更加简洁和易于理解。另外一点，递归展多维数组在面试中经常会出现，说不定哪天就用上了哈。</p><p>如果将两个数组合并成一个数组该怎么操作呢？其实和 <code>Map</code> 的合并相似，也是用到了自定义操作符 <code>operator</code> ，来看看怎么实现的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> InlineAdd&lt;T&gt; <span class="keyword">on</span> <span class="built_in">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="built_in">Iterable</span>&lt;T&gt; <span class="keyword">operator</span> +(T other) =&gt; followedBy([other]);</span><br><span class="line">  <span class="built_in">Iterable</span>&lt;T&gt; <span class="keyword">operator</span> &amp;(<span class="built_in">Iterable</span>&lt;T&gt; other) =&gt; followedBy(other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; values = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">  <span class="built_in">print</span>((values &amp; [<span class="number">40</span>, <span class="number">50</span>]));</span><br><span class="line">  <span class="comment">// 输出结果：(10, 20, 30, 40, 50)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了两个操作符：<code>+</code> 和 <code>&amp;</code>。将一个元素或者另一个可迭代对象添加到当前的可迭代对象中，然后返回一个新的可迭代对象，让可迭代对象 <code>terable</code> 有了合并数组的功能。</p><p>当数组中有一个为 <code>null</code> 的对象时，该如何过滤掉这个 <code>null</code> 对象呢，很简单可以这样做：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> CompactMap&lt;T&gt; <span class="keyword">on</span> <span class="built_in">Iterable</span>&lt;T?&gt; &#123;</span><br><span class="line">  <span class="built_in">Iterable</span>&lt;T&gt; compactMap&lt;E&gt;([</span><br><span class="line">    E? <span class="built_in">Function</span>(T?)? transform,</span><br><span class="line">  ]) =&gt;</span><br><span class="line">      map(transform ?? (e) =&gt; e).where((e) =&gt; e != <span class="keyword">null</span>).cast();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">const</span> list = [<span class="string">&#x27;Hello&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;World&#x27;</span>];</span><br><span class="line">  <span class="built_in">print</span>(list); <span class="comment">// [Hello, null, World]</span></span><br><span class="line">  <span class="built_in">print</span>(list.compactMap()); <span class="comment">// [Hello, World]</span></span><br><span class="line">  <span class="built_in">print</span>(list.compactMap((e) =&gt; e?.toUpperCase())); <span class="comment">// [HELLO, WORLD]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map-的过滤和合并"><a href="#Map-的过滤和合并" class="headerlink" title="Map 的过滤和合并"></a><code>Map</code> 的过滤和合并</h2><p>下面代码是 <code>Map</code> 类型的 <code>extension</code>，为 <code>Map</code> 类型添加了查找过滤的函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> DetailedWhere&lt;K, V&gt; <span class="keyword">on</span> <span class="built_in">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">  <span class="built_in">Map</span>&lt;K, V&gt; where(<span class="built_in">bool</span> <span class="built_in">Function</span>(K key, V value) f) =&gt; <span class="built_in">Map</span>&lt;K, V&gt;.fromEntries(</span><br><span class="line">        entries.where((entry) =&gt; f(entry.key, entry.value)),</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;K, V&gt; whereKey(<span class="built_in">bool</span> <span class="built_in">Function</span>(K key) f) =&gt;</span><br><span class="line">      &#123;...where((key, value) =&gt; f(key))&#125;;</span><br><span class="line">  <span class="built_in">Map</span>&lt;K, V&gt; whereValue(<span class="built_in">bool</span> <span class="built_in">Function</span>(V value) f) =&gt;</span><br><span class="line">      &#123;...where((key, value) =&gt; f(value))&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>where</code> : 接受一个函数作为参数，该函数接受 <code>Map</code> 的键和值作为参数，并返回一个布尔值。</li><li><code>whereKey</code> : 接受一个只接受键作为参数的函数。</li><li><code>whereValue</code> : 这个方法接受一个只接受值作为参数的函数。</li></ul><p>下面是调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; people = &#123;<span class="string">&#x27;John&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;Mary&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;Peter&#x27;</span>: <span class="number">22</span>&#125;;</span><br><span class="line">  <span class="built_in">print</span>(people.where((key, value) =&gt; key.length &gt; <span class="number">4</span> &amp;&amp; value &gt; <span class="number">20</span>)); <span class="comment">// &#123;Peter: 22&#125;</span></span><br><span class="line">  <span class="built_in">print</span>(people.whereKey((key) =&gt; key.length &lt; <span class="number">5</span>)); <span class="comment">// &#123;John: 20, Mary: 21&#125;</span></span><br><span class="line">  <span class="built_in">print</span>(people.whereValue((value) =&gt; value.isEven)); <span class="comment">// &#123;John: 20, Peter: 22&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>where</code> 方法先使用 <code>entries</code> 获取 <code>Map</code> 的键值对列表，然后使用 <code>entries.where</code> 方法对列表中的每个键值对进行过滤，最后使用 <code>fromEntries</code> 方法将过滤后的键值对列表转换回 <code>Map</code>，最后返回的新的 <code>Map</code> 中只包含满足条件的键值对，达到对 <code>Map</code> 中键值过滤的效果，也让代码更加简洁和易读。</p><p><code>Map</code> 过滤还有另外一种写法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> Filter&lt;K, V&gt; <span class="keyword">on</span> <span class="built_in">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">  <span class="built_in">Iterable</span>&lt;MapEntry&lt;K, V&gt;&gt; filter(</span><br><span class="line">    <span class="built_in">bool</span> <span class="built_in">Function</span>(MapEntry&lt;K, V&gt; entry) f,</span><br><span class="line">  ) <span class="keyword">sync</span>* &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> entry <span class="keyword">in</span> entries) &#123;</span><br><span class="line">      <span class="keyword">if</span> (f(entry)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> entry;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; people = &#123;</span><br><span class="line">    <span class="string">&#x27;foo&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;bar&#x27;</span>: <span class="number">31</span>,</span><br><span class="line">    <span class="string">&#x27;baz&#x27;</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="string">&#x27;qux&#x27;</span>: <span class="number">32</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">final</span> peopleOver30 = people.filter((e) =&gt; e.value &gt; <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">print</span>(peopleOver30); <span class="comment">// 输出结果：(MapEntry(bar: 31), MapEntry(qux: 32))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map</code>  其它一些更有趣的 <code>extension</code>，如 <code>Merge</code> 功能，将两个 <code>Map</code> 合并成一个，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> Merge&lt;K, V&gt; <span class="keyword">on</span> <span class="built_in">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">  <span class="built_in">Map</span>&lt;K, V&gt; <span class="keyword">operator</span> |(<span class="built_in">Map</span>&lt;K, V&gt; other) =&gt; &#123;...<span class="keyword">this</span>&#125;..addEntries(</span><br><span class="line">      other.entries,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用到了 <code>operator</code> 关键字，在 <code>Dart</code> 中，<code>operator</code> 关键字用于定义自定义操作符或者重载现有的操作符。通过 <code>operator</code> 关键字，我们可以为自定义类定义各种操作符的行为，使得我们的类可以像内置类型一样使用操作符。</p><p>如 <code>operator +</code> 来定义两个对象相加的行为，<code>operator []</code> 来实现索引操作，<code>operator ==</code> 来定义相等性比较。这种语义式的也更加符合直觉、清晰易懂。</p><p>下面来看看 <code>Map</code> 的 <code>Merge</code> 功能调用代码例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;StellarRemi&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> address = &#123;</span><br><span class="line">  <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;shanghai&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post_code&#x27;</span>: <span class="string">&#x27;200000&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> allInfo = userInfo | address;</span><br><span class="line">  <span class="built_in">print</span>(allInfo);</span><br><span class="line">  <span class="comment">// 输出结果：&#123;name: StellarRemi, age: 28, address: shanghai, post_code: 200000&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候也很简单直接 <code>userInfo | address;</code>，这种操作在处理数据更新或合并配置等情况下特别有用。使用的时候需要注意的是，如果两个 <code>Map</code> 中有重复的键，那么上述操作会保留第一个 <code>Map</code> 中的值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>怎么样，上面的这些 <code>Dart</code> 的语法是不是很有意思，有没有函数式编程那味儿，后面还会单独一篇来分享 <code>Dart</code> 语言面向对象的设计。好了，今天就到这里，也希望通过本文的分享，能够激发大家对 <code>Dart</code> 语言的兴趣，感谢您的阅读，更多干货文章扫描下方的二维码关注我的公众号“Flutter技术实践”。</p><p><img src="https://s2.loli.net/2022/11/09/fNBn2gWw8tVazkr.jpg" alt="Flutter技术实践"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/04/24/owI1VJfX4ZtOcKY.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;说到到某个语言的语法可能大家会觉得很枯燥、乏味，而日常开发中我们往往更加注重的是业务逻辑和页面开发，语法的使用大多也停留在满足基本的需求。其实 &lt;code&gt;Dart&lt;/code&gt; 语法有很多有意思的地方的，仔细探究一下你会发现，它的简洁清晰、灵活多样的语法会让人爱不释手。在本文中，我们将探索 Dart 语法的各种奇妙之处吧。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter大型项目架构：UI设计系统实现（一）</title>
    <link href="http://www.nnxkcloud.com/2024/04/21/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9AUI%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.nnxkcloud.com/2024/04/21/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9AUI%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2024-04-21T09:07:56.000Z</published>
    <updated>2024-10-15T03:05:34.688Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/04/26/phrXKsvEDQwTHl1.png"></p><p>前面几篇讲了很多关于分层设计、状态管理和依赖管理，但是作为前端开发，设计资源怎么去管理、设计系统如何去实现其实在日常开发中接触是最多的，每个开发者或者项目都有一套自己的管理方式或实现方式，今天来分享一下我在大型项目中是如何做设计和实现资源管理的。</p><span id="more"></span><h2 id="Flutter-默认的设计系统"><a href="#Flutter-默认的设计系统" class="headerlink" title="Flutter 默认的设计系统"></a><code>Flutter</code> 默认的设计系统</h2><p>在 <code>Flutter</code>  写页面的时候通常会用到 <code>package:flutter/material.dart</code> 和 <code>package:flutter/cupertino.dart</code> ，主要是为了使用 <code>Flutter SDK</code> 提供的 <code>Material/Cupertino Design</code> 风格的UI组件和工具，这其中它的默认主题。虽然您可以自定义默认文本主题的标题样式，但被严格限制为 3 个级别：<code>Large</code>, <code>Medium</code>, <code>Small</code>， <code>Color</code> 的命名的变量个数也是有限制的。 </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter技术实践&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        <span class="comment">// 设置主色为蓝色</span></span><br><span class="line">        primaryColor: Colors.blue,</span><br><span class="line">        <span class="comment">// 设置强调色为绿色</span></span><br><span class="line">        accentColor: Colors.green,</span><br><span class="line">        <span class="comment">// 设置默认字体为Roboto</span></span><br><span class="line">        fontFamily: <span class="string">&#x27;Roboto&#x27;</span>,</span><br><span class="line">        <span class="comment">// 设置默认文本样式</span></span><br><span class="line">        textTheme: TextTheme(</span><br><span class="line">            <span class="comment">// 设置标题文本样式</span></span><br><span class="line">            displayMedium:</span><br><span class="line">                TextStyle(fontSize: <span class="number">24</span>, fontWeight: FontWeight.bold),</span><br><span class="line">            <span class="comment">// 设置正文文本样式</span></span><br><span class="line">            bodyMedium: TextStyle(fontSize: <span class="number">16</span>),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 设置按钮的样式</span></span><br><span class="line">        buttonTheme: ButtonThemeData(</span><br><span class="line">          buttonColor: Colors.blue, <span class="comment">// 按钮颜色</span></span><br><span class="line">          shape: RoundedRectangleBorder(</span><br><span class="line">            borderRadius: BorderRadius.circular(<span class="number">8</span>), <span class="comment">// 圆角半径</span></span><br><span class="line">          ),</span><br><span class="line">          textTheme: ButtonTextTheme.primary, <span class="comment">// 按钮文本颜色</span></span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      home: HomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些原生的设计资源看起来好像是够用的，但是当我们需要给 <code>ListView</code> 一个背景颜色时，没用合适字段去表示。而在大型的 <code>Flutter</code> 项目中这种情况加太多了，又该如何做呢？</p><h2 id="定制自己的设计系统"><a href="#定制自己的设计系统" class="headerlink" title="定制自己的设计系统"></a>定制自己的设计系统</h2><p>设计系统是一套用于管理和共享设计资源的方法和工具集合。它包含了一系列的设计准则、组件、样式、布局规范等，将可重复使用的组件、样式指南（包括字体、颜色、尺寸等）和使用标准集合在一起集中去管理，旨在确保应用程序的视觉和交互一致性，并提高开发效率和设计协作能力。</p><p>对应到 <code>App</code> 中，将设计系统通常分为 3 类：</p><ul><li>原子级别：如 <code>color</code>、<code>font</code>、<code>padding</code>、<code>radius</code> 等等，这是构成设计系统的基础。</li><li>分子级别：如 <code>button</code>、<code>checkboxes</code>、<code>radio boxes</code>、<code>dividers</code>、<code>input fields</code>，是一些最基本和常见的 <code>widget</code>。</li><li>细胞级别：如 <code>appbars</code>、<code>complex card</code>，甚至自定义 <code>widget</code>（如 <code>CustomPainter</code>），一些更复杂的 <code>widget</code>。</li></ul><p>下面来实现一套自己的设计系统。</p><h2 id="Theme-Extension"><a href="#Theme-Extension" class="headerlink" title="Theme Extension"></a><code>Theme Extension</code></h2><p>通常自定义一些常用的主题样式属性，会将其封装在 <code>ThemeExtension</code> 中，<code>ThemeExtension</code> 是对 <code>ThemeData</code> 类的扩展，用于简化主题样式的设置和访问，使用 <code>ThemeExtension</code> 轻松地定义和管理我们自己的主题样式，并在整个项目中访问和应用。</p><h3 id="Color-Theme"><a href="#Color-Theme" class="headerlink" title="Color Theme"></a><code>Color Theme</code></h3><p>我们先以 <code>Colors</code> 为例，创建一个名为 <code>AppColorsTheme</code> 的类，继承自 <code>ThemeExtension</code>，如下面代码:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppColorsTheme</span> <span class="keyword">extends</span> <span class="title">ThemeExtension</span>&lt;<span class="title">AppColorsTheme</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _colorB0B0B0 = Color(<span class="number">0xFFB0B0B0</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _colorEFEFEF = Color(<span class="number">0xFFEFEFEF</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _color333333 = Color(<span class="number">0xFF333333</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _color6C6C6C = Color(<span class="number">0xFF6C6C6C</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _color7D7D7D = Color(<span class="number">0xFF7d7d7d</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _color676767 = Color(<span class="number">0xFF676767</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 页面中真正使用的颜色名称</span></span><br><span class="line">  <span class="keyword">final</span> Color backgroundDefault;</span><br><span class="line">  <span class="keyword">final</span> Color backgroundInput;</span><br><span class="line">  <span class="keyword">final</span> Color textDefault;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有的构造函数</span></span><br><span class="line">  <span class="keyword">const</span> AppColorsTheme._internal(&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.backgroundDefault,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.backgroundInput,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.textDefault,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浅色主题工厂方法</span></span><br><span class="line">  <span class="keyword">factory</span> AppColorsTheme.light() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> AppColorsTheme._internal(</span><br><span class="line">        backgroundDefault: _colorB0B0B0,</span><br><span class="line">        backgroundInput: _colorEFEFEF,</span><br><span class="line">        textDefault: _color333333);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暗色主题工厂方法</span></span><br><span class="line">  <span class="keyword">factory</span> AppColorsTheme.dark() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> AppColorsTheme._internal(</span><br><span class="line">        backgroundDefault: _color6C6C6C,</span><br><span class="line">        backgroundInput: _color7D7D7D,</span><br><span class="line">        textDefault: _color676767);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ThemeExtension&lt;AppColorsTheme&gt; copyWith(&#123;<span class="built_in">bool?</span> lightMode&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lightMode == <span class="keyword">null</span> || lightMode == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> AppColorsTheme.light();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> AppColorsTheme.dark();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ThemeExtension&lt;AppColorsTheme&gt; lerp(</span><br><span class="line">          <span class="keyword">covariant</span> ThemeExtension&lt;AppColorsTheme&gt;? other, <span class="built_in">double</span> t) =&gt;</span><br><span class="line">      <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将<code>color name</code>  与页面中实际使用的颜色变量名称分开，因为很多时候 <code>color name</code> 在不同的主题模式下是不一样的，虽然只提供了 <code>light</code> 和 <code>dark</code>，当然我还可以添加更多其它的主题颜色。</p><h3 id="Text-Theme"><a href="#Text-Theme" class="headerlink" title="Text Theme"></a><code>Text Theme</code></h3><p>创建文本样式主题，命名为 <code>AppTextsTheme</code>，同样继承自 <code>ThemeExtension</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppTextsTheme</span> <span class="keyword">extends</span> <span class="title">ThemeExtension</span>&lt;<span class="title">AppTextsTheme</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _baseFamily = <span class="string">&quot;Roboto&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> TextStyle labelH1;</span><br><span class="line">  <span class="keyword">final</span> TextStyle labelH2;</span><br><span class="line">  <span class="keyword">final</span> TextStyle labelTextDefault;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> AppTextsTheme._internal(</span><br><span class="line">      &#123;<span class="keyword">required</span> <span class="keyword">this</span>.labelH1,</span><br><span class="line">      <span class="keyword">required</span> <span class="keyword">this</span>.labelH2,</span><br><span class="line">      <span class="keyword">required</span> <span class="keyword">this</span>.labelTextDefault&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> AppTextsTheme.main() =&gt; <span class="keyword">const</span> AppTextsTheme._internal(</span><br><span class="line">      labelH1: TextStyle(</span><br><span class="line">        fontFamily: _baseFamily,</span><br><span class="line">        fontWeight: FontWeight.w400,</span><br><span class="line">        fontSize: <span class="number">18</span>,</span><br><span class="line">        height: <span class="number">1.4</span>,</span><br><span class="line">      ),</span><br><span class="line">      labelH2: TextStyle(</span><br><span class="line">        fontFamily: _baseFamily,</span><br><span class="line">        fontWeight: FontWeight.w300,</span><br><span class="line">        fontSize: <span class="number">16</span>,</span><br><span class="line">        height: <span class="number">1.4</span>,</span><br><span class="line">      ),</span><br><span class="line">      labelTextDefault: TextStyle(</span><br><span class="line">        fontFamily: _baseFamily,</span><br><span class="line">        fontWeight: FontWeight.w400,</span><br><span class="line">        fontSize: <span class="number">16</span>,</span><br><span class="line">        height: <span class="number">1.2</span>,</span><br><span class="line">      ));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ThemeExtension&lt;AppTextsTheme&gt; copyWith() &#123;</span><br><span class="line">    <span class="keyword">return</span> AppTextsTheme._internal(</span><br><span class="line">      labelH1: labelH1,</span><br><span class="line">      labelH2: labelH2,</span><br><span class="line">      labelTextDefault: labelTextDefault,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ThemeExtension&lt;AppTextsTheme&gt; lerp(</span><br><span class="line">          <span class="keyword">covariant</span> ThemeExtension&lt;AppTextsTheme&gt;? other, <span class="built_in">double</span> t) =&gt;</span><br><span class="line">      <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的字体等文本样式需要和 <code>UI</code> 设计人员沟通好，而且最好命名也和他们设计稿的名称保持一致，这样在后期重复使用的时候能最大的降低沟通成本。</p><h3 id="Dimension-Theme"><a href="#Dimension-Theme" class="headerlink" title="Dimension Theme"></a><code>Dimension Theme</code></h3><p><code>AppDimensionsTheme</code> 主要存放项目中的尺寸相关的主题数据，例如间距、大小、边框宽度等。这些尺寸数据通常用于保持应用程序中的视觉一致性和布局稳定性。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDimensionsTheme</span> <span class="keyword">extends</span> <span class="title">ThemeExtension</span>&lt;<span class="title">AppDimensionsTheme</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> radiusCommitButton;</span><br><span class="line">  <span class="keyword">final</span> EdgeInsets paddingOrderList;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> AppDimensionsTheme._internal(&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.radiusCommitButton,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.paddingOrderList,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> AppDimensionsTheme.main() =&gt; <span class="keyword">const</span> AppDimensionsTheme._internal(</span><br><span class="line">        radiusCommitButton: <span class="number">8</span>,</span><br><span class="line">        paddingOrderList: EdgeInsets.symmetric(horizontal: <span class="number">12</span>, vertical: <span class="number">10</span>),</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ThemeExtension&lt;AppDimensionsTheme&gt; copyWith() &#123;</span><br><span class="line">    <span class="keyword">return</span> AppDimensionsTheme._internal(</span><br><span class="line">      radiusCommitButton: radiusCommitButton,</span><br><span class="line">      paddingOrderList: paddingOrderList,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ThemeExtension&lt;AppDimensionsTheme&gt; lerp(</span><br><span class="line">          <span class="keyword">covariant</span> ThemeExtension&lt;AppDimensionsTheme&gt;? other, <span class="built_in">double</span> t) =&gt;</span><br><span class="line">      <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一般是放一些比较通用的尺寸，而不是将所有的和尺寸相关的都放在这里。你可能会问，尺寸都写死在这里，那如何做响应式 <code>UI</code> 呢？</p><h3 id="响应式-UI"><a href="#响应式-UI" class="headerlink" title="响应式 UI"></a>响应式 <code>UI</code></h3><p>为 <code>FlutterView</code> 创建一个 <code>extension</code>，命名为 <code>FlutterViewExtension</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/gestures.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> FlutterViewExtension <span class="keyword">on</span> FlutterView &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">double</span> responsive360 = <span class="number">360</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">double</span> responsive480 = <span class="number">480</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">double</span> responsive600 = <span class="number">600</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">double</span> responsive800 = <span class="number">800</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">double</span> responsive900 = <span class="number">900</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">double</span> responsive1200 = <span class="number">1200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> logicalWidth =&gt; physicalSize.width / devicePixelRatio;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> logicalHeight =&gt; physicalSize.height / devicePixelRatio;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> logicalWidthSA =&gt;</span><br><span class="line">      (physicalSize.width - padding.left - padding.right) / devicePixelRatio;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> logicalHeightSA =&gt;</span><br><span class="line">      (physicalSize.height - padding.top - padding.bottom) / devicePixelRatio;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isSmallSmartphone &#123;</span><br><span class="line">    <span class="keyword">if</span> (logicalWidthSA &lt; logicalHeightSA) &#123;</span><br><span class="line">      <span class="keyword">return</span> (logicalWidthSA &lt;= responsive360 ||</span><br><span class="line">          logicalHeightSA &lt;= responsive600);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (logicalWidthSA &lt;= responsive600 ||</span><br><span class="line">          logicalHeightSA &lt;= responsive360);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isRegularSmartphoneOrLess &#123;</span><br><span class="line">    <span class="keyword">if</span> (logicalWidthSA &lt; logicalHeightSA) &#123;</span><br><span class="line">      <span class="keyword">return</span> (logicalWidthSA &lt;= responsive480 ||</span><br><span class="line">          logicalHeightSA &lt;= responsive800);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (logicalWidthSA &lt;= responsive800 ||</span><br><span class="line">          logicalHeightSA &lt;= responsive480);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isSmallTabletOrLess &#123;</span><br><span class="line">    <span class="keyword">if</span> (logicalWidthSA &lt; logicalHeightSA) &#123;</span><br><span class="line">      <span class="keyword">return</span> (logicalWidthSA &lt;= responsive600 ||</span><br><span class="line">          logicalHeightSA &lt;= responsive900);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (logicalWidthSA &lt;= responsive900 ||</span><br><span class="line">          logicalHeightSA &lt;= responsive600);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isRegularTabletOrLess &#123;</span><br><span class="line">    <span class="keyword">if</span> (logicalWidthSA &lt; logicalHeightSA) &#123;</span><br><span class="line">      <span class="keyword">return</span> (logicalWidthSA &lt;= responsive800 ||</span><br><span class="line">          logicalHeightSA &lt;= responsive1200);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (logicalWidthSA &lt;= responsive1200 ||</span><br><span class="line">          logicalHeightSA &lt;= responsive800);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>AppDimensionsTheme</code> 中使用，只需要在这里加上判断就可以了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">factory</span> AppDimensionsTheme.main(FlutterView flutterView) =&gt;</span><br><span class="line">  AppDimensionsTheme._internal(</span><br><span class="line">    radiusCommitButton: flutterView.isSmallSmartphone ? <span class="number">8</span> : <span class="number">16</span>,</span><br><span class="line">    paddingOrderList:</span><br><span class="line">        <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">16</span>, vertical: <span class="number">12</span>),</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="如何使用-Theme-Extension"><a href="#如何使用-Theme-Extension" class="headerlink" title="如何使用 Theme Extension"></a>如何使用 <code>Theme Extension</code></h3><p>第一步：在 <code>main.dart</code> 文件，将以下代码放在程序入口 <code>Widget</code> 的 <code>MaterialApp</code> 下面。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  title: <span class="string">&#x27;Flutter技术实践&#x27;</span>,</span><br><span class="line">  theme: Theme.of(context).copyWith(</span><br><span class="line">    extensions: [</span><br><span class="line">      AppTextsTheme.main(),</span><br><span class="line">      AppColorsTheme.light(),</span><br><span class="line">      AppDimensionsTheme.main(View.of(context)),</span><br><span class="line">    ],</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第二步：为 <code>ThemeData</code> 创建一个 <code>extension</code>，目的是简化了调用代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_todo/resources/app_colors_theme.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_todo/resources/app_dimensions_theme.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_todo/resources/app_texts_theme.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> ThemeDataExtension <span class="keyword">on</span> ThemeData &#123;</span><br><span class="line">  AppDimensionsTheme <span class="keyword">get</span> appDimensions =&gt; <span class="keyword">extension</span>&lt;AppDimensionsTheme&gt;()!;</span><br><span class="line"></span><br><span class="line">  AppColorsTheme <span class="keyword">get</span> appColors =&gt; <span class="keyword">extension</span>&lt;AppColorsTheme&gt;()!;</span><br><span class="line"></span><br><span class="line">  AppTextsTheme <span class="keyword">get</span> appTexts =&gt; <span class="keyword">extension</span>&lt;AppTextsTheme&gt;()!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：开始调用，这里显示文本样式为 <code>labelTextDefault</code>，颜色为 <code>textDefault</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;Flutter&quot;</span>,</span><br><span class="line">  style: Theme.of(context).appTexts.labelTextDefault.copyWith(</span><br><span class="line">    color: Theme.of(context).appColors.textDefault,</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="分层架构中去管理设计系统"><a href="#分层架构中去管理设计系统" class="headerlink" title="分层架构中去管理设计系统"></a>分层架构中去管理设计系统</h2><p><img src="https://s2.loli.net/2024/04/21/7oCVc96UkvN2bI5.png" alt="架构分层"></p><p>从上面的分层设计架构图可以到，把与 <code>Theme Extension</code> 相关的划分到 <code>resources</code> 的组件包（在上图红框内），<code>resources</code>  组件包的目录结构如下：</p><p><img src="https://s2.loli.net/2024/04/21/R39magV4F1pHLAW.png" alt="resources 组件包目录结构"></p><p>而<code>resources</code> 的组件包在整个架构中是作为基础组件包，不需要依赖任何其它组件包，这样在使用 <code>ThemeExtension</code> 时可以确保整个应用程序中使用的主题样式保持一致，从而提高用户体验和视觉一致性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了 <code>Flutter</code> 大型项目分层架构中的UI设计系统实现，主要是原子级别的，如 <code>color</code>、<code>font</code>、<code>padding</code>、<code>radius</code> 等等设计系统的基础，下一篇来介绍设计系统中分子级别和细胞级别，感谢您的阅读，更多该系列干货文章请关注我关注号：<strong>Flutter技术实践</strong>，记得关注加点赞哦！</p><p><img src="https://s2.loli.net/2022/11/09/fNBn2gWw8tVazkr.jpg" alt="Flutter技术实践"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/04/26/phrXKsvEDQwTHl1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;前面几篇讲了很多关于分层设计、状态管理和依赖管理，但是作为前端开发，设计资源怎么去管理、设计系统如何去实现其实在日常开发中接触是最多的，每个开发者或者项目都有一套自己的管理方式或实现方式，今天来分享一下我在大型项目中是如何做设计和实现资源管理的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>深入了解 Flutter 中的 BuildContext</title>
    <link href="http://www.nnxkcloud.com/2024/04/18/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Flutter-%E4%B8%AD%E7%9A%84-BuildContext/"/>
    <id>http://www.nnxkcloud.com/2024/04/18/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Flutter-%E4%B8%AD%E7%9A%84-BuildContext/</id>
    <published>2024-04-18T12:33:56.000Z</published>
    <updated>2024-10-15T03:05:34.692Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/04/18/yD7IvSUXkAniB2M.png" alt="19.png"></p><p>在 <code>Flutter</code> 中 <code>BuildContext</code> 可太常见了，不管是 <code>StatelessWidget</code> 还是 <code>StatefulWidget</code> 的 <code>build()</code> 函数参数都会带有 <code>BuildContext</code>，好像随处可见，就像我们的一位老朋友，但似乎又对其知之甚少（熟悉的陌生人），今天我们再来了解一下这位老朋友 <code>BuildContext</code>，看看它在 <code>Flutter</code> 架构中扮演什么角色，我们该如何使用它及使用的时候需要注意什么。</p><span id="more"></span><h2 id="BuildContext-是什么"><a href="#BuildContext-是什么" class="headerlink" title="BuildContext 是什么"></a><code>BuildContext</code> 是什么</h2><p>打开 <code>BuildContext</code> 所在的文档的看到的第一句话就是 <code>A handle to the location of a widget in the widget tree.</code> （翻译过来：小部件树中小部件位置的句柄），啥意思呢？ </p><p>每一个 <code>Widget</code> 都有自己的 <code>BuildContext</code>，而 <strong><code>BuildContext</code>  代表了 <code>Widget</code> 在 <code>Widget Tree</code> 中的位置</strong>，常用于在 <code>Widget Tree</code> 中查找和定位 <code>Widget</code>，或者执行任务，例如导航到其他屏幕、显示对话框、访问主题数据等，如 <code>Theme.of(context)</code>、<code>Navigator.of(context)</code>。</p><p><code>BuildContext</code> 提供对 <code>Widget</code> 和资源的访问，以及对当前 <code>Widget</code> 最近的祖先<code>Widget</code>的其他数据的访问。 如每个 <code>Widget</code> 的 <code>build()</code> 函数中使用的 <code>BuildContext</code> 参数，就是 <code>Flutter</code> 框架通过 <code>Widget Tree</code> 向下传递的 <code>BuildContext</code>。</p><p>假设现在显示一个对话框。即使用 <code>showDialog()</code> 方法创建对话框，但同时 <code>showDialog()</code> 需要传一个 <code>BuildContext</code> 参数。此时就可以把当前 <code>Widget</code> 的 <code>BuildContext</code> 传递给此方法以显示对话框，如下面代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildContextPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> BuildContextPage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;BuildContextPage&gt; createState() =&gt; _BuildContextPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BuildContextPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BuildContextPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        backgroundColor: <span class="keyword">const</span> Color(<span class="number">0xffffffff</span>),</span><br><span class="line">        body: Center(</span><br><span class="line">            child: Column(</span><br><span class="line">          children: [</span><br><span class="line">            TextButton(</span><br><span class="line">              child: <span class="keyword">const</span> Text(<span class="string">&#x27;ShowAlert&#x27;</span>),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                showDialog(</span><br><span class="line">                  context: context,</span><br><span class="line">                  builder: (BuildContext context) &#123;</span><br><span class="line">                    <span class="keyword">return</span> AlertDialog(</span><br><span class="line">                      title: <span class="keyword">const</span> Text(<span class="string">&#x27;Dialog Title&#x27;</span>),</span><br><span class="line">                      content: <span class="keyword">const</span> Text(<span class="string">&#x27;This is the content of the dialog.&#x27;</span>),</span><br><span class="line">                      actions: [</span><br><span class="line">                        TextButton(</span><br><span class="line">                          onPressed: () =&gt; Navigator.pop(context),</span><br><span class="line">                          child: <span class="keyword">const</span> Text(<span class="string">&#x27;Close&#x27;</span>),</span><br><span class="line">                        ),</span><br><span class="line">                      ],</span><br><span class="line">                    );</span><br><span class="line">                  &#125;,</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        )));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用-BuildContext"><a href="#如何使用-BuildContext" class="headerlink" title="如何使用 BuildContext"></a>如何使用 <code>BuildContext</code></h2><p>通常我们在使用 <code>BuildContext</code> 前会通过 <code>State</code> 的属性 <code>mounted</code> 来判断再使用，这是因为 <code>State</code> 是依附于 <code>Element</code> 创建，<code>Element</code> 的生命周期和 <code>State</code> 是同步的。如果 <code>Element</code> 销毁了，那此时的 <code>mounted</code> 则为 <code>false</code>，再去使用 <code>BuildContext</code> 就会报错，为 <code>true</code> 才可以继续使用，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TextButton(</span><br><span class="line">  onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">if</span> (!mounted) <span class="keyword">return</span>;</span><br><span class="line">    Navigator.of(context).pop();</span><br><span class="line">  &#125;,</span><br><span class="line">  child: <span class="keyword">const</span> Text(<span class="string">&#x27;Close&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="在逻辑层使用-BuildContext"><a href="#在逻辑层使用-BuildContext" class="headerlink" title="在逻辑层使用 BuildContext"></a>在逻辑层使用 <code>BuildContext</code></h2><p>有时候我们在 <code>ViewModel</code> 或者 <code>Bloc</code> 异步执行完成一些操作后，再使用 <code>BuildContext</code> 返回页面或者弹出提示框，如下面的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TextButton(</span><br><span class="line">  onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="keyword">await</span> model.login(success: <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      Navigator.of(context).pushNamed(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  child: <span class="keyword">const</span> Text(<span class="string">&#x27;Close&#x27;</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>而此时的 <code>ViewModel</code> 或者 <code>Bloc</code> 没有 <code>BuildContext</code>，同时，如上面代码需要在 <code>UI</code> 展示层来处理与功能相关的逻辑，随着 <code>App</code> 的需求和功能的扩展，有可能会在这里添加更多逻辑，造成视图层和逻辑层代码耦合在一起，不好维护。那要在 <code>ViewModel</code> 或者 <code>Bloc</code> 使用 <code>BuildContext</code> 该如何做呢？</p><ol><li>创建类 <code>NavigationService</code> ，并给添加一个 <code>GlobalKey</code> 属性。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavigationService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> GlobalKey&lt;NavigatorState&gt; navigatorKey = GlobalKey&lt;NavigatorState&gt;();</span><br><span class="line">  Future&lt;<span class="built_in">dynamic</span>&gt;? navigateTo(<span class="built_in">String</span> routeName) &#123;</span><br><span class="line">    <span class="keyword">return</span> navigatorKey.currentState?.pushNamed(routeName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> goBack() &#123;</span><br><span class="line">    <span class="keyword">return</span> navigatorKey.currentState?.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将 <code>NavigationService</code> 注册到 <code>get_it</code> 容器中。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GetIt locator = GetIt.instance;</span><br><span class="line"><span class="keyword">void</span> setupLocator() &#123;</span><br><span class="line">  locator.registerLazySingleton(() =&gt; NavigationService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将 <code>navigatorKey</code> 赋值给程序入口 <code>Widget</code> 的 <code>key</code>， <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        ChangeNotifierProvider(create: (_) &#123;</span><br><span class="line">          <span class="keyword">return</span> AppLanguageProvider();</span><br><span class="line">        &#125;),</span><br><span class="line">      ],</span><br><span class="line">      builder: (BuildContext context, Widget? child) &#123;</span><br><span class="line">        <span class="keyword">return</span> MaterialApp(</span><br><span class="line">          ...</span><br><span class="line">          key: locator&lt;NavigationService&gt;().navigatorKey,</span><br><span class="line">          onGenerateRoute: MyRoutes.router.generator,</span><br><span class="line">          initialRoute: MyRoutes.root,</span><br><span class="line">          ...,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修改 <code>LoginViewModel</code> 中的代码，异步操作完成后跳转页面。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginViewModel</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> NavigationService _navigationService = locator&lt;NavigationService&gt;();</span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; login(&#123;<span class="built_in">bool</span> success = <span class="keyword">true</span>&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">/// <span class="language-markdown">模拟网络请求</span></span></span><br><span class="line">    <span class="keyword">await</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      _navigationService.navigateTo(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>页面UI层调用，不再写逻辑判断了。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextButton(</span><br><span class="line">  onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> model.login(success: <span class="keyword">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: <span class="keyword">const</span> Text(<span class="string">&#x27;Close&#x27;</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>这样达到了 <code>ViewModel</code> 层处理所有逻辑，视图应该只调用模型上的函数，然后在需要时使用新状态 <code>rebild</code> 或者其它操作，降低了彼此之间的耦合。</li></ol><h2 id="需要注意什么？"><a href="#需要注意什么？" class="headerlink" title="需要注意什么？"></a><code>需要注意什么？</code></h2><ol><li>作用域问题，确保使用的 <code>BuildContext</code> 在正确的作用域内，即所在的 <code>Widget Tree</code> 中。避免在 <code>Widget Tree</code> 之外的地方使用 <code>BuildContext</code>，否则可能导致运行时错误.</li><li>生命周期问题，<code>BuildContext</code> 的生命周期与相应的 <code>Widget</code> 相关联。当 <code>Widget</code> 被创建时，会创建一个新的 <code>BuildContext</code> 对象，并在 <code>Widget</code> 树中传递。当 <code>Widget</code> 被移除时，相关的 <code>BuildContext</code> 也会被销毁。因此，在保存<code>BuildContext</code> 时，要确保它的生命周期与所需的操作相匹配，避免出现空指针异常。</li><li>尽量避免在 <code>build()</code> 函数中利用 <code>BuildContext</code> 获取 <code>MediaQuery</code> 的 <code>size</code> 和 <code>padding</code> 做大量计算的操作，如下面代码： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">var</span> size = MediaQuery.of(context).size;</span><br><span class="line">  <span class="keyword">var</span> padding = MediaQuery.of(context).padding;</span><br><span class="line">  <span class="keyword">var</span> width = size.width / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> height = size.width / size.height  *  (<span class="number">40</span> - padding.bottom);</span><br><span class="line">  <span class="keyword">return</span> Container(</span><br><span class="line">    color: Colors.amber,</span><br><span class="line">    width: width,</span><br><span class="line">    height: height,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面这种用法可能会导致键盘在弹出的时候，虽然当前页面并没有完全展示，但是也会导致你的控件不断重新计算从而出现卡顿。</li></ol><p>好了，今天分享就到这里，感谢您的阅读，记得关注加点赞哦。</p><p><img src="https://s2.loli.net/2022/11/09/fNBn2gWw8tVazkr.jpg" alt="Flutter技术实践"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/04/18/yD7IvSUXkAniB2M.png&quot; alt=&quot;19.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Flutter&lt;/code&gt; 中 &lt;code&gt;BuildContext&lt;/code&gt; 可太常见了，不管是 &lt;code&gt;StatelessWidget&lt;/code&gt; 还是 &lt;code&gt;StatefulWidget&lt;/code&gt; 的 &lt;code&gt;build()&lt;/code&gt; 函数参数都会带有 &lt;code&gt;BuildContext&lt;/code&gt;，好像随处可见，就像我们的一位老朋友，但似乎又对其知之甚少（熟悉的陌生人），今天我们再来了解一下这位老朋友 &lt;code&gt;BuildContext&lt;/code&gt;，看看它在 &lt;code&gt;Flutter&lt;/code&gt; 架构中扮演什么角色，我们该如何使用它及使用的时候需要注意什么。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter大型项目架构：依赖管理篇</title>
    <link href="http://www.nnxkcloud.com/2024/04/17/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E7%AF%87/"/>
    <id>http://www.nnxkcloud.com/2024/04/17/Flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E7%AF%87/</id>
    <published>2024-04-17T01:49:36.000Z</published>
    <updated>2024-10-15T03:05:34.689Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/04/16/hkYiExGqXdo62Rw.png"></p><p>前两篇文章说到了 <strong><a href="https://www.nnxkcloud.com/2023/08/09/flutter-%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%AF%87/">状态管理</a></strong> 和 <strong><a href="https://www.nnxkcloud.com/2024/03/26/flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E7%AF%87/">分层设计</a></strong> ，本篇换个角度来讲讲 <code>Flutter</code> 中的依赖管理，需要注意的是这里讲的依赖管理主要指项目内的代码，包括依赖注入、组件包之间的依赖关系，而不是第三方库的依赖管理，下面开始进入正题。</p><span id="more"></span><h2 id="为啥需要依赖管理"><a href="#为啥需要依赖管理" class="headerlink" title="为啥需要依赖管理"></a>为啥需要依赖管理</h2><p>你可能会问，为啥搞那么麻烦使用依赖管理？不就是实例化的时候多写几句代码嘛，没有用它照样能把功能完成，不是吗？这么说也没错，如果只是在项目的几个位置这样写，问题也不大，可是放大到大型的项目中呢，该如何应对呢？下面这段代码是没有使用依赖管理之前的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoryTool</span> </span>&#123;</span><br><span class="line">  ApiService _apiService;</span><br><span class="line">  AppPreferences _appPreferences;</span><br><span class="line">  AppDatabase _appDatabase;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">factory</span> RepositoryTool() =&gt; _singleton;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> RepositoryTool _singleton = RepositoryTool._();</span><br><span class="line">  <span class="keyword">static</span> RepositoryTool <span class="keyword">get</span> instance =&gt; RepositoryTool();</span><br><span class="line">  </span><br><span class="line">  RepositoryTool._() &#123;</span><br><span class="line">    _apiService = ApiService();</span><br><span class="line">    _appPreferences = AppPreferences();</span><br><span class="line">    _appDatabase = AppDatabase();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录请求</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; login(&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> username,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> password,</span><br><span class="line">  &#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    _appApiService.login(username: username, password: password);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从数据库中获取用户信息</span></span><br><span class="line">  Future&lt;User&gt; getLocalUser(<span class="built_in">int</span> id) <span class="keyword">async</span> &#123;</span><br><span class="line">    _appDatabase.getLocalUser(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里单例类 <code>RepositoryTool</code> 为整个应用提供数据的，其有三个成员变量：<code>_apiService</code> 负责接口请求服务；<code>_appPreferences</code> 负责从偏好设置中读取或者存储数据，主要是一些字段或者 <code>Bool</code> 值；<code>_appDatabase</code> 负责从数据库中读取或者存储数据，这三个也是应用中经常使用的，它们都和数据相关却各司其职。但是当我们需更改一下 <code>_apiService</code> 的构造函数的时候，如下面的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line">  ApiService(</span><br><span class="line">    <span class="keyword">this</span>._noneAuthApiClient, </span><br><span class="line">    <span class="keyword">this</span>._authApiClient);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> NoneAuthApiClient _noneAuthApiClient;</span><br><span class="line">  <span class="keyword">final</span> AuthApiClient _authApiClient;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录操作</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; login(&#123;<span class="built_in">String</span> username, <span class="built_in">String</span> password&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> _authApiClient.request(</span><br><span class="line">        method: RestMethod.post,</span><br><span class="line">        path: <span class="string">&#x27;/v1/auth/login&#x27;</span>,</span><br><span class="line">        queryParameters: &#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: password&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 RestApiClient，用于发送不带 Token 的接口请求，如登录操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoneAuthApiClient</span> <span class="keyword">extends</span> <span class="title">RestApiClient</span> </span>&#123;</span><br><span class="line">  NoneAuthApiClient(HeaderInterceptor _headerInterceptor)</span><br><span class="line">      : <span class="keyword">super</span>(baseUrl: <span class="string">&quot;&quot;</span> interceptors: [</span><br><span class="line">          _headerInterceptor,</span><br><span class="line">        ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 RestApiClient，用于发送带 Token 的接口请求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthApiClient</span> <span class="keyword">extends</span> <span class="title">RestApiClient</span> </span>&#123;</span><br><span class="line">  AuthApiClient(</span><br><span class="line">    HeaderInterceptor _headerInterceptor,</span><br><span class="line">    AccessTokenInterceptor _accessTokenInterceptor,</span><br><span class="line">    RefreshTokenInterceptor _refreshTokenInterceptor,</span><br><span class="line">  ) : <span class="keyword">super</span>(baseUrl: <span class="string">&quot;&quot;</span>, interceptors: [</span><br><span class="line">          _headerInterceptor,</span><br><span class="line">          _accessTokenInterceptor,</span><br><span class="line">          _refreshTokenInterceptor,</span><br><span class="line">        ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Api 请求的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestApiClient</span> </span>&#123;</span><br><span class="line">  RestApiClient(&#123;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="keyword">this</span>.interceptors = <span class="keyword">const</span> [],</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用 Dio 发送请求</span></span><br><span class="line">  Future&lt;T&gt; request&lt;T, D&gt;()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候又得回到 <code>RepositoryTool</code> 的 <code>RepositoryTool._() </code> 修改实例 <code>_apiService</code> 初始化代码，而在 <code>ApiService</code> 类中的成员变量 <code>_noneAuthApiClient</code> 和 <code>_authApiClient</code> 也需要在实例化的时候传入不同的 <code>Interceptor</code> 。</p><p>同样 <code>_appPreferences</code>  和 <code>_appDatabase</code>  的构造函数也是需要传入不同类实例参数，如果不把这些参数放在构造函数中传入的话，就需要在用到地方去实例化。如 <code>RepositoryTool</code> 的 <code>RepositoryTool._() </code> 的代码，导致这些类 <code>ApiService</code>、<code>AppPreferences</code>、<code>AppDatabase</code> 和 <code>RepositoryTool</code> 紧密耦合在一起，难以进行单元测试和扩展，而且，构造函数一改其它所有用到的地方都得改，代码维护成本太高了。</p><h2 id="依赖管理是什么"><a href="#依赖管理是什么" class="headerlink" title="依赖管理是什么"></a>依赖管理是什么</h2><p>用过 <code>get_it</code> 的同学可能会说，用依赖注入不就可以优化上面的问题吗，和依赖管理有什么关系呢？依赖注入（<code>Dependency Injection</code>，简称：<code>DI</code>）和依赖管理（<code>Dependency Management</code>）在软件开发中确实是两个相关但不同的概念。</p><p>依赖注入是一种软件设计模式，它通过将依赖关系从代码中分离出来，并由外部系统在运行时动态地注入到代码中，从而实现了依赖的管理，是一种实现依赖管理的技术手段。</p><p>依赖注入需要依赖管理来实现，在依赖注入的实践过程中，需要一个依赖管理的机制来管理各个组件之间的依赖关系。这包括管理依赖的声明周期、版本、配置等信息，并确保依赖的正确注入和使用。</p><p>如下图体现出来的各个组件的依赖关系：</p><p><img src="https://s2.loli.net/2024/03/27/RvQMhaPd8p4cOf5.png" alt="各个组件的依赖关系"></p><p>在主工程 <code>App</code> 中的 <code>LoginPage</code> 发送登录请求，上图中是在 <code>Bloc</code> 调用抽象类 <code>Repository</code> 登录函数，<code>Repository</code> 是在 <code>domain</code> 组件包的，实际上登录操作的实现是在 <code>data</code> 组件包中的类 <code>RepositoryImpl</code> 的 <code>login</code> 函数。<code>App</code> 只需要依赖 <code>domain</code> 组件包，不直接依赖 <code>data</code>，而这之间的实现代码则是由<code>DI</code> 帮我们完成的。</p><h2 id="Flutter-中依赖管理方案"><a href="#Flutter-中依赖管理方案" class="headerlink" title="Flutter 中依赖管理方案"></a>Flutter 中依赖管理方案</h2><p>具体该怎么操作呢？我在 <strong><a href="https://www.nnxkcloud.com/2024/04/13/flutter%E5%BC%80%E5%8F%917%E4%B8%AA%E5%BB%BA%E8%AE%AE%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E9%A3%99%E5%8D%87/">《Flutter开发7个建议，让你的工作效率飙升》</a></strong> 也提到了依赖注入，也是以 <code>Repository</code> 为例，通过 <code>get_it</code> 和 <code>injectable</code> 配合来使用，达到解耦<code>App</code>  和 <code>data</code> 组件之间的依赖关系。今天换一个，我们以 <code>AppNavigator</code> 为例，来看看怎样解耦业务调用 <code>AppNavigator</code>  和导航具体实现的之间关系。先来看看 <code>AppNavigator</code> 中的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppNavigator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AppNavigator();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> currentBottomTab;</span><br><span class="line"></span><br><span class="line">  Future&lt;T?&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object?</span>&gt;(AppRouteInfo appRouteInfo);</span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; pop&lt;T <span class="keyword">extends</span> <span class="built_in">Object?</span>&gt;(&#123;</span><br><span class="line">    T? result,</span><br><span class="line">    <span class="built_in">bool</span> useRootNavigator = <span class="keyword">false</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>AppNavigator</code> 还是 <code>abstract</code> 类，和 <code>Repository</code> 一样，也是在 <code>domain</code> 组件包中，从上面的各个组件的依赖关系图看出，<code>AppNavigator</code>  实现类 <code>AppNavigatorImpl</code> 放在了主工程 <code>App</code> 组件包中的。</p><p>类<code>AppNavigatorImpl</code> 实现代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:auto_route/auto_route.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:domain/domain.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span> <span class="keyword">as</span> m;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:injectable/injectable.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LazySingleton</span>(<span class="keyword">as</span>: AppNavigator)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppNavigatorImpl</span> <span class="keyword">extends</span> <span class="title">AppNavigator</span></span>&#123;</span><br><span class="line">  AppNavigatorImpl(</span><br><span class="line">    <span class="keyword">this</span>._appRouter,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> AppRouter _appRouter;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> currentBottomTab &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;T?&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object?</span>&gt;(AppRouteInfo appRouteInfo) &#123;</span><br><span class="line">    <span class="keyword">return</span> _appRouter.push&lt;T&gt;(_appRouteInfoMapper.map(appRouteInfo));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; pop&lt;T <span class="keyword">extends</span> <span class="built_in">Object?</span>&gt;(&#123;T? result, <span class="built_in">bool</span> useRootNavigator = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> _appRouter.pop&lt;T&gt;(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppNavigatorImpl</code> 中实现的路由导航是插件 <code>auto_route</code>，通过构造函数传过来，此时运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure><p>在 <code>di.config.dart</code> 自动生成了如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:get_it/get_it.dart&#x27;</span> <span class="keyword">as</span> _i1;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:injectable/injectable.dart&#x27;</span> <span class="keyword">as</span> _i2;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:domain/domain.dart&#x27;</span> <span class="keyword">as</span> _i4;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:app/navigation/routes/app_router.dart&#x27;</span> <span class="keyword">as</span> _i5;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:app/app.dart&#x27;</span> <span class="keyword">as</span> _i6;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:app/navigation/app_navigator_impl.dart&#x27;</span> <span class="keyword">as</span> _i7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> GetItInjectableX <span class="keyword">on</span> _i1.GetIt &#123;</span><br><span class="line">  <span class="comment">// initializes the registration of main-scope dependencies inside of GetIt</span></span><br><span class="line">  _i1.GetIt init(&#123;</span><br><span class="line">    <span class="built_in">String?</span> environment,</span><br><span class="line">    _i2.EnvironmentFilter? environmentFilter,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> gh = _i2.GetItHelper(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      environment,</span><br><span class="line">      environmentFilter,</span><br><span class="line">    );</span><br><span class="line">   </span><br><span class="line">    gh.lazySingleton&lt;_i5.AppRouter&gt;(() =&gt; _i5.AppRouter());</span><br><span class="line">    gh.lazySingleton&lt;_i4.AppNavigator&gt;(() =&gt; _i7.AppNavigatorImpl(</span><br><span class="line">          gh&lt;_i6.AppRouter&gt;(),</span><br><span class="line">        ));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>DI</code> 生成的代码也能看出它们之间的依赖关系，在用到导航跳转的时候从 <code>get_it</code> 容器中取出使用即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">late</span> <span class="keyword">final</span> AppNavigator navigator = GetIt.instance.<span class="keyword">get</span>&lt;AppNavigator&gt;();</span><br><span class="line">navigator.push(...);</span><br></pre></td></tr></table></figure><p>这样调用的时候是通过抽象类 <code>AppNavigator</code> ，不需要关心导航的具体是怎么实现的。或许哪天不用插件 <code>auto_route</code> 来做路由导航，只需要继承 <code>AppNavigator</code> 的并实现它的函数即可，而调用的地方不需要做任何更改。</p><p>上面的例子是以 <code>Navigator</code> 相关的作为切入点，其实在大型 <code>Flutter</code> 项目中用这种 <strong>并依赖于抽象而不是具体的实现</strong> 的理念来做依赖管理的地方有很多，这样做的好处是使得代码更加清晰、模块化，并且方便进行单元测试和维护。同时，通过依赖注入容器的注册和获取，可以实现依赖对象的延迟加载和单例管理，提高了应用程序的性能和效率。</p><p>本篇算是上一篇文章 <strong><a href="%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1">《Flutter大型项目架构：分层设计篇》</a></strong> 的延伸，也是做分层设计的落地实施时必不可少的环节。今天分享到这里，更多系列文章更新在公众号：<strong>Flutter技术实践</strong> 里，感谢您的阅读。</p><p><img src="https://s2.loli.net/2022/11/09/fNBn2gWw8tVazkr.jpg" alt="Flutter技术实践"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/04/16/hkYiExGqXdo62Rw.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;前两篇文章说到了 &lt;strong&gt;&lt;a href=&quot;https://www.nnxkcloud.com/2023/08/09/flutter-%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%AF%87/&quot;&gt;状态管理&lt;/a&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;a href=&quot;https://www.nnxkcloud.com/2024/03/26/flutter%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E7%AF%87/&quot;&gt;分层设计&lt;/a&gt;&lt;/strong&gt; ，本篇换个角度来讲讲 &lt;code&gt;Flutter&lt;/code&gt; 中的依赖管理，需要注意的是这里讲的依赖管理主要指项目内的代码，包括依赖注入、组件包之间的依赖关系，而不是第三方库的依赖管理，下面开始进入正题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter开发7个建议，让你的工作效率飙升</title>
    <link href="http://www.nnxkcloud.com/2024/04/13/Flutter%E5%BC%80%E5%8F%917%E4%B8%AA%E5%BB%BA%E8%AE%AE%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E9%A3%99%E5%8D%87/"/>
    <id>http://www.nnxkcloud.com/2024/04/13/Flutter%E5%BC%80%E5%8F%917%E4%B8%AA%E5%BB%BA%E8%AE%AE%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E9%A3%99%E5%8D%87/</id>
    <published>2024-04-13T08:30:13.000Z</published>
    <updated>2024-10-15T03:05:34.689Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/04/13/9Pq84iVst1CG7oR.png" alt=" 10 5.png"></p><p>刚开始接触用 <code>Flutter</code>  开发App的时候，比较喜欢它的 <code>UI</code> 编写方式，尤其是 <code>Flutter</code> 热重载特性，UI调试如同Web前端开发，能够即时查看代码更改的效果。那在日常开发中，还有没有其它提升工作效率的方法呢，今天就给大家分享几个超实用的建议，助你在 <code>Flutter</code> 开发中事半功倍。</p><span id="more"></span><h2 id="1-使用-Code-Snippets"><a href="#1-使用-Code-Snippets" class="headerlink" title="1. 使用 Code Snippets"></a>1. 使用 <code>Code Snippets</code></h2><p>如果之前做过原生的 <code>iOS</code> 或者 <code>Android</code> 再来写 <code>Flutter</code> 代码的时候，<code>Flutter</code> 在代码提示上会不习惯，比如 <code>for</code> 循环，<code>Flutter</code> 的代码提示是 <code>foreach</code> 或者 <code>for(var a in arr)</code> 这些。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; items = [<span class="string">&quot;Flutter&quot;</span>, <span class="string">&quot;iOS&quot;</span>, <span class="string">&quot;Android&quot;</span>];</span><br><span class="line">items.forEach((element) &#123;</span><br><span class="line">   <span class="built_in">print</span>(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> element <span class="keyword">in</span> items) &#123;</span><br><span class="line">   <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要数组的索引的时候，就需要手写一遍：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = items[i];</span><br><span class="line">    <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们可以这些常用的代码保存到自己的 <code>Code Snippets</code> 中，具体操作根据编辑器不同而不同，这里以 <code>Android Studio</code> 为例，<strong>Setting</strong>  -&gt; <strong>Editor</strong> -&gt; <strong>Live Templates</strong>。<br><img src="https://s2.loli.net/2024/04/12/NzbgmntulxhAfjZ.png" alt="添加 Code Snippets"></p><p>使用的时候输入：<code>fori</code> 编辑器就会有提示，选中回车后就是保存的<code>Code Snippets</code>，是不是很方便。</p><h2 id="2-使用代码生成器"><a href="#2-使用代码生成器" class="headerlink" title="2. 使用代码生成器"></a>2. 使用代码生成器</h2><p>开发过程中有大量重复的代码或者操作，这个时候使用代码生成器可以自动生成重复性的代码，减少开发人员手动编写模板代码的工作量。这样可以节省大量的时间和精力，并使开发人员能够更专注于解决业务逻辑和UI设计等核心任务。不同于<code>Code Snippets</code> 需要依赖编辑器的设置，这生成的代码则使用插件或者工具来完成。</p><p>下面是我经常使用的代码生成器插件或者工具：</p><ol><li><code>flutter_gen</code>：项目图片资源、字体、颜色等的代码生成器。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Image.asset(<span class="string">&#x27;assets/images/profile.jpeg&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 使用 <code>flutter_gen</code> 之后，显示图片的时候再也不需要填入字符串了。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Assets.images.profile.image();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>intl_utils</code>：<code>Intl</code> 库样板代码生成器，用于在 .arb 文件的翻译和 Flutter 应用程序之间创建绑定。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text(AppLocalizations.of(context)!.translate(<span class="string">&#x27;intl_zh&#x27;</span>)),</span><br></pre></td></tr></table></figure>使用 <code>intl_utils</code> 生成的模板代码：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  S.of(context).intl_zh,</span><br><span class="line">  style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">      color: Color(<span class="number">0xFFffffff</span>), fontSize: <span class="number">22</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><a href="https://ftool.nnxkcloud.com/">ftool</a>：我自己开发的一款 <code>JSON</code> 字符串转成 <code>Dart Model</code> 生成器工具。<br> <img src="https://s2.loli.net/2024/03/22/f3Sjbvqgpdh7E2t.png" alt="JSON 字符串转成 Dart Model"></li></ol><p> 其它的还有很多，如：<code>Bloc Generator</code>、<code>Provider Generator</code> 等状态管理相关的模板代码生成器，我就不在这里一一列举了。</p><h2 id="3-应用图标生成"><a href="#3-应用图标生成" class="headerlink" title="3. 应用图标生成"></a>3. 应用图标生成</h2><p><code>Flutter</code> 应用图标需要支持多个平台，如果每一张不同尺寸的图标都去手动切的话，太麻烦，这里推荐一个插件工具 <code>flutter_launcher_icons</code>，只需要几个配置就可以自动生成各个平台的应用图标。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter_launcher_icons:</span> <span class="string">^0.13.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flutter_icons:</span></span><br><span class="line">  <span class="attr">image_path:</span> <span class="string">&quot;images/image.png&quot;</span></span><br><span class="line">  <span class="attr">android:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ios:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#image_path_ios: &quot;images/image.png&quot;</span></span><br><span class="line">  <span class="comment">#image_path_android: &quot;images/image.png&quot;</span></span><br></pre></td></tr></table></figure><p>命令行工具里执行下面命令就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub run flutter_launcher_icons</span><br></pre></td></tr></table></figure><p> 如果你还是觉得麻烦，不想引入这个插件，可以使用在线工具，网上也有很多。</p><h2 id="4-CI-CD"><a href="#4-CI-CD" class="headerlink" title="4. CI/CD"></a>4. <code>CI/CD</code></h2><p> 持续集成（<code>CI</code>）和持续交付（<code>CD</code>）在开发过程中的好处有很多，特别是对于使用 <code>Flutter</code> 做跨平台开发 <code>App</code> 来说，如果用传统手动的方式打包提测那就太耗时间了，<code>CI/CD</code> 可以做快速地构建和部署应用程序，节省宝贵的时间也最大限度地减少人为错误，</p><p><img src="https://s2.loli.net/2024/04/13/UCSdVJ4sNBvlbuA.png" alt="CI/CD"></p><p>团队开发更是如此，能确保所有团队成员都在同一个一致的构建环境中工作，这有助于避免由于环境差异而导致的问题。我们常使用工具有 <code>Fastlane</code>，它在 <code>Flutter</code> 项目中的详细用法以后抽个时间会专门写一篇文章来介绍。</p><h2 id="5-清晰的应用架构"><a href="#5-清晰的应用架构" class="headerlink" title="5. 清晰的应用架构"></a>5. 清晰的应用架构</h2><p> 不管是大型还是小型的 <code>Flutter</code> 应用，一个清晰的应用架构设计也是不可或缺的，尤其是在团队开发的时候，每个人项目经验、代码风格各不相同，如果碰上项目赶工期的话，那写出来的除了本人其它人都看不懂，时间久了有可能他自己也看不懂了。这时候，清晰的应用架构使团队成员之间更容易合作和协同工作。每个人都可以清楚地了解项目的结构和设计，从而更好地分工合作，提高开发效率。</p><p> <img src="https://s2.loli.net/2024/03/27/RvQMhaPd8p4cOf5.png" alt="Flutter App Architecture Design"></p><p> 你可能会说应用架构的设计和使用并不是很简单和直接，甚至还有些繁琐，怎么能提升开发效率？关于 <code>Flutter</code> 应用架构的设计和实践相关的疑问，可以翻一翻我之前的两篇文章：<strong>《Flutter大型项目架构：状态管理篇》</strong> 和 <strong>《Flutter大型项目架构：分层设计篇》</strong>，也许你会从中找到答案。</p><h2 id="6-依赖注入"><a href="#6-依赖注入" class="headerlink" title="6. 依赖注入"></a>6. 依赖注入</h2><p>说到依赖注入那就不得不提 <code>get_it</code>，在 <code>Flutter</code> 开发里知名度高使用人数众多，那它是如何做依赖管理的呢？我在 <code>get_it</code> 的官方文档找到了这句话。</p><blockquote><p>it’s a way to decouple the interface (abstract base class) from a concrete implementation, and at the same time allows to access the concrete implementation from everywhere in your App over the interface. </p></blockquote><p>大概意思就是：它是一种将接口（抽象基类）与具体实现解耦的方法，同时允许通过接口从应用程序中的任何位置访问具体实现。</p><p><code>Flutter</code> 中是不支持反射的，而大多数传统的 <code>IoC</code> 容器要依赖于反射，<code>get_it</code> 的作者就借鉴了 <code>.Net</code> 中的服务定位器（<code>ServiceLocator</code>）的概念，并运用到了 <code>Flutter</code> 中，相比于传统的 <code>IoC</code>  容器，<code>get_it</code> 更加轻量简洁。</p><p>我们怎么使用 <code>get_it</code>  呢？<code>get_it</code> 文档写的很详细了，但本篇文章介绍另外一种使用方法，就是和 <code>injectable</code>  插件一起使用，下面是简单的示例用法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Repository</span> </span>&#123;</span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; login(&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> email,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> password,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@LazySingleton</span>(<span class="keyword">as</span>: Repository)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoryImpl</span> <span class="keyword">implements</span> <span class="title">Repository</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; login(&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> email,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> password,</span><br><span class="line">  &#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 登录操作，发送网络请求</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行运行：<code>flutter packages pub run build_runner build</code> 命令后，就会自动生成以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:get_it/get_it.dart&#x27;</span> <span class="keyword">as</span> _i1;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:injectable/injectable.dart&#x27;</span> <span class="keyword">as</span> _i2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> GetItInjectableX <span class="keyword">on</span> _i1.GetIt &#123;</span><br><span class="line">  <span class="comment">// initializes the registration of main-scope dependencies inside of GetIt</span></span><br><span class="line">  Future&lt;_i1.GetIt&gt; init(&#123;</span><br><span class="line">    <span class="built_in">String?</span> environment,</span><br><span class="line">    _i2.EnvironmentFilter? environmentFilter,</span><br><span class="line">  &#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> gh = _i2.GetItHelper(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      environment,</span><br><span class="line">      environmentFilter,</span><br><span class="line">    );</span><br><span class="line">    gh.lazySingleton&lt;_i3.Repository&gt;(() =&gt; _i4.RepositoryImpl());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务层调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span>&lt;<span class="title">LoginEvent</span>, <span class="title">LoginState</span>&gt; </span>&#123;</span><br><span class="line">  LoginBloc(<span class="keyword">this</span>._repository) : <span class="keyword">super</span>(LoginState()) &#123;</span><br><span class="line">  <span class="keyword">on</span>&lt;LoginButtonPressed&gt;(</span><br><span class="line">        _onLoginButtonPressed,</span><br><span class="line">        transformer: log(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Repository _repository;</span><br><span class="line">  </span><br><span class="line">  FutureOr&lt;<span class="keyword">void</span>&gt; _onLoginButtonPressed(LoginButtonPressed event, Emitter&lt;LoginState&gt; emit) &#123;</span><br><span class="line">  _repository.login(email: <span class="string">&quot;&quot;</span>,  password:<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中以发送登录请求为例，在业务层使用的直接调用抽象类 <code>Repository</code> 的 <code>login</code> 函数，而具体实现则在 <code>RepositoryImpl</code> 中，很好的隔离业务层和数据处理层，使得他们之间的连接都是通过抽象层 <code>Repository</code> ，这中间的依赖关系不再需要你写任何代码，<code>get_it</code>  配合 <code>injectable</code> 帮你生成了，这样管理和解耦应用程序的组件更加方便了，特别是跨组件调用的时候，提高代码的可维护性、可测试性和灵活性。</p><h2 id="7-Github-Copilot"><a href="#7-Github-Copilot" class="headerlink" title="7. Github Copilot"></a>7. <code>Github Copilot</code></h2><p>一款由 <code>GitHub</code> 和 <code>OpenAI</code> 共同开发的人工智能代码编写助手，它基于 <code>GPT</code> 模型生成代码建议，可以根据上下文和用户输入提供代码提示和建议，帮助开发者快速编写代码。还能能够生成函数、类、变量声明等各种类型的代码片段，并提供自然语言描述的文档注释。</p><p><img src="https://s2.loli.net/2024/04/13/Vj7OBz3IbArJsZE.gif" alt="Copilot"></p><p>用过的就不需要我多说了吧，好用是真好用，就是有点儿小贵（对于小编来说），初学者使用它简直太香了，可以直接把 <code>Copilot</code> 作为学习工具，用来学习编程语言和编码风格。</p><p>以上与插件相关的内容着重在提升效率的说明上，详细用法还是要去阅读官方文档。以上建议是小编在开发过程中经常使用到的，也仅代表我个人的观点，当然还有更多其它提升效率的方法。好了，本篇文章分享就到这里，感谢您的阅读，原创不易，记得关注加点赞哦。</p><center>    <img src="https://s2.loli.net/2022/12/12/EWvyFX2LgiaeZ3d.jpg" style="width: 100px;"></center>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/04/13/9Pq84iVst1CG7oR.png&quot; alt=&quot; 10 5.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;刚开始接触用 &lt;code&gt;Flutter&lt;/code&gt;  开发App的时候，比较喜欢它的 &lt;code&gt;UI&lt;/code&gt; 编写方式，尤其是 &lt;code&gt;Flutter&lt;/code&gt; 热重载特性，UI调试如同Web前端开发，能够即时查看代码更改的效果。那在日常开发中，还有没有其它提升工作效率的方法呢，今天就给大家分享几个超实用的建议，助你在 &lt;code&gt;Flutter&lt;/code&gt; 开发中事半功倍。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>App开发装X指南：玩转自定义绘制</title>
    <link href="http://www.nnxkcloud.com/2024/04/12/App%E5%BC%80%E5%8F%91%E8%A3%85X%E6%8C%87%E5%8D%97%EF%BC%9A%E7%8E%A9%E8%BD%AC%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%88%B6/"/>
    <id>http://www.nnxkcloud.com/2024/04/12/App%E5%BC%80%E5%8F%91%E8%A3%85X%E6%8C%87%E5%8D%97%EF%BC%9A%E7%8E%A9%E8%BD%AC%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%88%B6/</id>
    <published>2024-04-12T02:42:24.000Z</published>
    <updated>2024-10-15T03:05:34.687Z</updated>
    
    <content type="html"><![CDATA[<p>先来看看某互联网公司前端开发和产品的日常交流（互掐）：</p><p><img src="https://s2.loli.net/2024/04/10/yXcNRd6bonluQ14.png" alt="前端开发和产品日常交流"></p><p>很精彩吧，这种故事经常在互联网公司上演，那你可能会问这和本篇文章有什么关系呢？答案是没有关系。</p><span id="more"></span><p>到这里先别急着骂我哈，小编先来捋捋是咋个回事儿，作为一个从来都是和产品和平相处（苦大仇深）的App前端开发，每次碰到类似这种的需求心里都想对产品问候几遍，但是需要装X的时候，咱们得上啊，比人会的咱也会，别人不会的咱还得会，比如说 <code>Flutter</code> 的自定义绘制。</p><p><img src="https://s2.loli.net/2024/04/11/Bb8knuNdeVMFqvR.jpg"></p><p>你可能会问，这玩意儿能干啥？ <code>Flutter</code> 的内置组件还不够用吗？是的，<code>Flutter</code>  提供的内置组件的确可以满足大部分UI需求，但有时候需要实现一些特殊的UI效果，比如自定义图形（不规则的图形）、动画、渐变背景等，这时候就需要使用自定义绘制来实现。除了可以高度定制化的 <code>UI</code> 效果，同时可以减少  <code>UI</code>  的层级嵌套，优化 <code>UI</code> 性能，好处是不是很多。</p><p><img src="https://s2.loli.net/2024/04/11/WO2z7ybpIj9UDxM.png" alt="自定义图形"></p><p>比如上图中显示当前温度的圆形进度条，内置的 <code>Widget</code> 组件就没法儿实现了，这里就需要用到 <code>Flutter</code> 中的 <code>CustomPainter</code>。</p><h2 id="CustomPainter-是啥？"><a href="#CustomPainter-是啥？" class="headerlink" title="CustomPainter 是啥？"></a><code>CustomPainter</code> 是啥？</h2><p><code>CustomPainter</code> 是 <code>Flutter</code> 中的一个抽象类，用于绘制自定义的图形和图像。通过实现 <code>CustomPainter</code> 类并重写其 <code>paint</code> 方法，开发者可以自由地定义绘制逻辑，从而实现各种复杂的绘图效果。下面使用 <code>CustomPainter</code> 来绘制一个简单的自定义图形.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPainterPagePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> CustomPainterPagePage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;CustomPainterPagePage&gt; createState() =&gt; _CustomPainterPagePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CustomPainterPagePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CustomPainterPagePage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      backgroundColor: <span class="keyword">const</span> Color(<span class="number">0xffF2F4F5</span>),</span><br><span class="line">      body: CustomPaint(</span><br><span class="line">        painter: MyCustomPainter(), <span class="comment">// 应用自定义的绘制类</span></span><br><span class="line">        child: <span class="keyword">const</span> SizedBox(</span><br><span class="line">          width: <span class="number">200.0</span>,</span><br><span class="line">          height: <span class="number">200.0</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    <span class="keyword">final</span> paint = Paint()</span><br><span class="line">      ..color = Colors.blue</span><br><span class="line">      ..strokeWidth = <span class="number">3.0</span></span><br><span class="line">      ..style = PaintingStyle.fill;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制一个圆形</span></span><br><span class="line">    canvas.drawCircle(Offset(size.width / <span class="number">2</span>, size.height / <span class="number">2</span>), <span class="number">50.0</span>, paint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRepaint(<span class="keyword">covariant</span> CustomPainter oldDelegate) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：<br><img src="https://s2.loli.net/2024/04/11/FWAf4jnbPEZXV9C.png" alt="CustomPainter 自定义图形"></p><p>从上面的例子中可以看到使用 <code>CustomPainter</code>  绘制自定义图形有以下几个步骤：</p><ol><li>创建一个继承自 <code>CustomPainter</code> 的子类 <code>MyCustomPainter</code>，并实现其中的 <code>paint</code> 方法来定义绘图逻辑。在 <code>paint</code> 方法中，可以使用 <code>Canvas API</code> 来执行各种绘制操作，如绘制路径、文本、图像等。</li><li>将自定义的绘制类 <code>MyCustomPainter</code>  的实例传递给 <code>CustomPaint</code> 的 <code>painter</code> 属性，即可将自定义的绘制逻辑应用到 <code>Widget</code> 中。</li></ol><h2 id="CustomPaint-介绍"><a href="#CustomPaint-介绍" class="headerlink" title="CustomPaint 介绍"></a><code>CustomPaint</code> 介绍</h2><p>下面是 <code>CustomPaint</code> 的构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CustomPaint(&#123;</span><br><span class="line">    <span class="keyword">super</span>.key,</span><br><span class="line">    <span class="keyword">this</span>.painter,</span><br><span class="line">    <span class="keyword">this</span>.foregroundPainter,</span><br><span class="line">    <span class="keyword">this</span>.size = Size.zero,</span><br><span class="line">    <span class="keyword">this</span>.isComplex = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.willChange = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">super</span>.child,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ul><li><code>child</code>：子节点。</li><li><code>painter</code>: 背景画笔，会显示在 <code>child</code> 后面;</li><li><code>foregroundPainter</code>: 前景画笔，会显示在 <code>child</code> 前面</li><li><code>size</code>：当 <code>child</code> 为 <code>null</code> 时，代表默认绘制区域大小，如果有 <code>child</code> 则忽略此参数，画布尺寸则为 <code>child</code> 尺寸。如果有 <code>child</code> 但是想指定画布为特定大小，可以使用 <code>SizeBox</code> 包裹 <code>CustomPaint</code> 实现。</li><li><code>isComplex</code>：是否复杂的绘制，如果是，<code>Flutter</code> 会应用一些缓存策略来减少重复渲染的开销。</li><li><code>willChange</code>：和 <code>isComplex</code> 配合使用，当启用缓存时，该属性代表在下一帧中绘制是否会改变。</li></ul><h2 id="CustomPainter-源码"><a href="#CustomPainter-源码" class="headerlink" title="CustomPainter 源码"></a><code>CustomPainter</code> 源码</h2><p>下面是搂出的 <code>CustomPainter</code>  源码，为了好理解，小编在每个函数上面做了注释。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPainter</span> <span class="keyword">extends</span> <span class="title">Listenable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> CustomPainter(&#123; Listenable? repaint &#125;) : _repaint = repaint;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Listenable? _repaint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个回调，以便在需要重新绘制时收到通知。</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> addListener(VoidCallback listener) =&gt; _repaint?.addListener(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用不到的时候，需要移除监听。</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> removeListener(VoidCallback listener) =&gt; _repaint?.removeListener(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类重写在此方法，并执行各种绘制操作。</span></span><br><span class="line">  <span class="keyword">void</span> paint(Canvas canvas, Size size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为该绘制的图形构建语义信息。</span></span><br><span class="line">  SemanticsBuilderCallback? <span class="keyword">get</span> semanticsBuilder =&gt; <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要重绘语义信息</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRebuildSemantics(<span class="keyword">covariant</span> CustomPainter oldDelegate) =&gt; shouldRepaint(oldDelegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要重绘。</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRepaint(<span class="keyword">covariant</span> CustomPainter oldDelegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击时是否命中，传过来 position 对于当前绘制图形视为命中的点则为true，否则为false</span></span><br><span class="line">  <span class="built_in">bool?</span> hitTest(Offset position) =&gt; <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&#x27;<span class="subst">$&#123;describeIdentity(<span class="keyword">this</span>)&#125;</span>(<span class="subst">$&#123; _repaint?.toString() ?? <span class="string">&quot;&quot;</span> &#125;</span>)&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面使用频率最高的就是 <code>void paint(Canvas canvas, Size size);</code>  函数了，<code>Canvas</code>  就是画布，<code>Size</code> 是当前绘制区域大小，下面是 <code>Canvas</code>  内部常用的绘制函数。</p><ul><li><code>drawLine</code> 划线</li><li><code>drawPoint</code> 画点</li><li><code>drawPath</code> 画路径</li><li><code>drawImage</code> 画图像</li><li><code>drawRect</code> 画矩形</li><li><code>drawCircle</code> 画圆</li><li><code>drawOval</code> 画椭圆</li><li><code>drawArc</code>画圆弧</li></ul><p><code>Paint</code> 是画笔，可以配置画笔的各种属性如粗细、颜色、样式等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> paint = Paint()</span><br><span class="line">  ..color = Colors.blue<span class="comment">// 画笔颜色</span></span><br><span class="line">  ..strokeWidth = <span class="number">3.0</span><span class="comment">// 画笔线条大小</span></span><br><span class="line">  ..isAntiAlias = <span class="keyword">true</span><span class="comment">//是否抗锯齿</span></span><br><span class="line">  ..style = PaintingStyle.fill;<span class="comment">//画笔样式：填充</span></span><br></pre></td></tr></table></figure><h2 id="画板刷新"><a href="#画板刷新" class="headerlink" title="画板刷新"></a>画板刷新</h2><p>在 <code>CustomPainter</code> 源码中，构造函数中 <code>repaint</code> 是干啥用的？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CustomPainter(&#123; Listenable? repaint &#125;) : _repaint = repaint;</span><br><span class="line"><span class="keyword">final</span> Listenable? _repaint;</span><br></pre></td></tr></table></figure><p>其实 <code>Fultter</code> 源码注释文档已经告诉我们了，</p><p><img src="https://s2.loli.net/2024/04/11/7Ulz5uxHPO6dKpf.png" alt="画板刷新"></p><p>翻译过来就是，触发重绘的最高效方式是:</p><ol><li>继承 <code>[CustomPainter]</code> 类，并在构造函数提供一个 <code>&#39;repaint&#39;</code> 参数，当需要重新绘制时，该对象会进行通知它的监听者。</li><li>继承  <code>[Listenable] </code> （比如通过 <code> [ChangeNotifier]</code> ）并实现 <code>[CustomPainter]</code>，这样对象本身就可以直接提供通知。</li></ol><p>可能你会问直接 <code>setState</code> 干不就完了吗？还用得着这么麻烦。<code>setState</code>  当然是可以，但咱们是对程序性能有追求的，而且还得根据具体使用的场景。<code>setState</code>  重建的范围太大，如果绘制的是一个大且复杂的自定义图形，加上 <code>CustomPaint</code> 还有一个 <code>child</code> 子节点，亦或者还有一个高频率的动画和滑动，这些情况下用 <code>setState</code>  来销毁再重建 <code>Widget</code> 有可能直接影响页面的流畅度。下面整个例子来实现触发重绘的最高效方式。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeChangedPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; animation;</span><br><span class="line">  SizeChangedPainter(&#123;<span class="keyword">required</span> <span class="keyword">this</span>.animation&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    <span class="comment">// 绘制逻辑</span></span><br><span class="line">    <span class="built_in">double</span> rectWidth = animation.value * size.width;</span><br><span class="line">    <span class="built_in">double</span> rectHeight = animation.value * size.height;</span><br><span class="line"></span><br><span class="line">    Paint paint = Paint()..color = Colors.blue;</span><br><span class="line">    canvas.drawRect(Rect.fromLTRB(<span class="number">0</span>, <span class="number">0</span>, rectWidth, rectHeight), paint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRepaint(<span class="keyword">covariant</span> SizeChangedPainter oldDelegate) &#123;</span><br><span class="line">    <span class="comment">// 默认返回true，表示总是需要重绘</span></span><br><span class="line">    <span class="keyword">return</span> oldDelegate.animation.value != animation.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPainterPagePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> CustomPainterPagePage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;CustomPainterPagePage&gt; createState() =&gt; _CustomPainterPagePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CustomPainterPagePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CustomPainterPagePage</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">late</span> AnimationController _controller;</span><br><span class="line">  <span class="keyword">late</span> Animation&lt;<span class="built_in">double</span>&gt; _animation;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    _controller = AnimationController(</span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">      duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>),</span><br><span class="line">    );</span><br><span class="line">    _animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0.2</span>, end: <span class="number">3.0</span>).animate(_controller);</span><br><span class="line">    _controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      backgroundColor: <span class="keyword">const</span> Color(<span class="number">0xffF2F4F5</span>),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: [</span><br><span class="line">          CustomPaint(</span><br><span class="line">            painter: SizeChangedPainter(animation: _animation),</span><br><span class="line">            child: <span class="keyword">const</span> SizedBox(</span><br><span class="line">              width: <span class="number">200.0</span>,</span><br><span class="line">              height: <span class="number">200.0</span>,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子可以看出将 <code>Animation&lt;double&gt;</code>  通过构造函数赋值给成员变量 <code>repaint</code> 。而 <code>repaint</code> 是 Listenable 可监听对象类型，当 <code>repaint</code> 也就是 <code>_animation</code> 值发送变化时，会通知画板调用 <code>paint</code> 实现重绘，效果如下：</p><p><img src="https://s2.loli.net/2024/04/11/kXIilhOQxYNUyFv.gif" alt="CustomPainter 重绘"></p><p>好了，先啰嗦到这里了，下篇来实现一个有难度点儿的自定义图形，敬请期待吧。我的公众号：<strong>Flutter技术实践</strong>，记得点赞加关注哦。</p><p><img src="https://s2.loli.net/2022/11/09/fNBn2gWw8tVazkr.jpg" alt="Flutter技术实践"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先来看看某互联网公司前端开发和产品的日常交流（互掐）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/04/10/yXcNRd6bonluQ14.png&quot; alt=&quot;前端开发和产品日常交流&quot;&gt;&lt;/p&gt;
&lt;p&gt;很精彩吧，这种故事经常在互联网公司上演，那你可能会问这和本篇文章有什么关系呢？答案是没有关系。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter 日常开发小技巧</title>
    <link href="http://www.nnxkcloud.com/2024/04/08/Flutter-%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.nnxkcloud.com/2024/04/08/Flutter-%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2024-04-08T07:18:26.000Z</published>
    <updated>2024-10-15T03:05:34.688Z</updated>
    
    <content type="html"><![CDATA[<p>收集了一些日常开发中会用到技巧或者语法糖，简化代码，提升开发效率。</p><span id="more"></span><h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h2><p>在 <code>Dart</code> 中，我们可以为扩展任何数据类型，而任何函数都能转换成数据类型，所以，我们也可以在 <code>Dart</code> 中扩展任何类型的函数，函数扩展是通过扩展方法的方式实现的，通过使用 <code>extension</code> 关键字。其目的就是为了提高代码的可读性和可维护性。</p><p>如下面的例子，为 <code>String</code> 类型添加了一个名为 <code>capitalize()</code> 的方法，用于将字符串的首字母大写。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> StringExtensions <span class="keyword">on</span> <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> capitalize() &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + substring(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DartTipsPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> DartTipsPage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;DartTipsPage&gt; createState() =&gt; _DartTipsPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DartTipsPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DartTipsPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">String</span> text = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(text.capitalize()); <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以直接给函数类型创建 <code>extension</code>，在函数之上添加功能。如下例，为函数类型添加延迟调用的功能。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="keyword">on</span> VoidCallback &#123;</span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; delayedCall(</span><br><span class="line">      <span class="built_in">Duration</span> duration,</span><br><span class="line">      ) =&gt;</span><br><span class="line">      Future&lt;<span class="keyword">void</span>&gt;.delayed(duration, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DartTipsPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> DartTipsPage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;DartTipsPage&gt; createState() =&gt; _DartTipsPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DartTipsPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DartTipsPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    _click.delayedCall(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> _click()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;delayedCall&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>VoidCallback</code> 是一种已经转换为数据类型的函数类型，所以我们也可以为其添加扩展。</p><h2 id="安全数组"><a href="#安全数组" class="headerlink" title="安全数组"></a>安全数组</h2><p>在 <code>Flutter</code> 开发时，碰到数组越界或者访问数组中不存在的元素情况时，会引起运行时错误，如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">print</span>(numbers[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>尝试访问索引为 5 的元素，但数组长度只有 5 个元素，就会触发数组越界错误，<code>Flutter</code> 报错信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RangeError (index): Index out of range: index should be less than 5: 5</span><br></pre></td></tr></table></figure><p>当然也可以使用 <code>try-catch</code> 来捕获异常，但使用起来有些繁琐，很多时候问题没法儿及时发现和修复，那有没有更好的办法呢？当然有，自定义一个继承自 <code>ListBase</code> 的类：<code>SafeList</code>，其代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:collection&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ListBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;T&gt; _list;</span><br><span class="line">  <span class="comment">// 调用 set 方法修改 length 的时候，若大于当前数组的长度时，就使用 defaultValue 填充</span></span><br><span class="line">  <span class="keyword">final</span> T defaultValue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在数组中查询不存在的值时，即数组越界时，返回 absentValue</span></span><br><span class="line">  <span class="keyword">final</span> T absentValue;</span><br><span class="line"></span><br><span class="line">  SafeList(&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.defaultValue,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.absentValue,</span><br><span class="line">    <span class="built_in">List</span>&lt;T&gt;? values,</span><br><span class="line">  &#125;) : _list = values ?? [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  T <span class="keyword">operator</span> [](<span class="built_in">int</span> index) =&gt; index &lt; _list.length ? _list[index] : absentValue;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span> []=(<span class="built_in">int</span> index, T value) =&gt; _list[index] = value;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> length =&gt; _list.length;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  T <span class="keyword">get</span> first =&gt; _list.isNotEmpty ? _list.first : absentValue;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  T <span class="keyword">get</span> last =&gt; _list.isNotEmpty ? _list.last : absentValue;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">set</span> length(<span class="built_in">int</span> newValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &lt; _list.length) &#123;</span><br><span class="line">      _list.length = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _list.addAll(<span class="built_in">List</span>.filled(newValue - _list.length, defaultValue));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> notFound = <span class="string">&#x27;Value Not Found&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> defaultString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> SafeList&lt;<span class="built_in">String</span>&gt; myList = SafeList(</span><br><span class="line">  defaultValue: defaultString,</span><br><span class="line">  absentValue: notFound,</span><br><span class="line">  values: [<span class="string">&#x27;Flutter&#x27;</span>, <span class="string">&#x27;iOS&#x27;</span>, <span class="string">&#x27;Android&#x27;</span>],</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myList[<span class="number">0</span>]); <span class="comment">// Flutter</span></span><br><span class="line"><span class="built_in">print</span>(myList[<span class="number">1</span>]); <span class="comment">// iOS</span></span><br><span class="line"><span class="built_in">print</span>(myList[<span class="number">2</span>]); <span class="comment">// Android</span></span><br><span class="line"><span class="built_in">print</span>(myList[<span class="number">3</span>]); <span class="comment">// Value Not Found</span></span><br><span class="line"></span><br><span class="line">myList.length = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">print</span>(myList[<span class="number">4</span>]); <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">myList.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">print</span>(myList.first); <span class="comment">// Value Not Found</span></span><br><span class="line"><span class="built_in">print</span>(myList.last); <span class="comment">// Value Not Found</span></span><br></pre></td></tr></table></figure><h2 id="获取图片宽高比"><a href="#获取图片宽高比" class="headerlink" title="获取图片宽高比"></a>获取图片宽高比</h2><p>获取图片的宽高比在 <code>Flutter</code> 开发中是一个很常见的需求，可以帮助我们更加精准的地控制UI布局，特别是需要设置图片宽高的时候，做响应式布局的时候也需要根据图片的宽高比动态调整UI布局。</p><p>在 <code>ImageStream</code> 的 <code>addListener</code> 回调中使用的 <code>Completer</code>，用来处理Future对象的完成和结果传递。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span> <span class="keyword">show</span> Completer;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span> <span class="keyword">as</span> material</span><br><span class="line">    <span class="keyword">show</span> Image, ImageConfiguration, ImageStreamListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> GetImageAspectRatio <span class="keyword">on</span> material.Image &#123;</span><br><span class="line">  Future&lt;<span class="built_in">double</span>&gt; getAspectRatio() &#123;</span><br><span class="line">    <span class="keyword">final</span> completer = Completer&lt;<span class="built_in">double</span>&gt;();</span><br><span class="line">    image.resolve(<span class="keyword">const</span> material.ImageConfiguration()).addListener(</span><br><span class="line">      material.ImageStreamListener(</span><br><span class="line">            (imageInfo, synchronousCall) &#123;</span><br><span class="line">          <span class="keyword">final</span> aspectRatio = imageInfo.image.width / imageInfo.image.height;</span><br><span class="line">          imageInfo.image.dispose();</span><br><span class="line">          completer.complete(aspectRatio);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> completer.future;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DartTipsPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DartTipsPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _getImageAspectRatio(); <span class="comment">// 打印结果：2.8160919540229883</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _getImageAspectRatio() <span class="keyword">async</span> &#123;</span><br><span class="line">    Image wxIcon = Image.asset(<span class="string">&quot;images/wx_icon.png&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> aspectRatio = <span class="keyword">await</span> wxIcon.getAspectRatio();</span><br><span class="line">    <span class="built_in">print</span>(aspectRatio);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      backgroundColor: <span class="keyword">const</span> Color(<span class="number">0xffffffff</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动添加间距"><a href="#自动添加间距" class="headerlink" title="自动添加间距"></a>自动添加间距</h2><p><code>Flutter</code> 的 <code>Row</code> 或者 <code>Column</code> 需要在元素之间添加相同间距的时候经常会有这样的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Row(</span><br><span class="line">  crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  children: [</span><br><span class="line">    _hasFirstSpacing ? SizedBox(width: <span class="number">20</span>,) : Container(),</span><br><span class="line">    Text(<span class="string">&quot;Flutter&quot;</span>),</span><br><span class="line">    SizedBox(width: <span class="number">20</span>,),</span><br><span class="line">    Text(<span class="string">&quot;ReactNative&quot;</span>),</span><br><span class="line">    SizedBox(width: <span class="number">20</span>,),</span><br><span class="line">    Text(<span class="string">&quot;uni-app&quot;</span>),</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>而且有的情况是第一个间距是否添加还需要根据条件来判断，这样重复的代码太多，可读性也比较差，有没有一种更优雅的方式呢？来看看下面的实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RowWithSpacing</span> <span class="keyword">extends</span> <span class="title">Row</span> </span>&#123;</span><br><span class="line">  RowWithSpacing(&#123;</span><br><span class="line">    <span class="keyword">super</span>.key,</span><br><span class="line">    <span class="built_in">double</span> spacing = <span class="number">8</span>,</span><br><span class="line">    <span class="comment">// 是否需要在开头添加间距</span></span><br><span class="line">    <span class="built_in">bool</span> existLeadingSpace = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">super</span>.mainAxisAlignment,</span><br><span class="line">    <span class="keyword">super</span>.mainAxisSize,</span><br><span class="line">    <span class="keyword">super</span>.crossAxisAlignment,</span><br><span class="line">    <span class="keyword">super</span>.textDirection,</span><br><span class="line">    <span class="keyword">super</span>.verticalDirection,</span><br><span class="line">    <span class="keyword">super</span>.textBaseline,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> [],</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(</span><br><span class="line">    children: [</span><br><span class="line">      ...existLeadingSpace ? [SizedBox(width: spacing)] : &lt;Widget&gt;[],</span><br><span class="line">      ...children.expand(</span><br><span class="line">            (w) =&gt; [</span><br><span class="line">          w,</span><br><span class="line">          SizedBox(width: spacing),</span><br><span class="line">        ],</span><br><span class="line">      )</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是继承 <code>Row</code> ，在自定义类 <code>RowWithSpacing</code> 内部自动添加 <code>spacing</code>，将上面的例子改成使用 <code>RowWithSpacing</code> ，代码是不是也清爽多了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RowWithSpacing(</span><br><span class="line">  crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  existLeadingSpace: <span class="keyword">true</span>,</span><br><span class="line">  spacing: <span class="number">20</span>,</span><br><span class="line">  children: [</span><br><span class="line">    Text(<span class="string">&quot;Flutter&quot;</span>),</span><br><span class="line">    Text(<span class="string">&quot;ReactNative&quot;</span>),</span><br><span class="line">    Text(<span class="string">&quot;uniapp&quot;</span>),</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>以上这些技巧代码量都不多，简单轻便，拿来就用，日常开发中也能带来不少方便，代码和测试的 <code>Demo</code> 放在了老地方，不知道的先关注公众号后，回复源码就能看到。原创不易，您的关注是我更新下去最大的动力。</p><p><img src="https://s2.loli.net/2022/11/09/fNBn2gWw8tVazkr.jpg" alt="Flutter技术实践"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;收集了一些日常开发中会用到技巧或者语法糖，简化代码，提升开发效率。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
